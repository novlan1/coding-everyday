(window.webpackJsonp=window.webpackJsonp||[]).push([[150],{453:function(o,t,s){"use strict";s.r(t);var a=s(25),_=Object(a.a)({},(function(){var o=this,t=o._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":o.$parent.slotKey}},[t("ul",[t("li",[t("a",{attrs:{href:"#1-react-hooks"}},[o._v("1. React Hooks")]),o._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#11-hook-%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99"}},[o._v("1.1. Hook 使用规则")])]),o._v(" "),t("li",[t("a",{attrs:{href:"#12-hook-%E5%A6%82%E4%BD%95%E6%8A%8A%E8%B0%83%E7%94%A8%E5%92%8C%E7%BB%84%E4%BB%B6%E8%81%94%E7%B3%BB%E8%B5%B7%E6%9D%A5%E7%9A%84"}},[o._v("1.2. Hook 如何把调用和组件联系起来的？")])]),o._v(" "),t("li",[t("a",{attrs:{href:"#13-%E7%B1%BB%E7%BB%84%E4%BB%B6%E7%9A%84%E4%B8%8D%E8%B6%B3"}},[o._v("1.3. 类组件的不足")])]),o._v(" "),t("li",[t("a",{attrs:{href:"#14-hooks-%E4%BC%98%E5%8A%BF"}},[o._v("1.4. hooks 优势")])])])])]),o._v(" "),t("h2",{attrs:{id:"_1-react-hooks"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-react-hooks"}},[o._v("#")]),o._v(" 1. React Hooks")]),o._v(" "),t("p",[o._v("Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数。Hook 不能在 class 组件中使用")]),o._v(" "),t("h3",{attrs:{id:"_1-1-hook-使用规则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-hook-使用规则"}},[o._v("#")]),o._v(" 1.1. Hook 使用规则")]),o._v(" "),t("ul",[t("li",[o._v("只能在函数最外层调用 Hook。不可在循环、条件判断或者子函数中调用。")]),o._v(" "),t("li",[o._v("只能在 React 的函数组件或自定义的 Hook 中调用 Hook。不要在其他 JavaScript 函数中调用。")])]),o._v(" "),t("p",[o._v("可以使用"),t("code",[o._v("eslint-plugin-react-hooks")]),o._v("来检测，在 Webpack 中添加配置如下：")]),o._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[o._v('  "eslintConfig": {\n    "extends": "react-app",\n    "plugins": [\n      "react-hooks"\n    ],\n    "rules": {\n      "react-hooks/rules-of-hooks":"error"\n    }\n  },\n')])])]),t("h3",{attrs:{id:"_1-2-hook-如何把调用和组件联系起来的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-hook-如何把调用和组件联系起来的"}},[o._v("#")]),o._v(" 1.2. Hook 如何把调用和组件联系起来的？")]),o._v(" "),t("p",[o._v("React 保持对当先渲染中的组件的追踪。多亏了 Hook 规范，我们得知 Hook 只会在 React 组件中被调用（或自定义 Hook —— 同样只会在 React 组件中被调用）。")]),o._v(" "),t("p",[o._v("每个组件内部都有一个「记忆单元格」列表。它们只不过是我们用来存储一些数据的 JavaScript 对象。当你用 useState() 调用一个 Hook 的时候，它会读取当前的单元格（或在首次渲染时将其初始化），然后把指针移动到下一个。这就是多个 useState() 调用会得到各自独立的本地 state 的原因。")]),o._v(" "),t("h3",{attrs:{id:"_1-3-类组件的不足"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-类组件的不足"}},[o._v("#")]),o._v(" 1.3. 类组件的不足")]),o._v(" "),t("ul",[t("li",[o._v("状态逻辑难以复用\n"),t("ul",[t("li",[o._v("缺少复用机制\n"),t("ul",[t("li",[o._v("不方便封装逻辑，使用渲染属性和高阶组件也有缺点")])])]),o._v(" "),t("li",[o._v("渲染属性和高阶组件导致层级冗余\n"),t("ul",[t("li",[o._v("无论是高阶组件还是渲染属性，都相当与在原来的组件之上增加了新的组件层次。尤其是在 Chrome 调试器上会看到为了服用逻辑而添加的狠多组件层级，显得十分臃肿。不仅是调试体验问题、也存在着运行性能的问题")])])])])]),o._v(" "),t("li",[o._v("趋向复杂时难以维护\n"),t("ul",[t("li",[o._v("生命周期函数函数混杂不相干逻辑")]),o._v(" "),t("li",[o._v("相关逻辑代码经常会打散到不同生命周期中")])])]),o._v(" "),t("li",[o._v("this 指向困扰\n"),t("ul",[t("li",[o._v("内联函数需要绑定 this, 否则每次渲染都创建一个箭头函数")]),o._v(" "),t("li",[o._v("类成员函数不能保证 this")])])])]),o._v(" "),t("h3",{attrs:{id:"_1-4-hooks-优势"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-hooks-优势"}},[o._v("#")]),o._v(" 1.4. hooks 优势")]),o._v(" "),t("ul",[t("li",[o._v("函数组件无类实例 this 问题\n"),t("ul",[t("li",[o._v("hooks 是函数组件环境，所有逻辑都在函数内部，没有实例化概念，无复杂的 this 问题")])])]),o._v(" "),t("li",[o._v("自定义 Hook 函数方便复用状态逻辑\n"),t("ul",[t("li",[o._v("hooks 指的是在函数内部调用的特殊函数，我们可以自定义 hooks 函数，在 hooks 函数内部，依旧可以调用 useState 和 useEffect 等 hooks 函数。这样就可以非常高效的将可复用逻辑提取出来")])])]),o._v(" "),t("li",[o._v("副作用的关注点分离\n"),t("ul",[t("li",[o._v("hooks 天生优化了副作用代码逻辑\n"),t("ul",[t("li",[o._v("每个 useEffect 来实现一个逻辑，不同逻辑写在不同的 useEffect 中，比冗在同一生命周期中好很多")]),o._v(" "),t("li",[o._v("以前副作用大都是写在生命函数周期中")])])]),o._v(" "),t("li",[o._v("副作用：\n"),t("ul",[t("li",[o._v("发送网络请求")]),o._v(" "),t("li",[o._v("访问原始 DOM 元素")]),o._v(" "),t("li",[o._v("访问本地存储")]),o._v(" "),t("li",[o._v("绑定解绑事件")])])])])])])])}),[],!1,null,null,null);t.default=_.exports}}]);