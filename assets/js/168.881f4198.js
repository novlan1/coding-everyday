(window.webpackJsonp=window.webpackJsonp||[]).push([[168],{473:function(e,t,v){"use strict";v.r(t);var r=v(25),_=Object(r.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h3",{attrs:{id:"_1-双向数据绑定的原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-双向数据绑定的原理"}},[e._v("#")]),e._v(" 1. 双向数据绑定的原理")]),e._v(" "),t("p",[e._v("vue数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的。")]),e._v(" "),t("ol",[t("li",[e._v("要实现数据的双向绑定，首先要对数据进行劫持监听，所以我们需要设置一个监听器Observer，用来监听所有属性。")]),e._v(" "),t("li",[e._v("如果属性发上变化了，就需要告诉订阅者Watcher看是否需要更新。")]),e._v(" "),t("li",[e._v("因为订阅者是有很多个，所以我们需要有一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理的。")]),e._v(" "),t("li",[e._v("接着，我们还需要有一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令（如v-model，v-on）对应初始化成一个订阅者Watcher，并替换模板数据或者绑定相应的函数，此时当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。")])]),e._v(" "),t("p",[e._v("因此接下去我们执行以下3个步骤，实现数据的双向绑定：")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("实现一个监听器Observer，用来"),t("strong",[e._v("劫持并监听所有属性")]),e._v("，如果有变动的，就通知订阅者。")])]),e._v(" "),t("li",[t("p",[e._v("实现一个订阅者Watcher，"),t("strong",[e._v("每一个Watcher都绑定一个更新函数")]),e._v("，watcher可以收到属性的变化通知并执行相应的函数，从而更新视图。")])]),e._v(" "),t("li",[t("p",[e._v("实现一个解析器Compile，可以"),t("strong",[e._v("扫描和解析每个节点的相关指令")]),e._v("（v-model，v-on等指令），如果节点存在v-model，v-on等指令，则解析器Compile"),t("strong",[e._v("初始化这类节点的模板数据")]),e._v("，使之可以显示在视图上，然后"),t("strong",[e._v("初始化相应的订阅者（Watcher）")]),e._v("。")])])]),e._v(" "),t("p",[t("img",{attrs:{src:"/imgs/vue_mvvm.png",alt:"MVVM"}})]),e._v(" "),t("h3",{attrs:{id:"_2-proxy-相比于-defineproperty-的优势"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-proxy-相比于-defineproperty-的优势"}},[e._v("#")]),e._v(" 2. Proxy 相比于 defineProperty 的优势")]),e._v(" "),t("ol",[t("li",[t("code",[e._v("Object.defineProperty")]),e._v("无法监控到数组下标的变化，导致直接通过数组的下标给数组设置值，不能实时响应。 为了解决这个问题，经过vue内部处理后可以使用以下几种方法来监听数组")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("push()\npop()\nshift()\nunshift()\nsplice()\nsort()\nreverse()\n")])])]),t("p",[e._v("由于只针对了以上八种方法进行了hack处理,所以其他数组的属性也是检测不到的，还是具有一定的局限性。")]),e._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[t("code",[e._v("Object.defineProperty")]),e._v("只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历。Vue 2.x里，是通过 "),t("code",[e._v("递归 + 遍历")]),e._v(" data 对象来实现对数据的监控的，如果属性值也是对象那么需要深度遍历,显然如果能劫持一个完整的对象是才是更好的选择。\n而要取代它的Proxy有以下两个优点;\n"),t("ul",[t("li",[e._v("可以劫持整个对象，并返回一个新对象")]),e._v(" "),t("li",[e._v("有13种劫持操作")])])])])])}),[],!1,null,null,null);t.default=_.exports}}]);