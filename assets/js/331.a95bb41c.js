(window.webpackJsonp=window.webpackJsonp||[]).push([[331],{630:function(t,_,a){"use strict";a.r(_);var v=a(25),s=Object(v.a)({},(function(){var t=this,_=t._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("ul",[_("li",[_("a",{attrs:{href:"#1-git-%E5%92%8C-svn-%E7%9A%84%E5%8C%BA%E5%88%AB"}},[t._v("1. Git 和 SVN 的区别")])]),t._v(" "),_("li",[_("a",{attrs:{href:"#2-git-%E7%9A%84%E4%BC%98%E5%8A%BF"}},[t._v("2. Git 的优势")])]),t._v(" "),_("li",[_("a",{attrs:{href:"#3-git-%E7%9A%84%E5%8E%86%E5%8F%B2"}},[t._v("3. Git 的历史")])]),t._v(" "),_("li",[_("a",{attrs:{href:"#4-git-%E5%8F%AA%E8%83%BD%E8%BF%BD%E8%B8%AA%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E7%9A%84%E5%8F%98%E5%8A%A8"}},[t._v("4. Git 只能追踪文本文件的变动")])]),t._v(" "),_("li",[_("a",{attrs:{href:"#5-git-%E5%9B%9B%E4%B8%AA%E5%8C%BA%E5%9F%9F"}},[t._v("5. Git 四个区域")])]),t._v(" "),_("li",[_("a",{attrs:{href:"#6-git-%E7%AE%A1%E7%90%86%E7%9A%84%E6%96%87%E4%BB%B6%E6%9C%89%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81"}},[t._v("6. Git 管理的文件有三种状态")])]),t._v(" "),_("li",[_("a",{attrs:{href:"#7-github-%E6%8A%80%E5%B7%A7"}},[t._v("7. Github 技巧")])]),t._v(" "),_("li",[_("a",{attrs:{href:"#8-git-add%E5%90%8E%E9%9D%A2%E7%9A%84%E5%8F%82%E6%95%B0"}},[t._v("8. "),_("code",[t._v("git add")]),t._v("后面的参数")])]),t._v(" "),_("li",[_("a",{attrs:{href:"#9-git-%E6%80%8E%E4%B9%88%E7%9F%A5%E9%81%93%E5%93%AA%E4%B8%AA%E7%89%88%E6%9C%AC%E5%9C%A8%E5%85%88%E5%93%AA%E4%B8%AA%E7%89%88%E6%9C%AC%E5%9C%A8%E5%90%8E"}},[t._v("9. Git 怎么知道哪个版本在先哪个版本在后？")])]),t._v(" "),_("li",[_("a",{attrs:{href:"#10-git-%E4%B8%AD%E7%9A%84-head-%E8%A1%A8%E7%A4%BA%E4%BB%80%E4%B9%88"}},[t._v("10. Git 中的 HEAD 表示什么")])]),t._v(" "),_("li",[_("a",{attrs:{href:"#11-%E5%BF%AB%E8%BF%9B%E6%A8%A1%E5%BC%8F"}},[t._v("11. 快进模式")])]),t._v(" "),_("li",[_("a",{attrs:{href:"#12-git-%E9%85%8D%E7%BD%AE"}},[t._v("12. Git 配置")]),t._v(" "),_("ul",[_("li",[_("a",{attrs:{href:"#121-%E6%9F%A5%E7%9C%8B%E4%B8%8D%E5%90%8C%E7%BA%A7%E5%88%AB%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"}},[t._v("12.1. 查看不同级别的配置文件")])]),t._v(" "),_("li",[_("a",{attrs:{href:"#122-git-%E7%9B%B8%E5%85%B3%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%9C%89%E4%B8%89%E4%B8%AA"}},[t._v("12.2. Git 相关的配置文件有三个")])]),t._v(" "),_("li",[_("a",{attrs:{href:"#123-%E9%85%8D%E7%BD%AE%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E9%82%AE%E7%AE%B1"}},[t._v("12.3. 配置用户名和邮箱")])])])]),t._v(" "),_("li",[_("a",{attrs:{href:"#13-%E6%9F%A5%E7%9C%8B%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF%E4%B8%8E%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E7%9A%84%E8%BF%BD%E8%B8%AA"}},[t._v("13. 查看本地分支与远程分支的追踪")])]),t._v(" "),_("li",[_("a",{attrs:{href:"#14-bug-%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6"}},[t._v("14. bug 分支合并")])]),t._v(" "),_("li",[_("a",{attrs:{href:"#15-gitignore%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8"}},[t._v("15. "),_("code",[t._v(".gitignore")]),t._v("不起作用")])]),t._v(" "),_("li",[_("a",{attrs:{href:"#16-git-rm-%E4%B8%8E-git-rm---cached"}},[t._v("16. "),_("code",[t._v("git rm")]),t._v(" 与 "),_("code",[t._v("git rm --cached")])])]),t._v(" "),_("li",[_("a",{attrs:{href:"#17-%E5%B8%B8%E7%94%A8-git-stash-%E5%91%BD%E4%BB%A4"}},[t._v("17. 常用 "),_("code",[t._v("git stash")]),t._v(" 命令")])]),t._v(" "),_("li",[_("a",{attrs:{href:"#18-git%E5%88%97%E5%87%BA%E6%89%80%E6%9C%89%E5%B7%B2%E7%BB%8F%E8%B7%9F%E8%B8%AA%E6%96%87%E4%BB%B6"}},[t._v("18. git列出所有已经跟踪文件")])]),t._v(" "),_("li",[_("a",{attrs:{href:"#19-git-commit%E6%8A%A5did-not-match-any-file-known-to-git%E7%9A%84%E9%94%99%E8%AF%AF%E7%9A%84%E9%97%AE%E9%A2%98"}},[t._v("19. "),_("code",[t._v("git commit")]),t._v("报"),_("code",[t._v("did not match any file known to git")]),t._v("的错误的问题")])]),t._v(" "),_("li",[_("a",{attrs:{href:"#20-git-rebase-%E5%92%8C-git-merge-%E7%9A%84%E5%8C%BA%E5%88%AB"}},[t._v("20. git rebase 和 git merge 的区别")]),t._v(" "),_("ul",[_("li",[_("a",{attrs:{href:"#201-%E5%8F%98%E5%9F%BA%E7%9A%84%E9%A3%8E%E9%99%A9"}},[t._v("20.1. 变基的风险")])])])])]),t._v(" "),_("h3",{attrs:{id:"_1-git-和-svn-的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-git-和-svn-的区别"}},[t._v("#")]),t._v(" 1. Git 和 SVN 的区别")]),t._v(" "),_("p",[t._v("Git 是"),_("strong",[t._v("分布式*的版本控制工具，每一个你pull下来的git仓库都是主仓库的一个分布式版本，仓库的内容完全一样。\n而SVN不然，它需要一个")]),t._v("中央版本"),_("strong",[t._v("来")]),t._v("集中控制**。\n分布式版本控制不依赖与网络，有更改需要提交但又无法联网时，可以把更改提交到本地仓库，有网络的时候再将本地仓库和远程的主仓库进行同步。")]),t._v(" "),_("h3",{attrs:{id:"_2-git-的优势"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-git-的优势"}},[t._v("#")]),t._v(" 2. Git 的优势")]),t._v(" "),_("ul",[_("li",[t._v("分布式版本控制系统，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了。")]),t._v(" "),_("li",[t._v("安全性要高很多，因为每个人电脑里都有"),_("strong",[t._v("完整的版本库")]),t._v("，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。")])]),t._v(" "),_("h3",{attrs:{id:"_3-git-的历史"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-git-的历史"}},[t._v("#")]),t._v(" 3. Git 的历史")]),t._v(" "),_("p",[t._v("Git 是 用 C 开发的，一个公司威胁要收回原来的免费使用权，Linus 用了两周的时间做出了 Git。")]),t._v(" "),_("h3",{attrs:{id:"_4-git-只能追踪文本文件的变动"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-git-只能追踪文本文件的变动"}},[t._v("#")]),t._v(" 4. Git 只能追踪文本文件的变动")]),t._v(" "),_("ul",[_("li",[t._v("所有的版本控制系统，其实只能跟踪"),_("strong",[t._v("文本文件")]),t._v("的改动，比如 TXT 文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。")]),t._v(" "),_("li",[t._v("而"),_("strong",[t._v("图片、视频")]),t._v("这些"),_("strong",[t._v("二进制文件")]),t._v("，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。")]),t._v(" "),_("li",[t._v("不幸的是，Microsoft 的 Word 格式是二进制格式，因此，版本控制系统是没法跟踪 Word 文件的改动的")])]),t._v(" "),_("h3",{attrs:{id:"_5-git-四个区域"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-git-四个区域"}},[t._v("#")]),t._v(" 5. Git 四个区域")]),t._v(" "),_("p",[t._v("git跟传统的代码管理器（如:svn）不同， 主要区别在于git多了个"),_("strong",[t._v("本地仓库以及缓存区")]),t._v("，所以即使无法联网也一样能提交代码。")]),t._v(" "),_("ul",[_("li",[t._v("工作区间：即我们创建的工程文件， 在编辑器可直观显示；")]),t._v(" "),_("li",[t._v("缓存区：只能通过git GUI或git shell 窗口显示，提交代码、解决冲突的中转站；")]),t._v(" "),_("li",[t._v("本地仓库：只能在git shell 窗口显示，连接本地代码跟远程代码的枢纽，不能联网时本地代码可先提交至该处；")]),t._v(" "),_("li",[t._v("远程仓库：即保存我们代码的服务器，本文以公共版本控制系统：github为例，登录github账号后可直观显示；")])]),t._v(" "),_("p",[_("img",{attrs:{src:"/imgs/git_repos.jpg",alt:"git 仓库"}})]),t._v(" "),_("h3",{attrs:{id:"_6-git-管理的文件有三种状态"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-git-管理的文件有三种状态"}},[t._v("#")]),t._v(" 6. Git 管理的文件有三种状态")]),t._v(" "),_("ul",[_("li",[t._v("已修改（"),_("code",[t._v("modified")]),t._v("）")]),t._v(" "),_("li",[t._v("已暂存（"),_("code",[t._v("staged")]),t._v("）")]),t._v(" "),_("li",[t._v("已提交("),_("code",[t._v("committed")]),t._v(")")])]),t._v(" "),_("h3",{attrs:{id:"_7-github-技巧"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-github-技巧"}},[t._v("#")]),t._v(" 7. Github 技巧")]),t._v(" "),_("ol",[_("li",[t._v("在"),_("code",[t._v("issue")]),t._v("中回复他人时，可以使用引用模式，回答具体某人的问题，"),_("code",[t._v(">")]),t._v("某人具体的问题；有可以引用某人回答过的答案，点击某人的那条回答，地址栏会得到该回答的链接，在评论里插入这个链接即可。")]),t._v(" "),_("li",[t._v("针对某个"),_("code",[t._v("issue")]),t._v("可以插入代码，新建代码后，"),_("code",[t._v("commit")]),t._v("时"),_("code",[t._v("title")]),t._v("最后加 "),_("code",[t._v("#1")]),t._v("(1表示"),_("code",[t._v("issue")]),t._v("编号) ，若最后加上"),_("code",[t._v("fix #1")]),t._v("，则会关闭该"),_("code",[t._v("issue")]),t._v("。")]),t._v(" "),_("li",[t._v("快捷键"),_("code",[t._v("T")]),t._v("，打开检索文件功能")])]),t._v(" "),_("h3",{attrs:{id:"_8-git-add后面的参数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-git-add后面的参数"}},[t._v("#")]),t._v(" 8. "),_("code",[t._v("git add")]),t._v("后面的参数")]),t._v(" "),_("ul",[_("li",[_("code",[t._v("git add -u")]),t._v("：提交被修改(modified)和被删除(deleted)文件，不包括新文件(new)。")]),t._v(" "),_("li",[_("code",[t._v("git add .")]),t._v("：提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件。")]),t._v(" "),_("li",[_("code",[t._v("git add -A")]),t._v("：提交所有变化，包括以上2种。")])]),t._v(" "),_("h3",{attrs:{id:"_9-git-怎么知道哪个版本在先哪个版本在后"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9-git-怎么知道哪个版本在先哪个版本在后"}},[t._v("#")]),t._v(" 9. Git 怎么知道哪个版本在先哪个版本在后？")]),t._v(" "),_("p",[t._v("因为还保存了父版本号")]),t._v(" "),_("h3",{attrs:{id:"_10-git-中的-head-表示什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_10-git-中的-head-表示什么"}},[t._v("#")]),t._v(" 10. Git 中的 HEAD 表示什么")]),t._v(" "),_("p",[t._v("git 中的分支，其实本质上仅仅是个指向 commit 对象的可变指针。git 是如何知道你当前在哪个分支上工作的呢？\n其实答案也很简单，它保存着一个名为 HEAD 的特别指针。在 git 中，它是一个"),_("strong",[t._v("指向你正在工作中的本地分支的指针")]),t._v("，可以将 HEAD 想象为当前分支的别名。")]),t._v(" "),_("ul",[_("li",[t._v("一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向 master，就能确定当前分支，以及当前分支的提交点。")]),t._v(" "),_("li",[t._v("当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上。")]),t._v(" "),_("li",[t._v("Git怎么合并呢？最简单的方法，就是直接把 master 指向d ev 的当前提交，就完成了合并。")])]),t._v(" "),_("p",[t._v("一般情况下，用"),_("code",[t._v("HEAD")]),t._v("表示"),_("strong",[t._v("当前版本")]),t._v("，也就是最新的提交"),_("code",[t._v("1094adb")]),t._v("...（注意我的提交ID和你的肯定不一样），上一个版本就是"),_("code",[t._v("HEAD^")]),t._v("，上上一个版本就是"),_("code",[t._v("HEAD^^")]),t._v("，当然往上100个版本写100个^比较容易数不过来，所以写成"),_("code",[t._v("HEAD~100")]),t._v("。")]),t._v(" "),_("h3",{attrs:{id:"_11-快进模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_11-快进模式"}},[t._v("#")]),t._v(" 11. 快进模式")]),t._v(" "),_("ul",[_("li",[t._v("快进模式，也就是"),_("strong",[t._v("直接把 master 指向 dev 的当前提交")]),t._v("，所以合并速度非常快。")]),t._v(" "),_("li",[t._v("合并分支时，加上"),_("code",[t._v("--no-ff")]),t._v("参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而"),_("code",[t._v("fast forward")]),t._v("合并就"),_("strong",[t._v("看不出来曾经做过合并")]),t._v("。")])]),t._v(" "),_("h3",{attrs:{id:"_12-git-配置"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_12-git-配置"}},[t._v("#")]),t._v(" 12. Git 配置")]),t._v(" "),_("h4",{attrs:{id:"_12-1-查看不同级别的配置文件"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_12-1-查看不同级别的配置文件"}},[t._v("#")]),t._v(" 12.1. 查看不同级别的配置文件")]),t._v(" "),_("ul",[_("li",[t._v("查看系统config\n"),_("code",[t._v("git config --system --list")])]),t._v(" "),_("li",[t._v("查看当前用户（global）配置\n"),_("code",[t._v("git config --global --list")])]),t._v(" "),_("li",[t._v("查看当前仓库配置信息\n"),_("code",[t._v("git config --local --list")])])]),t._v(" "),_("h4",{attrs:{id:"_12-2-git-相关的配置文件有三个"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_12-2-git-相关的配置文件有三个"}},[t._v("#")]),t._v(" 12.2. Git 相关的配置文件有三个")]),t._v(" "),_("ol",[_("li",[_("code",[t._v("/etc/gitconfig")]),t._v("：包含了适用于系统所有用户和所有项目的值。("),_("code",[t._v("Win：C:\\Program Files\\Git\\mingw64\\etc\\gitconfig")]),t._v(") ，"),_("code",[t._v("--system")]),t._v(" 系统级")]),t._v(" "),_("li",[_("code",[t._v("~/.gitconfig")]),t._v("：只适用于当前登录用户的配置。("),_("code",[t._v("Win：C:\\Users\\Administrator\\.gitconfig")]),t._v(")，  "),_("code",[t._v("--global")]),t._v(" 全局")]),t._v(" "),_("li",[t._v("位于git项目目录中的"),_("code",[t._v(".git/config")]),t._v("：适用于特定git项目的配置。("),_("code",[t._v("Win：C:\\gitProject")]),t._v(") ，"),_("code",[t._v("--local")]),t._v("当前项目")])]),t._v(" "),_("p",[t._v("1）添加配置项\n"),_("code",[t._v("git config [--local|--global|--system] section.key value")])]),t._v(" "),_("ul",[_("li",[_("code",[t._v("[--local|--global|--system]")]),t._v("，可选的，对应本地，全局，系统不同级别的设置")]),t._v(" "),_("li",[_("code",[t._v("section.key")]),t._v("，区域下的键")]),t._v(" "),_("li",[_("code",[t._v("value")]),t._v("，对应的值")])]),t._v(" "),_("p",[t._v("2）删除配置项\n"),_("code",[t._v("git config [--local|--global|--system] --unset section.key")])]),t._v(" "),_("h4",{attrs:{id:"_12-3-配置用户名和邮箱"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_12-3-配置用户名和邮箱"}},[t._v("#")]),t._v(" 12.3. 配置用户名和邮箱")]),t._v(" "),_("p",[t._v("当你安装Git后首先要做的事情是设置你的用户名称和"),_("code",[t._v("e-mail")]),t._v("地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中：")]),t._v(" "),_("div",{staticClass:"language-bash extra-class"},[_("pre",{pre:!0,attrs:{class:"language-bash"}},[_("code",[_("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" config "),_("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("--global")]),t._v(" user.name "),_("span",{pre:!0,attrs:{class:"token string"}},[t._v('"zhangguo"')]),t._v("  "),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#名称")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" config "),_("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("--global")]),t._v(" user.email zhangguo@qq.com   "),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#邮箱")]),t._v("\n")])])]),_("p",[t._v("只需要做一次这个设置，如果你传递了"),_("code",[t._v("--global")]),t._v(" 选项，因为Git将总是会使用该信息来处理你在系统中所做的一切操作。如果你希望在一个特定的项目中使用不同的名称或"),_("code",[t._v("e-mail")]),t._v("地址，你可以在该项目中运行该命令而不要"),_("code",[t._v("--global")]),t._v("选项。 总之"),_("code",[t._v("--global")]),t._v("为全局配置，不加为某个项目的特定配置。")]),t._v(" "),_("h3",{attrs:{id:"_13-查看本地分支与远程分支的追踪"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_13-查看本地分支与远程分支的追踪"}},[t._v("#")]),t._v(" 13. 查看本地分支与远程分支的追踪")]),t._v(" "),_("p",[_("code",[t._v("git branch -vv")])]),t._v(" "),_("h3",{attrs:{id:"_14-bug-分支合并"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_14-bug-分支合并"}},[t._v("#")]),t._v(" 14. bug 分支合并")]),t._v(" "),_("p",[t._v("在"),_("code",[t._v("master")]),t._v("分支上修复的bug，提交后，想要合并到当前"),_("code",[t._v("dev")]),t._v("分支，可以"),_("code",[t._v("dev")]),t._v("分支上用"),_("code",[t._v("git cherry-pick <commit>")]),t._v("命令，把 bug 提交的修改“复制”到当前分支，避免重复劳动。")]),t._v(" "),_("h3",{attrs:{id:"_15-gitignore不起作用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_15-gitignore不起作用"}},[t._v("#")]),t._v(" 15. "),_("code",[t._v(".gitignore")]),t._v("不起作用")]),t._v(" "),_("p",[_("code",[t._v(".gitignore")]),t._v("中已经标明忽略的文件目录下的文件，"),_("code",[t._v("git push")]),t._v("的时候还会出现在 push 的目录中，原因是因为在 git 忽略目录中，新建的文件在 git 中会有"),_("strong",[t._v("缓存")]),t._v("，如果某些文件已经被纳入了版本管理中，就算是在"),_("code",[t._v(".gitignore")]),t._v("中已经声明了忽略路径也是不起作用的，这时候我们就应该先把本地缓存删除，然后再进行 git 的 push，这样就不会出现忽略的文件了。")]),t._v(" "),_("p",[t._v("git清除本地缓存命令如下：")]),t._v(" "),_("div",{staticClass:"language-bash extra-class"},[_("pre",{pre:!0,attrs:{class:"language-bash"}},[_("code",[_("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token function"}},[t._v("rm")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-r")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("--cached")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v(".")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v(".")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" commit "),_("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-m")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token string"}},[t._v("'update .gitignore'")]),t._v("\n")])])]),_("h3",{attrs:{id:"_16-git-rm-与-git-rm-cached"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_16-git-rm-与-git-rm-cached"}},[t._v("#")]),t._v(" 16. "),_("code",[t._v("git rm")]),t._v(" 与 "),_("code",[t._v("git rm --cached")])]),t._v(" "),_("p",[t._v("1.当我们需要删除暂存区或分支上的文件，同时"),_("strong",[t._v("工作区")]),t._v("也不需要这个文件了，可以使用")]),t._v(" "),_("div",{staticClass:"language-bash extra-class"},[_("pre",{pre:!0,attrs:{class:"language-bash"}},[_("code",[_("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token function"}},[t._v("rm")]),t._v(" file_path\n")])])]),_("p",[t._v("2.当我们需要删除暂存区或分支上的文件，但"),_("strong",[t._v("本地又需要使用")]),t._v("，只是"),_("strong",[t._v("不希望这个文件被版本控制")]),t._v("，可以使用")]),t._v(" "),_("div",{staticClass:"language-bash extra-class"},[_("pre",{pre:!0,attrs:{class:"language-bash"}},[_("code",[_("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token function"}},[t._v("rm")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("--cached")]),t._v(" file_path\n")])])]),_("h3",{attrs:{id:"_17-常用-git-stash-命令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_17-常用-git-stash-命令"}},[t._v("#")]),t._v(" 17. 常用 "),_("code",[t._v("git stash")]),t._v(" 命令")]),t._v(" "),_("ol",[_("li",[_("code",[t._v('git stash save "save message"')]),t._v("  : 执行存储时，添加备注，方便查找，只有"),_("code",[t._v("git stash")]),t._v(" 也要可以的，但查找时不方便识别。")]),t._v(" "),_("li",[_("code",[t._v("git stash list")]),t._v("  ：查看 stash 了哪些存储")]),t._v(" "),_("li",[_("code",[t._v("git stash show")]),t._v(" ：显示做了哪些改动，默认 show 第一个存储,如果要显示其他存贮，后面加"),_("code",[t._v("stash@{$num}")]),t._v("，比如第二个 "),_("code",[t._v("git stash show stash@{1}")])]),t._v(" "),_("li",[_("code",[t._v("git stash show -p")]),t._v(" : 显示第一个存储的改动，如果想显示其他存存储，命令："),_("code",[t._v("git stash show stash@{$num} -p")]),t._v(" ，比如第二个："),_("code",[t._v("git stash show stash@{1} -p")])]),t._v(" "),_("li",[_("code",[t._v("git stash apply")]),t._v(" :应用某个存储,但不会把存储从存储列表中删除，默认使用第一个存储，即"),_("code",[t._v("stash@{0}")]),t._v("，如果要使用其他个，"),_("code",[t._v("git stash apply stash@{$num}")]),t._v(" ， 比如第二个："),_("code",[t._v("git stash apply stash@{1}")])]),t._v(" "),_("li",[_("code",[t._v("git stash pop")]),t._v(" ：命令恢复之前缓存的工作目录，将缓存堆栈中的对应stash删除，并将对应修改应用到当前的工作目录下，默认为第一个 stash，即"),_("code",[t._v("stash@{0}")]),t._v("，如果要应用并删除其他 stash，命令："),_("code",[t._v("git stash pop stash@{$num}")]),t._v("，比如应用并删除第二个："),_("code",[t._v("git stash pop stash@{1}")])]),t._v(" "),_("li",[_("code",[t._v("git stash drop stash@{$num}")]),t._v(" ：丢弃"),_("code",[t._v("stash@{$num}")]),t._v("存储，从列表中删除这个存储")]),t._v(" "),_("li",[_("code",[t._v("git stash clear")]),t._v(" ：删除所有缓存的 stash")])]),t._v(" "),_("p",[t._v("说明：新增的文件，直接执行 stash 是不会被存储的\n先执行下"),_("code",[t._v("git add")]),t._v(" 加到git版本控制中，然后再"),_("code",[t._v("git stash")]),t._v("就可以了")]),t._v(" "),_("h3",{attrs:{id:"_18-git列出所有已经跟踪文件"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_18-git列出所有已经跟踪文件"}},[t._v("#")]),t._v(" 18. git列出所有已经跟踪文件")]),t._v(" "),_("div",{staticClass:"language-bash extra-class"},[_("pre",{pre:!0,attrs:{class:"language-bash"}},[_("code",[_("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" ls-tree "),_("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-r")]),t._v(" master --name-only\n")])])]),_("h3",{attrs:{id:"_19-git-commit报did-not-match-any-file-known-to-git的错误的问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_19-git-commit报did-not-match-any-file-known-to-git的错误的问题"}},[t._v("#")]),t._v(" 19. "),_("code",[t._v("git commit")]),t._v("报"),_("code",[t._v("did not match any file known to git")]),t._v("的错误的问题")]),t._v(" "),_("p",[_("code",[t._v("git commit -m “changed one thing”")]),t._v("使用双引号，而不是单引号")]),t._v(" "),_("h3",{attrs:{id:"_20-git-rebase-和-git-merge-的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_20-git-rebase-和-git-merge-的区别"}},[t._v("#")]),t._v(" 20. git rebase 和 git merge 的区别")]),t._v(" "),_("p",[t._v("git merge 和 git rebase 都是用于分支合并，关键在 commit 记录的处理上不同。")]),t._v(" "),_("p",[t._v("git merge 会新建一个新的 commit 对象，然后两个分支以前的 commit 记录都指向这个新 commit 记录。这种方法会\n保留之前每个分支的 commit 历史。")]),t._v(" "),_("p",[t._v("git rebase 会先找到两个分支的第一个共同的 commit 祖先记录，然后将提取当前分支这之后的所有 commit 记录，然后\n将这个 commit 记录添加到目标分支的最新提交后面。经过这个合并后，两个分支合并后的 commit 记录就变为了线性的记\n录了。")]),t._v(" "),_("h4",{attrs:{id:"_20-1-变基的风险"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_20-1-变基的风险"}},[t._v("#")]),t._v(" 20.1. 变基的风险")]),t._v(" "),_("p",[_("strong",[t._v("不要对在你的仓库外有副本的分支执行变基。")]),t._v(" 如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用 git rebase 命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。")])])}),[],!1,null,null,null);_.default=s.exports}}]);