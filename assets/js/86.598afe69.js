(window.webpackJsonp=window.webpackJsonp||[]).push([[86],{358:function(_,v,a){"use strict";a.r(v);var t=a(14),e=Object(t.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("ul",[v("li",[v("a",{attrs:{href:"#1-solid-%E4%BA%94%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"}},[_._v("1. "),v("code",[_._v("SOLID")]),_._v(" 五大设计原则")]),_._v("\n- "),v("a",{attrs:{href:"#101-%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE"}},[_._v("1.0.1. 依赖倒置")]),_._v("\n- "),v("a",{attrs:{href:"#102-%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2"}},[_._v("1.0.2. 里氏替换")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#2-23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%9B%E5%BB%BA%E5%9E%8B%E7%BB%84%E5%90%88%E5%9E%8B%E8%A1%8C%E4%B8%BA%E5%9E%8B"}},[_._v("2. 23种设计模式：创建型、组合型、行为型")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#3-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"}},[_._v("3. 工厂模式")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#4-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"}},[_._v("4. 抽象工厂模式")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#5-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"}},[_._v("5. 单例模式")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#6-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"}},[_._v("6. 适配器模式")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#7-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F"}},[_._v("7. 装饰器模式")]),_._v("\n- "),v("a",{attrs:{href:"#701-%E9%80%82%E9%85%8D%E5%99%A8%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB"}},[_._v("7.0.1. 适配器和装饰器的区别")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#8-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"}},[_._v("8. 代理模式")]),_._v("\n- "),v("a",{attrs:{href:"#801-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-vs-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"}},[_._v("8.0.1. 代理模式 vs 适配器模式")]),_._v("\n- "),v("a",{attrs:{href:"#802-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-vs-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F"}},[_._v("8.0.2. 代理模式 vs 装饰器模式")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#9-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F"}},[_._v("9. 外观模式")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#10-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"}},[_._v("10. 观察者模式")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#11-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F"}},[_._v("11. 迭代器模式")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#12-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F"}},[_._v("12. 状态模式")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#13-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"}},[_._v("13. 原型模式")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#14-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F"}},[_._v("14. 桥接模式")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#15-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F"}},[_._v("15. 组合模式")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#16-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F"}},[_._v("16. 享元模式")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#17-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"}},[_._v("17. 策略模式")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#18-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95"}},[_._v("18. 模板方法")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#19-%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F"}},[_._v("19. 职责链模式")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#20-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"}},[_._v("20. 命令模式")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#21-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F"}},[_._v("21. 备忘录模式")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#22-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F"}},[_._v("22. 中介者模式")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#23-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F"}},[_._v("23. 访问者模式")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#24-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F"}},[_._v("24. 解释器模式")])])]),_._v(" "),v("h2",{attrs:{id:"设计模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#设计模式"}},[_._v("#")]),_._v(" 设计模式 ")]),_._v(" "),v("h3",{attrs:{id:"_1-solid-五大设计原则"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-solid-五大设计原则"}},[_._v("#")]),_._v(" 1. "),v("code",[_._v("SOLID")]),_._v(" 五大设计原则")]),_._v(" "),v("ul",[v("li",[_._v("S，单一职责原则。"),v("code",[_._v("single")]),_._v("，一个程序只做好一件事，如果功能过于复杂就拆分开，每个部分保持独立。")]),_._v(" "),v("li",[_._v("O，开放封闭原则。"),v("code",[_._v("open-close")]),_._v("，对扩展开放，对修改封闭。增加需求，扩展新代码，而非修改已有代码。")]),_._v(" "),v("li",[_._v("L，里氏置换原则。子类能覆盖父类。所有父类能出现的地方，子类就能出现。JS使用较少（弱类型&继承使用少）")]),_._v(" "),v("li",[_._v("I，接口独立原则。保持接口的单一独立，避免出现‘胖接口’。JS中没有接口，使用较少。\n类似于单一职责原则，这里更关注接口。")]),_._v(" "),v("li",[_._v("D，依赖倒置原则。面向接口编程，依赖于抽象而不依赖于具体。 使用方只关注接口而不关注具体类的实现。 JS使用较少（没有接口&弱类型）")])]),_._v(" "),v("p",[v("code",[_._v("S O")]),_._v("体现较多，"),v("code",[_._v("L I D")]),_._v("体现较少")]),_._v(" "),v("h5",{attrs:{id:"_1-0-1-依赖倒置"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-0-1-依赖倒置"}},[_._v("#")]),_._v(" 1.0.1. 依赖倒置")]),_._v(" "),v("p",[_._v("依赖倒置： "),v("code",[_._v("Dependence Inversion Principle")]),_._v("("),v("code",[_._v("DIP")]),_._v("):高层模块不应该依赖底层模块，都应该依赖于抽象；抽象不应该依赖于具体，具体依赖于抽象。\n例子：福特和本田汽车")]),_._v(" "),v("h5",{attrs:{id:"_1-0-2-里氏替换"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-0-2-里氏替换"}},[_._v("#")]),_._v(" 1.0.2. 里氏替换")]),_._v(" "),v("p",[_._v("里氏替换原则包含以下4层含义：")]),_._v(" "),v("ol",[v("li",[_._v("子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法。")]),_._v(" "),v("li",[_._v("子类中可以增加自己特有的方法。")]),_._v(" "),v("li",[_._v("当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。")]),_._v(" "),v("li",[_._v("当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。")])]),_._v(" "),v("h3",{attrs:{id:"_2-23种设计模式-创建型、组合型、行为型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-23种设计模式-创建型、组合型、行为型"}},[_._v("#")]),_._v(" 2. 23种设计模式：创建型、组合型、行为型")]),_._v(" "),v("ul",[v("li",[_._v("创建型：工厂模式（工厂方法模式、抽象方法模式、建造者模式）、单例模式、原型模式")]),_._v(" "),v("li",[_._v("结构型：适配器、装饰器、代理、外观模式、桥接、组合、享元模式")]),_._v(" "),v("li",[_._v("行为型：观察者模式、迭代器模式、状态模式、策略、模板方法、职责链、命令、备忘录、中介者、访问者、解释器模式")])]),_._v(" "),v("h3",{attrs:{id:"_3-工厂模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-工厂模式"}},[_._v("#")]),_._v(" 3. 工厂模式")]),_._v(" "),v("ol",[v("li",[_._v("将 new 操作单独封装")]),_._v(" "),v("li",[_._v("遇到 new 时，就要考虑是否使用工厂模式")])]),_._v(" "),v("p",[_._v("特点：\n创建实例的时候有统一的入口，收口。构造函数和创建者分离。符合开放封闭原则。")]),_._v(" "),v("p",[_._v("场景：")]),_._v(" "),v("ol",[v("li",[v("code",[_._v("jQuery - $(‘div’)")])]),_._v(" "),v("li",[v("code",[_._v("React.createElement")])]),_._v(" "),v("li",[_._v("vue 异步组件")])]),_._v(" "),v("p",[v("code",[_._v("React.createElement")]),_._v("创建的是 vnode 的实例")]),_._v(" "),v("div",{staticClass:"language-js extra-class"},[v("pre",{pre:!0,attrs:{class:"language-js"}},[v("code",[_._v("React"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),v("span",{pre:!0,attrs:{class:"token function-variable function"}},[_._v("createElement")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token operator"}},[_._v("=")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("function")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),v("span",{pre:!0,attrs:{class:"token parameter"}},[_._v("tag"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(",")]),_._v(" attrs"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(",")]),_._v(" children")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("{")]),_._v("\n\t"),v("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("return")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("new")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token class-name"}},[_._v("Vnode")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),_._v("tag"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(",")]),_._v(" attrs"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(",")]),_._v(" children"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),_._v("\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("}")]),_._v("\n")])])]),v("h3",{attrs:{id:"_4-抽象工厂模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-抽象工厂模式"}},[_._v("#")]),_._v(" 4. 抽象工厂模式")]),_._v(" "),v("p",[_._v("抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。")]),_._v(" "),v("h3",{attrs:{id:"_5-单例模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-单例模式"}},[_._v("#")]),_._v(" 5. 单例模式")]),_._v(" "),v("ol",[v("li",[_._v("系统中被唯一使用")]),_._v(" "),v("li",[_._v("保证一个类只有一个实例，先判断实例存在与否，如果存在直接返回，不存在创建了再返回，就保证了一个类只有一个实例对象。")])]),_._v(" "),v("p",[_._v("设计原则验证：")]),_._v(" "),v("ol",[v("li",[_._v("符合单一职责原则，只实例化唯一的对象")]),_._v(" "),v("li",[_._v("没有体现开闭原则，但没违反开闭原则")])]),_._v(" "),v("p",[_._v("前端应用场景：")]),_._v(" "),v("ol",[v("li",[_._v("jQuey只有一个$")]),_._v(" "),v("li",[_._v("登录框")]),_._v(" "),v("li",[_._v("购物车")]),_._v(" "),v("li",[_._v("vuex 和 redux 中的 store")])]),_._v(" "),v("p",[_._v("其他应用场景：")]),_._v(" "),v("ol",[v("li",[_._v("Windows的"),v("code",[_._v("Task Manager")]),_._v("（任务管理器）就是很典型的单例模式（这个很熟悉吧），想想看，是不是呢，你能打开两个"),v("code",[_._v("windows task manager")]),_._v("吗？")]),_._v(" "),v("li",[_._v("windows的"),v("code",[_._v("Recycle Bin")]),_._v("（回收站）也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例")]),_._v(" "),v("li",[_._v("应用程序的日志应用，一般都用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加")]),_._v(" "),v("li",[_._v("Web应用的配置对象的读取，一般也应用单例模式，这个是由于配置文件是共享的资源。")]),_._v(" "),v("li",[_._v("数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。数据库软件系统中使用数据库连接池，主要是节省打开或者关闭数据库连接所引起的效率损耗，这种效率上的损耗还是非常昂贵的，因为何用单例模式来维护，就可以大大降低这种损耗")]),_._v(" "),v("li",[_._v("多线程的线程池的设计一般也是采用单例模式，这是由于线程池要方便对池中的线程进行控制")]),_._v(" "),v("li",[_._v("操作系统的文件系统，也是大的单例模式实现的具体例子，一个操作系统只能有一个文件系统")])]),_._v(" "),v("p",[_._v("单例模式应用的场景一般发生在以下条件下：\n（1）资源共享的情况下，避免由于资源操作时导致的性能或损耗等。如上述中的日志文件，应用配置。\n（2）控制资源的情况下，方便资源之间的互相通信。如线程池等。")]),_._v(" "),v("h3",{attrs:{id:"_6-适配器模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-适配器模式"}},[_._v("#")]),_._v(" 6. 适配器模式")]),_._v(" "),v("ol",[v("li",[_._v("旧接口格式和使用者不兼容")]),_._v(" "),v("li",[_._v("中间加一个适配器转换接口（开闭原则）")])]),_._v(" "),v("p",[_._v("场景：")]),_._v(" "),v("ol",[v("li",[_._v("封装旧接口（比如"),v("code",[_._v("jQuery")]),_._v("中的"),v("code",[_._v("$.ajax({})")]),_._v("）")]),_._v(" "),v("li",[v("code",[_._v("Vue computed")])])]),_._v(" "),v("h3",{attrs:{id:"_7-装饰器模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-装饰器模式"}},[_._v("#")]),_._v(" 7. 装饰器模式")]),_._v(" "),v("p",[_._v("无需子类化扩展对象功能。")]),_._v(" "),v("ol",[v("li",[_._v("为对象添加新功能")]),_._v(" "),v("li",[_._v("不改变其原有的结构和功能")])]),_._v(" "),v("p",[_._v("场景：")]),_._v(" "),v("ol",[v("li",[_._v("ES7装饰器")]),_._v(" "),v("li",[v("code",[_._v("core-decorators")]),_._v("（封装了一些常见的装饰器，比如"),v("code",[_._v("readonly")]),_._v("，"),v("code",[_._v("deprecate")]),_._v("(提示此方法已经废弃)）")]),_._v(" "),v("li",[_._v("设置为只读")]),_._v(" "),v("li",[_._v("打印日志")])]),_._v(" "),v("h5",{attrs:{id:"_7-0-1-适配器和装饰器的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-0-1-适配器和装饰器的区别"}},[_._v("#")]),_._v(" 7.0.1. 适配器和装饰器的区别")]),_._v(" "),v("p",[_._v("适配器是原有的根本不能用了，装饰器是在"),v("code",[_._v("a b c")]),_._v("功能上增加"),v("code",[_._v("e f")]),_._v("功能（手机壳）")]),_._v(" "),v("h3",{attrs:{id:"_8-代理模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-代理模式"}},[_._v("#")]),_._v(" 8. 代理模式")]),_._v(" "),v("p",[_._v("把一个对象的操作代理到另一个对象（deque=>stack）。")]),_._v(" "),v("ol",[v("li",[_._v("使用者无权访问目标对象")]),_._v(" "),v("li",[_._v("中间加代理，通过代理做授权和控制")])]),_._v(" "),v("p",[_._v("示例：")]),_._v(" "),v("ol",[v("li",[_._v("科学上网")]),_._v(" "),v("li",[_._v("明星经纪人")])]),_._v(" "),v("p",[_._v("场景：")]),_._v(" "),v("ol",[v("li",[_._v("网页事件代理")]),_._v(" "),v("li",[_._v("jQuery 的"),v("code",[_._v("$.proxy")])]),_._v(" "),v("li",[_._v("ES6 的"),v("code",[_._v("proxy")])])]),_._v(" "),v("h5",{attrs:{id:"_8-0-1-代理模式-vs-适配器模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-0-1-代理模式-vs-适配器模式"}},[_._v("#")]),_._v(" 8.0.1. 代理模式 vs 适配器模式")]),_._v(" "),v("ol",[v("li",[_._v("适配器模式：提供一个不同的接口")]),_._v(" "),v("li",[_._v("代理模式：提供一模一样的接口")])]),_._v(" "),v("h5",{attrs:{id:"_8-0-2-代理模式-vs-装饰器模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-0-2-代理模式-vs-装饰器模式"}},[_._v("#")]),_._v(" 8.0.2. 代理模式 vs 装饰器模式")]),_._v(" "),v("ol",[v("li",[_._v("装饰器模式：扩展功能，原有功能不变且可以直接使用")]),_._v(" "),v("li",[_._v("代理模式：显示原有功能，但是经过限制或者阉割之后的")])]),_._v(" "),v("h3",{attrs:{id:"_9-外观模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_9-外观模式"}},[_._v("#")]),_._v(" 9. 外观模式")]),_._v(" "),v("p",[_._v("简化复杂对象的访问问题。")]),_._v(" "),v("ol",[v("li",[_._v("为子系统中的一组接口提供了一个高层接口")]),_._v(" "),v("li",[_._v("使用者使用这个高层接口")])]),_._v(" "),v("p",[_._v("场景：\n兼容传3个参数和传4个参数")]),_._v(" "),v("p",[_._v("设计原则验证：\n不符合单一职责和开放封闭原则，谨慎使用")]),_._v(" "),v("h3",{attrs:{id:"_10-观察者模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_10-观察者模式"}},[_._v("#")]),_._v(" 10. 观察者模式")]),_._v(" "),v("ol",[v("li",[_._v("前端使用最多")]),_._v(" "),v("li",[_._v("发布&订阅")]),_._v(" "),v("li",[_._v("可以一对多")])]),_._v(" "),v("p",[_._v("场景：")]),_._v(" "),v("ol",[v("li",[_._v("网页事件绑定")]),_._v(" "),v("li",[_._v("Promise")]),_._v(" "),v("li",[v("code",[_._v("jQuery callbacks")])]),_._v(" "),v("li",[_._v("NodeJS 自定义事件")]),_._v(" "),v("li",[_._v("NodeJS 中：处理 http 请求；多进程通讯")]),_._v(" "),v("li",[_._v("Vue 和 React 组件生命周期触发")]),_._v(" "),v("li",[_._v("Vue 的"),v("code",[_._v("watch")])])]),_._v(" "),v("p",[_._v("设计原则验证：")]),_._v(" "),v("ol",[v("li",[_._v("主题和观察者分离，不是主动触发而是被动监听，两者解耦")]),_._v(" "),v("li",[_._v("符合开发封闭原则")])]),_._v(" "),v("h3",{attrs:{id:"_11-迭代器模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_11-迭代器模式"}},[_._v("#")]),_._v(" 11. 迭代器模式")]),_._v(" "),v("ol",[v("li",[_._v("顺序访问一个集合")]),_._v(" "),v("li",[_._v("使用者无需知道集合的内部结构（封装）")])]),_._v(" "),v("p",[_._v("场景：")]),_._v(" "),v("ol",[v("li",[_._v("jQuery 的"),v("code",[_._v("each")])]),_._v(" "),v("li",[_._v("ES6 的"),v("code",[_._v("Iterator")])])]),_._v(" "),v("p",[_._v("ES6 的"),v("code",[_._v("Iterator")]),_._v("为何存在？")]),_._v(" "),v("ol",[v("li",[_._v("有序集合很多，"),v("code",[_._v("Array Map Set String TypedArray arguments NodeList")])]),_._v(" "),v("li",[v("code",[_._v("Object")]),_._v("不是有序集合，可以用"),v("code",[_._v("Map")]),_._v("代替")]),_._v(" "),v("li",[_._v("需要一个统一的遍历接口来遍历所有数据类型")])]),_._v(" "),v("p",[_._v("ES6 "),v("code",[_._v("Iterator")]),_._v("是什么？")]),_._v(" "),v("ol",[v("li",[_._v("以上数据类型都有"),v("code",[_._v("[Symbol.iterator]")]),_._v("属性")]),_._v(" "),v("li",[_._v("属性值是函数，执行函数返回一个迭代器")]),_._v(" "),v("li",[_._v("这个迭代器有"),v("code",[_._v("next")]),_._v("方法可顺序迭代子元素")]),_._v(" "),v("li",[_._v("可运行"),v("code",[_._v("Array.prototype[Symbol.iterator]")]),_._v("来测试")])]),_._v(" "),v("h3",{attrs:{id:"_12-状态模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_12-状态模式"}},[_._v("#")]),_._v(" 12. 状态模式")]),_._v(" "),v("ol",[v("li",[_._v("一个对象有状态变化")]),_._v(" "),v("li",[_._v("每次状态变化都会触发一个逻辑")]),_._v(" "),v("li",[_._v("不能总是用"),v("code",[_._v("if else")]),_._v("来控制")])]),_._v(" "),v("p",[_._v("场景：")]),_._v(" "),v("ol",[v("li",[_._v("有限状态机（如交通信号灯）")]),_._v(" "),v("li",[_._v("写一个简单的"),v("code",[_._v("Promise")])])]),_._v(" "),v("h3",{attrs:{id:"_13-原型模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_13-原型模式"}},[_._v("#")]),_._v(" 13. 原型模式")]),_._v(" "),v("ol",[v("li",[v("code",[_._v("clone")]),_._v("自己，生成一个新对象（"),v("code",[_._v("new")]),_._v("开销大）")]),_._v(" "),v("li",[_._v("Java 默认有"),v("code",[_._v("clone")]),_._v("接口，不用自己实现")]),_._v(" "),v("li",[_._v("通过克隆原型来创建新的实例")]),_._v(" "),v("li",[_._v("可以使用相同的原型，通过修改部分属性来创建新的实例")]),_._v(" "),v("li",[_._v("用途：对于一些创建实例开销比较大的地方可以使用原型模式")])]),_._v(" "),v("p",[_._v("JS中的应用："),v("code",[_._v("Object.create")])]),_._v(" "),v("h3",{attrs:{id:"_14-桥接模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_14-桥接模式"}},[_._v("#")]),_._v(" 14. 桥接模式")]),_._v(" "),v("ol",[v("li",[_._v("用于把抽象化与实现化解耦")]),_._v(" "),v("li",[_._v("使得二者可以独立变化")])]),_._v(" "),v("p",[_._v("比如：画图时，颜色有黄色和绿色，图形有矩形和三角形，它们的两两组合可以称为桥接。")]),_._v(" "),v("h3",{attrs:{id:"_15-组合模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_15-组合模式"}},[_._v("#")]),_._v(" 15. 组合模式")]),_._v(" "),v("ol",[v("li",[_._v("生成树形结构，表示‘整体-部分’关系")]),_._v(" "),v("li",[_._v("让整体和部分都具有一致的操作方式")])]),_._v(" "),v("p",[_._v("比如，文件夹包含文件和子文件夹，子文件夹又包含子子文件夹和文件，...")]),_._v(" "),v("p",[_._v("场景：\n虚拟DOM中的"),v("code",[_._v("vnode")]),_._v("是组合模式，但数据类型简单。")]),_._v(" "),v("h3",{attrs:{id:"_16-享元模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_16-享元模式"}},[_._v("#")]),_._v(" 16. 享元模式")]),_._v(" "),v("p",[_._v("通过对象复用（池）改善资源利用，比如连接池。")]),_._v(" "),v("ol",[v("li",[_._v("共享内存（主要考虑内存，而非效率）")]),_._v(" "),v("li",[_._v("相同的数据，共享使用")])]),_._v(" "),v("p",[_._v("事件代理可以看成享元模式的思想。")]),_._v(" "),v("h3",{attrs:{id:"_17-策略模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_17-策略模式"}},[_._v("#")]),_._v(" 17. 策略模式")]),_._v(" "),v("ol",[v("li",[_._v("不同策略分开处理")]),_._v(" "),v("li",[_._v("避免出现大量"),v("code",[_._v("if else")]),_._v("或者"),v("code",[_._v("switch case")])])]),_._v(" "),v("h3",{attrs:{id:"_18-模板方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_18-模板方法"}},[_._v("#")]),_._v(" 18. 模板方法")]),_._v(" "),v("p",[_._v("对自己内部的有顺序的方法封装")]),_._v(" "),v("h3",{attrs:{id:"_19-职责链模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_19-职责链模式"}},[_._v("#")]),_._v(" 19. 职责链模式")]),_._v(" "),v("ol",[v("li",[_._v("一个操作可能分为多个职责角色来完成")]),_._v(" "),v("li",[_._v("把这些角色都分开，然后用一个链串起来")]),_._v(" "),v("li",[_._v("将发起者和各个处理者进行隔离")])]),_._v(" "),v("p",[_._v("链式操作场景：")]),_._v(" "),v("ul",[v("li",[_._v("jQuery 的链式操作")]),_._v(" "),v("li",[v("code",[_._v("Promise.then")]),_._v("的链式操作")])]),_._v(" "),v("h3",{attrs:{id:"_20-命令模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_20-命令模式"}},[_._v("#")]),_._v(" 20. 命令模式")]),_._v(" "),v("ol",[v("li",[_._v("执行命令时，发布者和执行者分开")]),_._v(" "),v("li",[_._v("中间加入命令对象，作为中转站")])]),_._v(" "),v("p",[_._v("一级嵌套一级，"),v("code",[_._v("Invoker")]),_._v("调用"),v("code",[_._v("command")]),_._v("的"),v("code",[_._v("cmd")]),_._v("命令，"),v("code",[_._v("cmd")]),_._v("方法中又调用了"),v("code",[_._v("Receiver")]),_._v("的"),v("code",[_._v("exec")]),_._v("命令。")]),_._v(" "),v("p",[_._v("JS 中的应用")]),_._v(" "),v("ol",[v("li",[_._v("网页富文本编辑器操作，浏览器封装了一个命令对象")]),_._v(" "),v("li",[v("code",[_._v("document.exexCommand(‘bold’)")])]),_._v(" "),v("li",[v("code",[_._v("document.exexCommand(‘undo)")])])]),_._v(" "),v("h3",{attrs:{id:"_21-备忘录模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_21-备忘录模式"}},[_._v("#")]),_._v(" 21. 备忘录模式")]),_._v(" "),v("ol",[v("li",[_._v("随时记录一个对象的状态变化")]),_._v(" "),v("li",[_._v("随时可以恢复之前的某个状态（如撤销功能）")])]),_._v(" "),v("h3",{attrs:{id:"_22-中介者模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_22-中介者模式"}},[_._v("#")]),_._v(" 22. 中介者模式")]),_._v(" "),v("p",[_._v("比如，买房子和卖房子的中介。")]),_._v(" "),v("h3",{attrs:{id:"_23-访问者模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_23-访问者模式"}},[_._v("#")]),_._v(" 23. 访问者模式")]),_._v(" "),v("p",[_._v("将数据操作和数据结构进行分离")]),_._v(" "),v("h3",{attrs:{id:"_24-解释器模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_24-解释器模式"}},[_._v("#")]),_._v(" 24. 解释器模式")]),_._v(" "),v("ol",[v("li",[_._v("描述语言语法如何定义，如何解释和编译")]),_._v(" "),v("li",[_._v("用于专业场景（"),v("code",[_._v("babel")]),_._v("、"),v("code",[_._v("less")]),_._v("、"),v("code",[_._v("sass")]),_._v("）")])])])}),[],!1,null,null,null);v.default=e.exports}}]);