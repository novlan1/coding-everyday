(window.webpackJsonp=window.webpackJsonp||[]).push([[153],{424:function(t,n,e){"use strict";e.r(n);var a=e(14),s=Object(a.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("ul",[n("li",[n("a",{attrs:{href:"#1-hooks-%E4%B8%8E%E5%AE%9A%E6%97%B6%E5%99%A8"}},[t._v("1. hooks 与定时器")]),t._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"#11-%E9%94%99%E8%AF%AF%E7%9A%84%E5%AE%9A%E6%97%B6%E5%99%A8%E7%94%A8%E6%B3%95"}},[t._v("1.1. 错误的定时器用法")])]),t._v(" "),n("li",[n("a",{attrs:{href:"#12-%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%AE%9A%E6%97%B6%E5%99%A8%E8%AE%BE%E7%BD%AE"}},[t._v("1.2. 正确的定时器设置")])]),t._v(" "),n("li",[n("a",{attrs:{href:"#13-%E6%80%9D%E8%80%83%E8%BF%99%E6%A0%B7%E8%83%BD%E4%B8%8D%E8%83%BD%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E5%99%A8%E6%95%88%E6%9E%9C"}},[t._v("1.3. 思考这样能不能实现定时器效果？")])])])])]),t._v(" "),n("h2",{attrs:{id:"_1-hooks-与定时器"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-hooks-与定时器"}},[t._v("#")]),t._v(" 1. hooks 与定时器")]),t._v(" "),n("p",[t._v("在 hooks 中使用了定时器对于新手来说往往会出错，本文将介绍并剖析。")]),t._v(" "),n("h3",{attrs:{id:"_1-1-错误的定时器用法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-错误的定时器用法"}},[t._v("#")]),t._v(" 1.1. 错误的定时器用法")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function Counter() {\n  let [count, setCount] = useState(0);\n\n  useEffect(() => {\n    setInterval(() => {\n      setCount(count + 1);\n    }, 1000);\n  }, []);\n\n  return <h1>{count}</h1>;\n}\n")])])]),n("p",[t._v("页面上的 count 永远是 1，因为 useEffect 的依赖数组重没有包含 count。导致定时器中 count 永远是第一次渲染时的值，即 0 。页面上一直为 0+1 = 1")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function Counter() {\n  let [count, setCount] = useState(0);\n\n  useEffect(() => {\n    setInterval(() => {\n      setCount(count + 1);\n    }, 1000);\n  }, [count]);\n\n  return <h1>{count}</h1>;\n}\n")])])]),n("p",[t._v("现在在依赖数组中加入了 count，页面上的数值不一直为 1 了， 但是过不了一会儿，页面上的数字就会开始闪烁。 这是因为每次 count 变化后，都重新去运行了一遍 useEffect，导致生成了"),n("strong",[t._v("非常多的定时器")]),t._v("。页面上结果为：")]),t._v(" "),n("ul",[n("li",[t._v("0 + 1")]),t._v(" "),n("li",[t._v("1 + 1")]),t._v(" "),n("li",[t._v("2 + 1")]),t._v(" "),n("li",[t._v("3 + 1")]),t._v(" "),n("li",[t._v("4 + 1")]),t._v(" "),n("li",[t._v("...")])]),t._v(" "),n("p",[t._v("所以数字在闪烁。")]),t._v(" "),n("h3",{attrs:{id:"_1-2-正确的定时器设置"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-正确的定时器设置"}},[t._v("#")]),t._v(" 1.2. 正确的定时器设置")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function Counter() {\n  let [count, setCount] = useState(0);\n\n  useEffect(() => {\n    let id = setInterval(() => {\n      setCount(count + 1);\n    }, 1000);\n\n    return () => clearInterval(id);\n  }, [count]);\n\n  return <h1>{count}</h1>;\n}\n")])])]),n("p",[t._v("每下一次渲染前都用 useEffect 的 return 销毁掉之前生成的 定时器。")]),t._v(" "),n("p",[t._v("不过这样是比较耗费性能的，每一次加一都要执行一遍创建和销毁定时器。可以使用箭头函数的方式来更新 count。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function Counter() {\n  let [count, setCount] = useState(0);\n\n  useEffect(() => {\n    let id = setInterval(() => {\n      setCount((count) => count + 1);\n    }, 1000);\n\n    return () => clearInterval(id);\n  }, []);\n\n  return <h1>{count}</h1>;\n}\n")])])]),n("h3",{attrs:{id:"_1-3-思考这样能不能实现定时器效果"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-思考这样能不能实现定时器效果"}},[t._v("#")]),t._v(" 1.3. 思考这样能不能实现定时器效果？")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function Counter() {\n  let [count, setCount] = useState(0);\n\n  useEffect(() => {\n    let id = setInterval(() => {\n      setCount(count + 1);\n    }, 1000);\n    return () => clearInterval(id);\n  });\n\n  return <h1>{count}</h1>;\n}\n")])])]),n("p",[t._v("答案是：会。 看似没有把 count 放入依赖数组中，但不使用依赖数组的情况下，useEffect 会在第一次渲染之后和每次更新之后都会执行。这就使得每次渲染都能拿到最新的 count 值，这样就能实现定时器效果了。")]),t._v(" "),n("p",[t._v("不过，这会导致一个非常隐蔽的 BUG，参见 "),n("a",{attrs:{href:"https://overreacted.io/zh-hans/making-setinterval-declarative-with-react-hooks/#%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95",target:"_blank",rel:"noopener noreferrer"}},[t._v("Dan 的博客"),n("OutboundLink")],1)]),t._v(" "),n("p",[t._v("原因： setInterval 和它们不一样。当我们执行 clearInterval 和 setInterval 时，它们会进入时间队列里，如果我们频繁重渲染和重执行 effects，interval 有可能没有机会被执行！")])])}),[],!1,null,null,null);n.default=s.exports}}]);