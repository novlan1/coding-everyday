(window.webpackJsonp=window.webpackJsonp||[]).push([[533],{808:function(t,a,s){"use strict";s.r(a);var e=s(14),r=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"_1-chrome-架构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-chrome-架构"}},[t._v("#")]),t._v(" 1. Chrome 架构")]),t._v(" "),a("h3",{attrs:{id:"_1-1-多进程浏览器时代"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-多进程浏览器时代"}},[t._v("#")]),t._v(" 1.1. 多进程浏览器时代")]),t._v(" "),a("p",[t._v("查看 chrome 运行的进程的方法：右上角三个点 => 更多工具 => 任务管理器")]),t._v(" "),a("p",[t._v("最新的 Chrome 进程架构，可以参考下图：")]),t._v(" "),a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/b6/fc/b61cab529fa31301bde290813b4587fc.png?wh=1142*494",width:"600"}}),t._v(" "),a("p",[t._v("从图中可以看出，最新的 Chrome 浏览器包括："),a("strong",[t._v("1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程")]),t._v("。")]),t._v(" "),a("p",[t._v("下面我们来逐个分析下这几个进程的功能。")]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("浏览器进程")]),t._v("。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("渲染进程")]),t._v("。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("GPU 进程")]),t._v("。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("网络进程")]),t._v("。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("插件进程")]),t._v("。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。")])])]),t._v(" "),a("p",[t._v("讲到这里，现在你应该就可以回答文章开头提到的问题了：仅仅打开了 1 个页面，为什么有 4 个进程？因为打开 1 个页面至少需要 1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程，共 4 个；如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。")]),t._v(" "),a("p",[t._v("不过凡事都有两面性，虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题：")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("更高的资源占用")]),t._v("。因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。")]),t._v(" "),a("li",[a("strong",[t._v("更复杂的体系架构")]),t._v("。浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。")])]),t._v(" "),a("p",[t._v("对于上面这两个问题，Chrome 团队一直在寻求一种弹性方案，既可以解决资源占用高的问题，也可以解决复杂的体系架构的问题。")]),t._v(" "),a("h3",{attrs:{id:"_1-2-未来面向服务的架构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-未来面向服务的架构"}},[t._v("#")]),t._v(" 1.2. 未来面向服务的架构")]),t._v(" "),a("p",[t._v("为了解决这些问题，在 2016 年，Chrome 官方团队使用“面向服务的架构”（Services Oriented Architecture，简称 SOA）的思想设计了新的 Chrome 架构。也就是说 Chrome 整体架构会朝向现代操作系统所采用的“面向服务的架构” 方向发展，原来的各种模块会被重构成独立的服务（Service），每个服务（Service）都可以在独立的进程中运行，访问服务（Service）必须使用定义好的接口，通过 IPC 来通信，从而构建一个更内聚、松耦合、易于维护和扩展的系统，更好实现 Chrome 简单、稳定、高速、安全的目标。如果你对面向服务的架构感兴趣，你可以去网上搜索下资料，这里就不过多介绍了。")]),t._v(" "),a("p",[t._v("Chrome 最终要把 UI、数据库、文件、设备、网络等模块重构为基础服务，类似操作系统底层服务，下面是 Chrome“面向服务的架构”的进程模型图：")]),t._v(" "),a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/32/2a/329658fe821252db47b0964037a1de2a.png?wh=1142*582",width:"600"}}),t._v(" "),a("p",[t._v("目前 Chrome 正处在老的架构向服务化架构过渡阶段，这将是一个漫长的迭代过程。")]),t._v(" "),a("p",[t._v("Chrome 正在逐步构建 Chrome 基础服务（Chrome Foundation Service），如果你认为 Chrome 是“便携式操作系统”，那么 Chrome 基础服务便可以被视为该操作系统的“基础”系统服务层。")]),t._v(" "),a("p",[t._v("同时 Chrome 还提供灵活的弹性架构，在强大性能设备上会以多进程的方式运行基础服务，但是如果在资源受限的设备上（如下图），Chrome 会将很多服务整合到一个进程中，从而节省内存占用。")]),t._v(" "),a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/a9/76/a9ba86d7b03263fa3997d3733d958176.png?wh=1142*630",width:"600"}}),t._v(" "),a("h2",{attrs:{id:"_2-http-请求流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-http-请求流程"}},[t._v("#")]),t._v(" 2. HTTP 请求流程")]),t._v(" "),a("h3",{attrs:{id:"_2-1-浏览器端发起-http-请求流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-浏览器端发起-http-请求流程"}},[t._v("#")]),t._v(" 2.1. 浏览器端发起 HTTP 请求流程")]),t._v(" "),a("h4",{attrs:{id:"_2-1-1-构建请求"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-1-构建请求"}},[t._v("#")]),t._v(" 2.1.1. 构建请求")]),t._v(" "),a("p",[t._v("首先，浏览器构建请求行信息（如下所示），构建好后，浏览器准备发起网络请求。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("GET /index.html HTTP1.1\n")])])]),a("h4",{attrs:{id:"_2-1-2-查找缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-2-查找缓存"}},[t._v("#")]),t._v(" 2.1.2. 查找缓存")]),t._v(" "),a("p",[t._v("在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。其中，浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术。")]),t._v(" "),a("p",[t._v("当浏览器发现请求的资源已经在浏览器缓存中存有副本，它会拦截请求，返回该资源的副本，并直接结束请求，而不会再去源服务器重新下载。这样做的好处有：")]),t._v(" "),a("ul",[a("li",[t._v("缓解服务器端压力，提升性能（获取资源的耗时更短了）；")]),t._v(" "),a("li",[t._v("对于网站来说，缓存是实现快速资源加载的重要组成部分。")])]),t._v(" "),a("p",[t._v("当然，如果缓存查找失败，就会进入网络请求过程了。")]),t._v(" "),a("h4",{attrs:{id:"_2-1-3-准备-ip-地址和端口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-3-准备-ip-地址和端口"}},[t._v("#")]),t._v(" 2.1.3. 准备 IP 地址和端口")]),t._v(" "),a("p",[t._v("不过，先不急，在了解网络请求之前，我们需要先看看 HTTP 和 TCP 的关系。因为浏览器使用 "),a("strong",[t._v("HTTP 协议作为应用层协议")]),t._v("，用来封装请求的文本信息；并使用 "),a("strong",[t._v("TCP/IP 作传输层协议")]),t._v("将它发到网络上，所以在 HTTP 工作开始之前，浏览器需要通过 TCP 与服务器建立连接。也就是说 "),a("strong",[t._v("HTTP 的内容是通过 TCP 的传输数据阶段来实现的")]),t._v("。")]),t._v(" "),a("p",[t._v("那接下来你可以思考这么“一连串”问题：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("HTTP 网络请求的第一步是做什么呢？结合上图看，是和服务器建立 TCP 连接。")])]),t._v(" "),a("li",[a("p",[t._v("那建立连接的信息都有了吗？上一篇文章中，我们讲到建立 TCP 连接的第一步就是需要准备 IP 地址和端口号。")])]),t._v(" "),a("li",[a("p",[t._v("那怎么获取 IP 地址和端口号呢？这得看看我们现在有什么，我们有一个 URL 地址，那么是否可以利用 URL 地址来获取 IP 和端口信息呢？")])])]),t._v(" "),a("p",[t._v("在上一篇文章中，我们介绍过数据包都是通过 IP 地址传输给接收方的。由于 IP 地址是数字标识，比如极客时间网站的 IP 是 39.106.233.176,  难以记忆，但使用极客时间的域名（time.geekbang.org）就好记多了，所以基于这个需求又出现了一个服务，负责把域名和 IP 地址做一一映射关系。这套域名映射为 IP 的系统就叫做“域名系统”，简称 DNS（Domain Name System）。")]),t._v(" "),a("p",[t._v("所以，这样一路推导下来，你会发现在"),a("strong",[t._v("第一步浏览器会请求 DNS 返回域名对应的 IP")]),t._v("。当然浏览器还提供了 "),a("strong",[t._v("DNS 数据缓存服务")]),t._v("，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求。")]),t._v(" "),a("p",[t._v("拿到 IP 之后，接下来就需要获取端口号了。通常情况下，如果 URL 没有特别指明端口号，那么 HTTP 协议默认是 80 端口。")]),t._v(" "),a("h4",{attrs:{id:"_2-1-4-等待-tcp-队列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-4-等待-tcp-队列"}},[t._v("#")]),t._v(" 2.1.4. 等待 TCP 队列")]),t._v(" "),a("p",[t._v("现在已经把端口和 IP 地址都准备好了，那么下一步是不是可以建立 TCP 连接了呢？")]),t._v(" "),a("p",[t._v("答案依然是“不行”。Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。")]),t._v(" "),a("p",[t._v("当然，如果当前请求数量少于 6，会直接进入下一步，建立 TCP 连接。")]),t._v(" "),a("h4",{attrs:{id:"_2-1-5-建立-tcp-连接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-5-建立-tcp-连接"}},[t._v("#")]),t._v(" 2.1.5. 建立 TCP 连接")]),t._v(" "),a("p",[t._v("排队等待结束之后，终于可以快乐地和服务器握手了，在 HTTP 工作开始之前，浏览器通过 TCP 与服务器建立连接。而 TCP 的工作方式，我在上一篇文章中已经做过详细介绍了，如果有必要，你可以自行回顾下，这里我就不再重复讲述了。")]),t._v(" "),a("h4",{attrs:{id:"_2-1-6-发送-http-请求"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-6-发送-http-请求"}},[t._v("#")]),t._v(" 2.1.6. 发送 HTTP 请求")]),t._v(" "),a("p",[t._v("一旦建立了 TCP 连接，浏览器就可以和服务器进行通信了。而 HTTP 中的数据正是在这个通信过程中传输的。")]),t._v(" "),a("p",[t._v("你可以结合下图来理解，浏览器是如何发送请求信息给服务器的。")]),t._v(" "),a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/b8/d7/b8993c73f7b60feb9b8bd147545c47d7.png?wh=1142*656",width:"600"}}),t._v(" "),a("p",[t._v("首先浏览器会向服务器发送请求行，它包括了请求方法、请求 URI（Uniform Resource Identifier）和 HTTP 版本协议。")]),t._v(" "),a("p",[t._v("发送请求行，就是告诉服务器浏览器需要什么资源，最常用的请求方法是 Get。比如，直接在浏览器地址栏键入极客时间的域名（time.geekbang.org），这就是告诉服务器要 Get 它的首页资源。")]),t._v(" "),a("p",[t._v("另外一个常用的请求方法是 POST，它用于发送一些数据给服务器，比如登录一个网站，就需要通过 POST 方法把用户信息发送给服务器。如果使用 POST 方法，那么浏览器还要准备数据给服务器，这里准备的数据是通过请求体来发送。")]),t._v(" "),a("p",[t._v("在浏览器发送请求行命令之后，还要以请求头形式发送其他一些信息，把浏览器的一些基础信息告诉服务器。比如包含了浏览器所使用的操作系统、浏览器内核等信息，以及当前请求的域名信息、浏览器端的 Cookie 信息，等等。")]),t._v(" "),a("h3",{attrs:{id:"_2-2-服务器端处理-http-请求流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-服务器端处理-http-请求流程"}},[t._v("#")]),t._v(" 2.2. 服务器端处理 HTTP 请求流程")]),t._v(" "),a("p",[t._v("历经千辛万苦，HTTP 的请求信息终于被送达了服务器。接下来，服务器会根据浏览器的请求信息来准备相应的内容。")]),t._v(" "),a("h4",{attrs:{id:"_2-2-1-返回请求"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-1-返回请求"}},[t._v("#")]),t._v(" 2.2.1. 返回请求")]),t._v(" "),a("p",[t._v("一旦服务器处理结束，便可以返回数据给浏览器了。你可以通过工具软件 curl 来查看返回请求数据，具体使用方法是在命令行中输入以下命令：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("curl -i  https://time.geekbang.org/\n")])])]),a("p",[t._v("注意这里加上了"),a("code",[t._v("-i")]),t._v("是为了返回响应行、响应头和响应体的数据，返回的结果如下图所示，你可以结合这些数据来理解服务器是如何响应浏览器的。")]),t._v(" "),a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/3e/76/3e30476a4bbda49fd7cd4fd0ea09f076.png?wh=1142*651",width:"600"}}),t._v(" "),a("p",[t._v("首先服务器会返回响应行，包括协议版本和状态码。")]),t._v(" "),a("p",[t._v("但并不是所有的请求都可以被服务器处理的，那么一些无法处理或者处理出错的信息，怎么办呢？服务器会通过请求行的状态码来告诉浏览器它的处理结果，比如：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("最常用的状态码是 200，表示处理成功；")])]),t._v(" "),a("li",[a("p",[t._v("如果没有找到页面，则会返回 404。")])])]),t._v(" "),a("p",[t._v("状态码类型很多，这里我就不过多介绍了，网上有很多资料，你可以自行查询和学习。")]),t._v(" "),a("p",[t._v("随后，正如浏览器会随同请求发送请求头一样，服务器也会随同响应向浏览器发送响应头。响应头包含了服务器自身的一些信息，比如服务器生成返回数据的时间、返回的数据类型（JSON、HTML、流媒体等类型），以及服务器要在客户端保存的 Cookie 等信息。")]),t._v(" "),a("p",[t._v("发送完响应头后，服务器就可以继续发送响应体的数据，通常，响应体就包含了 HTML 的实际内容。")]),t._v(" "),a("p",[t._v("以上这些就是服务器响应浏览器的具体过程。")]),t._v(" "),a("h4",{attrs:{id:"_2-2-2-断开连接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-2-断开连接"}},[t._v("#")]),t._v(" 2.2.2. 断开连接")]),t._v(" "),a("p",[t._v("通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。不过如果浏览器或者服务器在其头信息中加入了：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("Connection:Keep-Alive \n")])])]),a("p",[t._v("那么 TCP 连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个 TCP 连接发送请求。保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。比如，一个 Web 页面中内嵌的图片就都来自同一个 Web 站点，如果初始化了一个持久连接，你就可以复用该连接，以请求其他资源，而不需要重新再建立新的 TCP 连接。")]),t._v(" "),a("h4",{attrs:{id:"_2-2-3-重定向"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-3-重定向"}},[t._v("#")]),t._v(" 2.2.3. 重定向")]),t._v(" "),a("p",[t._v("到这里似乎请求流程快结束了，不过还有一种情况你需要了解下，比如当你在浏览器中打开 geekbang.org 后，你会发现最终打开的页面地址是 https://www.geekbang.org。")]),t._v(" "),a("p",[t._v("这两个 URL 之所以不一样，是因为涉及到了一个重定向操作。跟前面一样，你依然可以使用 curl 来查看下请求 geekbang.org 会返回什么内容？")]),t._v(" "),a("p",[t._v("在控制台输入如下命令：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("curl -I geekbang.org\n")])])]),a("p",[t._v("注意这里输入的参数是-I，和-i不一样，-I表示只需要获取响应头和响应行数据，而不需要获取响应体的数据，最终返回的数据如下图所示：")]),t._v(" "),a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/28/43/28d5796c6ab7faa619ed8f1bd17b0843.jpg?wh=2525*1130",width:"600"}}),t._v(" "),a("p",[t._v("从图中你可以看到，响应行返回的状态码是 301，状态 301 就是告诉浏览器，我需要重定向到另外一个网址，而需要重定向的网址正是包含在响应头的 Location 字段中，接下来，浏览器获取 Location 字段中的地址，并使用该地址重新导航，这就是一个完整重定向的执行流程。这也就解释了为什么输入的是 geekbang.org，最终打开的却是 https://www.geekbang.org 了。")]),t._v(" "),a("p",[t._v("不过也不要认为这种跳转是必然的。如果你打开 https://12306.cn，你会发现这个站点是打不开的。这是因为 12306 的服务器并没有处理跳转，所以必须要手动输入完整的 https://www.12306.cn 才能打开页面。")]),t._v(" "),a("h3",{attrs:{id:"_2-3-总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-总结"}},[t._v("#")]),t._v(" 2.3. 总结")]),t._v(" "),a("p",[t._v("下面这张详细的“HTTP 请求示意图”，用来展现浏览器中的 HTTP 请求所经历的各个阶段。")]),t._v(" "),a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/1b/6c/1b49976aca2c700883d48d927f48986c.png?wh=1142*423",width:"600"}}),t._v(" "),a("p",[t._v("从图中可以看到，浏览器中的 HTTP 请求从发起到结束一共经历了如下八个阶段：")]),t._v(" "),a("ol",[a("li",[t._v("构建请求")]),t._v(" "),a("li",[t._v("查找缓存")]),t._v(" "),a("li",[t._v("准备 IP 和端口")]),t._v(" "),a("li",[t._v("等待 TCP 队列")]),t._v(" "),a("li",[t._v("建立 TCP 连接")]),t._v(" "),a("li",[t._v("发起 HTTP 请求")]),t._v(" "),a("li",[t._v("服务器处理请求")]),t._v(" "),a("li",[t._v("服务器返回请求")]),t._v(" "),a("li",[t._v("断开连接")])]),t._v(" "),a("h2",{attrs:{id:"_3-导航流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-导航流程"}},[t._v("#")]),t._v(" 3. 导航流程")]),t._v(" "),a("ul",[a("li",[t._v("服务器可以根据响应头来控制浏览器的行为，如跳转、网络数据类型判断。")]),t._v(" "),a("li",[t._v("Chrome 默认采用每个标签对应一个渲染进程，但是如果两个页面属于同一站点（协议、域名、端口号），那这两个标签会使用同一个渲染进程。")]),t._v(" "),a("li",[t._v("浏览器的导航过程涵盖了从用户发起请求到提交文档给渲染进程的中间所有阶段。")])]),t._v(" "),a("h2",{attrs:{id:"_4-渲染流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-渲染流程"}},[t._v("#")]),t._v(" 4. 渲染流程")]),t._v(" "),a("p",[t._v("由于渲染机制过于复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的 HTML 经过这些子阶段，最后输出像素。我们把这样的一个处理流程叫做渲染流水线，其大致流程如下图所示：")]),t._v(" "),a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/92/e8/9259f8732ddad472e5e08a633ad46de8.png?wh=1142*244",width:"600"}}),t._v(" "),a("p",[t._v("按照渲染的时间顺序，流水线可分为如下几个子阶段：")]),t._v(" "),a("ul",[a("li",[t._v("构建 DOM 树")]),t._v(" "),a("li",[t._v("样式计算")]),t._v(" "),a("li",[t._v("布局阶段")]),t._v(" "),a("li",[t._v("分层")]),t._v(" "),a("li",[t._v("绘制")]),t._v(" "),a("li",[t._v("分块")]),t._v(" "),a("li",[t._v("光栅化和合成")])]),t._v(" "),a("p",[t._v("内容比较多，我会用两篇文章来为你详细讲解这各个子阶段。接下来，在介绍每个阶段的过程中，你应该重点关注以下三点内容：")]),t._v(" "),a("ul",[a("li",[t._v("开始每个子阶段都有其输入的内容；")]),t._v(" "),a("li",[t._v("然后每个子阶段有其处理过程；")]),t._v(" "),a("li",[t._v("最终每个子阶段会生成输出内容。")])]),t._v(" "),a("p",[t._v("理解了这三部分内容，能让你更加清晰地理解每个子阶段。")]),t._v(" "),a("h3",{attrs:{id:"_4-1-构建-dom-树"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-构建-dom-树"}},[t._v("#")]),t._v(" 4.1. 构建 DOM 树")]),t._v(" "),a("p",[t._v("为什么要构建 DOM 树呢？"),a("strong",[t._v("这是因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树")]),t._v("。")]),t._v(" "),a("p",[t._v("来看看 DOM 树的构建过程，你可以参考下图：")]),t._v(" "),a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/12/79/125849ec56a3ea98d4b476c66c754f79.png?wh=1142*555",width:"600"}}),t._v(" "),a("p",[t._v("DOM 树构建过程示意图")]),t._v(" "),a("p",[t._v("从图中可以看出，构建 DOM 树的"),a("strong",[t._v("输入内容")]),t._v("是一个非常简单的 HTML 文件，然后经由 HTML 解析器解析，最终输出树状结构的 DOM。")]),t._v(" "),a("p",[t._v("为了更加直观地理解 DOM 树，你可以打开 Chrome 的“开发者工具”，选择“Console”标签来打开控制台，然后在控制台里面输入“document”后回车，这样你就能看到一个完整的 DOM 树结构，如下图所示：")]),t._v(" "),a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/47/73/47f57c3eee749dd838939bfe5dd64573.png?wh=1044*890",width:"600"}}),t._v(" "),a("p",[t._v("图中的 document 就是 DOM 结构，你可以看到，DOM 和 HTML 内容几乎是一样的，但是和 HTML 不同的是，DOM 是保存在内存中树状结构，可以通过 JavaScript 来查询或修改其内容。")]),t._v(" "),a("p",[t._v("那下面就来看看如何通过 JavaScript 来修改 DOM 的内容，在控制台中输入：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('document.getElementsByTagName("p")[0].innerText = "black"\n')])])]),a("p",[t._v("这行代码的作用是把第一个")]),a("p",[t._v("标签的内容修改为 black。")]),t._v(" "),a("p",[t._v("从图中可以看出，在执行了一段修改第一个")]),a("p",[t._v("标签的 JavaScript 代码后，DOM 的第一个 p 节点的内容成功被修改，同时页面中的内容也被修改了。")]),t._v(" "),a("p",[t._v("好了，现在我们已经生成 DOM 树了，但是 DOM 节点的样式我们依然不知道，要让 DOM 节点拥有正确的样式，这就需要样式计算了。")]),t._v(" "),a("h3",{attrs:{id:"_4-2-样式计算-recalculate-style"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-样式计算-recalculate-style"}},[t._v("#")]),t._v(" 4.2. 样式计算（Recalculate Style）")]),t._v(" "),a("p",[t._v("样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三步来完成。")]),t._v(" "),a("h4",{attrs:{id:"_4-2-1-把-css-转换为浏览器能够理解的结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-1-把-css-转换为浏览器能够理解的结构"}},[t._v("#")]),t._v(" 4.2.1. 把 CSS 转换为浏览器能够理解的结构")]),t._v(" "),a("p",[t._v("那 CSS 样式的来源主要有哪些呢？你可以先参考下图：")]),t._v(" "),a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/bc/7c/bc93df7b8d03b2675f21e1d9e4e1407c.png?wh=1142*585",width:"600"}}),t._v(" "),a("p",[t._v("从图中可以看出，CSS 样式来源主要有三种：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("通过 link 引用的外部 CSS 文件")])]),t._v(" "),a("li",[a("p",[a("code",[t._v("<style>")]),t._v("标记内的 CSS")])]),t._v(" "),a("li",[a("p",[t._v("元素的 style 属性内嵌的 CSS")])])]),t._v(" "),a("p",[t._v("和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，所以"),a("strong",[t._v("当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。")])]),t._v(" "),a("p",[t._v("为了加深理解，你可以在 Chrome 控制台中查看其结构，只需要在控制台中输入 document.styleSheets，然后就看到如下图所示的结构：")]),t._v(" "),a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/8e/ab/8ec7d5ecfadcd05b3f1ec762223a9aab.png?wh=1142*588",width:"600"}}),t._v(" "),a("p",[t._v("从图中可以看出，这个样式表包含了很多种样式，已经把那三种来源的样式都包含进去了。当然样式表的具体结构不是我们今天讨论的重点，你只需要知道渲染引擎会把获取到的 CSS 文本全部转换为 styleSheets 结构中的数据，并且该结构同时具备了查询和修改功能，这会为后面的样式操作提供基础。")]),t._v(" "),a("h4",{attrs:{id:"_4-2-2-转换样式表中的属性值-使其标准化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-2-转换样式表中的属性值-使其标准化"}},[t._v("#")]),t._v(" 4.2.2. 转换样式表中的属性值，使其标准化")]),t._v(" "),a("p",[t._v("现在我们已经把现有的 CSS 文本转化为浏览器可以理解的结构了，那么"),a("strong",[t._v("接下来就要对其进行属性值的标准化操作。")])]),t._v(" "),a("p",[t._v("要理解什么是属性值标准化，你可以看下面这样一段 CSS 文本：")]),t._v(" "),a("div",{staticClass:"language-css extra-class"},[a("pre",{pre:!0,attrs:{class:"language-css"}},[a("code",[a("span",{pre:!0,attrs:{class:"token selector"}},[t._v("body")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v("font-size")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 2em "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token selector"}},[t._v("p")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token property"}},[t._v("color")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("blue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token selector"}},[t._v("span")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token property"}},[t._v("display")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" none"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token selector"}},[t._v("div")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token property"}},[t._v("font-weight")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" bold"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token selector"}},[t._v("div  p")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token property"}},[t._v("color")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("green"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token selector"}},[t._v("div")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token property"}},[t._v("color")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("red"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("可以看到上面的 CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以"),a("strong",[t._v("需要将所有值转换为渲染引擎容易理解的、标准化的计算值")]),t._v("，这个过程就是属性值标准化。")]),t._v(" "),a("p",[t._v("那标准化后的属性值是什么样子的？")]),t._v(" "),a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/12/60/1252c6d3c1a51714606daa6bdad3a560.png?wh=1142*346",width:"600"}}),t._v(" "),a("p",[t._v("从图中可以看到，2em 被解析成了 32px，red 被解析成了 rgb(255,0,0)，bold 被解析成了 700……")]),t._v(" "),a("h4",{attrs:{id:"_4-2-3-计算出-dom-树中每个节点的具体样式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-3-计算出-dom-树中每个节点的具体样式"}},[t._v("#")]),t._v(" 4.2.3. 计算出 DOM 树中每个节点的具体样式")]),t._v(" "),a("p",[t._v("现在样式的属性已被标准化了，接下来就需要计算 DOM 树中每个节点的样式属性了，如何计算呢？")]),t._v(" "),a("p",[t._v("这就涉及到 CSS 的继承规则和层叠规则了。")]),t._v(" "),a("p",[t._v("首先是 CSS 继承。CSS 继承就是每个 DOM 节点都包含有父节点的样式。这么说可能有点抽象，我们可以结合具体例子，看下面这样一张样式表是如何应用到 DOM 节点上的。")]),t._v(" "),a("div",{staticClass:"language-css extra-class"},[a("pre",{pre:!0,attrs:{class:"language-css"}},[a("code",[a("span",{pre:!0,attrs:{class:"token selector"}},[t._v("body")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v("font-size")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 20px "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token selector"}},[t._v("p")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token property"}},[t._v("color")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("blue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token selector"}},[t._v("span")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token property"}},[t._v("display")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" none"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token selector"}},[t._v("div")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token property"}},[t._v("font-weight")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" bold"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),a("span",{pre:!0,attrs:{class:"token property"}},[t._v("color")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("red"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token selector"}},[t._v("div  p")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token property"}},[t._v("color")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("green"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("这张样式表最终应用到 DOM 节点的效果如下图所示：")]),t._v(" "),a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/fe/b4/fe9a0ea868dc02a3c4a59f6080aa80b4.png?wh=1142*876",width:"600"}}),t._v(" "),a("p",[t._v("从图中可以看出，所有子节点都继承了父节点样式。比如 body 节点的 font-size 属性是 20，那 body 节点下面的所有节点的 font-size 都等于 20。")]),t._v(" "),a("p",[t._v("为了加深你对 CSS 继承的理解，你可以打开 Chrome 的“开发者工具”，选择第一个“element”标签，再选择“style”子标签，你会看到很丰富的界面，就不过多介绍了。")]),t._v(" "),a("p",[t._v("样式计算过程中的第二个规则是样式层叠。**层叠是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。它在 CSS 处于核心地位，CSS 的全称“层叠样式表”正是强调了这一点。**关于层叠的具体规则这里就不做过多介绍了，网上资料也非常多，你可以自行搜索学习。")]),t._v(" "),a("p",[t._v("总之，样式计算阶段的目的是为了计算出 DOM 节点中每个元素的具体样式，在计算过程中需要遵守 CSS 的继承和层叠两个规则。这个阶段最终输出的内容是每个 DOM 节点的样式，并被保存在 ComputedStyle 的结构内。")]),t._v(" "),a("p",[t._v("如果你想了解每个 DOM 元素最终的计算样式，可以打开 Chrome 的“开发者工具”，选择第一个“element”标签，然后再选择“Computed”子标签，然后就能看到了。")]),t._v(" "),a("h3",{attrs:{id:"_4-3-布局阶段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-布局阶段"}},[t._v("#")]),t._v(" 4.3. 布局阶段")]),t._v(" "),a("p",[t._v("现在，我们有 DOM 树和 DOM 树中元素的样式，但这还不足以显示页面，因为我们还不知道 DOM 元素的几何位置信息。"),a("strong",[t._v("那么接下来就需要计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局。")])]),t._v(" "),a("p",[t._v("Chrome 在布局阶段需要完成两个任务：创建布局树和布局计算。")]),t._v(" "),a("h4",{attrs:{id:"_4-3-1-创建布局树"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-1-创建布局树"}},[t._v("#")]),t._v(" 4.3.1. 创建布局树")]),t._v(" "),a("p",[t._v("你可能注意到了 DOM 树还含有很多不可见的元素，比如 head 标签，还有使用了 display:none 属性的元素。所以"),a("strong",[t._v("在显示之前，我们还要额外地构建一棵只包含可见元素布局树")]),t._v("。")]),t._v(" "),a("p",[t._v("我们结合下图来看看布局树的构造过程：")]),t._v(" "),a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/8e/0e/8e48b77dd48bdc509958e73b9935710e.png?wh=1142*984",width:"600"}}),t._v(" "),a("p",[t._v("从上图可以看出，DOM 树中所有不可见的节点都没有包含到布局树中。")]),t._v(" "),a("p",[t._v("为了构建布局树，浏览器大体上完成了下面这些工作：")]),t._v(" "),a("ul",[a("li",[t._v("遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中；")]),t._v(" "),a("li",[t._v("而不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容，再比如 body.p.span 这个元素，因为它的属性包含 dispaly:none，所以这个元素也没有被包进布局树。")])]),t._v(" "),a("h4",{attrs:{id:"_4-3-2-布局计算"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-2-布局计算"}},[t._v("#")]),t._v(" 4.3.2. 布局计算")]),t._v(" "),a("p",[t._v("现在我们有了一棵完整的布局树。那么接下来，就要计算布局树节点的坐标位置了。布局的计算过程非常复杂，我们这里先跳过不讲，等到后面章节中我再做详细的介绍。")]),t._v(" "),a("p",[t._v("在执行布局操作的时候，会把布局运算的结果重新写回布局树中，所以布局树既是输入内容也是输出内容，这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰地将输入内容和输出内容区分开来。针对这个问题，Chrome 团队正在重构布局代码，下一代布局系统叫 LayoutNG，试图更清晰地分离输入和输出，从而让新设计的布局算法更加简单。")]),t._v(" "),a("h3",{attrs:{id:"_4-4-分层"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-分层"}},[t._v("#")]),t._v(" 4.4. 分层")]),t._v(" "),a("p",[t._v("现在我们有了布局树，而且每个元素的具体位置信息都计算出来了，那么接下来是不是就要开始着手绘制页面了？")]),t._v(" "),a("p",[t._v("答案依然是否定的。")]),t._v(" "),a("p",[t._v("因为页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实"),a("strong",[t._v("现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）")]),t._v("。如果你熟悉 PS，相信你会很容易理解图层的概念，正是这些图层叠加在一起构成了最终的页面图像。")]),t._v(" "),a("p",[t._v("要想直观地理解什么是图层，你可以打开 Chrome 的“开发者工具”，选择“Layers”标签，就可以可视化页面的分层情况。")]),t._v(" "),a("p",[t._v("渲染引擎给页面分了很多图层，这些图层按照一定顺序叠加在一起，就形成了最终的页面。")]),t._v(" "),a("p",[t._v("现在你知道了浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。下面我们再来看看这些图层和布局树节点之间的关系，如文中图所示：")]),t._v(" "),a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/e8/61/e8a7e60a2a08e05239456284d2aa4061.png?wh=1142*674",width:"600"}}),t._v(" "),a("p",[t._v("通常情况下，"),a("strong",[t._v("并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层")]),t._v("。如上图中的 span 标签没有专属图层，那么它们就从属于它们的父节点图层。但不管怎样，最终每一个节点都会直接或者间接地从属于一个层。")]),t._v(" "),a("p",[t._v("那么需要满足什么条件，渲染引擎才会为特定的节点创建新的图层呢？通常满足下面两点中任意一点的元素就可以被提升为单独的一个图层。")]),t._v(" "),a("p",[a("strong",[t._v("第一点，拥有层叠上下文属性的元素会被提升为单独的一层。")])]),t._v(" "),a("p",[t._v("页面是个二维平面，但是层叠上下文能够让 HTML 元素具有三维概念，这些 HTML 元素按照自身属性的优先级分布在垂直于这个二维平面的 z 轴上。你可以结合下图来直观感受下：")]),t._v(" "),a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/a0/19/a03eb12053aac1ac496b61a424f20119.png?wh=1142*601",width:"600"}}),t._v(" "),a("p",[t._v("从图中可以看出，明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等，都拥有层叠上下文属性。")]),t._v(" "),a("p",[t._v("若你想要了解更多层叠上下文的知识，你可以参考"),a("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_positioned_layout/Understanding_z-index/Stacking_context",target:"_blank",rel:"noopener noreferrer"}},[t._v("这篇文章"),a("OutboundLink")],1),t._v("。")]),t._v(" "),a("p",[a("strong",[t._v("第二点，需要剪裁（clip）的地方也会被创建为图层。")])]),t._v(" "),a("p",[t._v("不过首先你需要了解什么是剪裁，结合下面的 HTML 代码：")]),t._v(" "),a("div",{staticClass:"language-html extra-class"},[a("pre",{pre:!0,attrs:{class:"language-html"}},[a("code",[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("style")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token style"}},[a("span",{pre:!0,attrs:{class:"token language-css"}},[t._v("\n      "),a("span",{pre:!0,attrs:{class:"token selector"}},[t._v("div")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v("width")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 200"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v("height")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 200"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v("overflow")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("auto"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v("background")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" gray"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" \n")])]),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("style")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("body")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("div")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("p")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("所以元素有了层叠上下文的属性或者需要被剪裁，那么就会被提升成为单独一层，你可以参看下图："),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("p")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("p")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("从上图我们可以看到，document层上有A和B层，而B层之上又有两个图层。这些图层组织在一起也是一颗树状结构。"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("p")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("p")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("图层树是基于布局树来创建的，为了找出哪些元素需要在哪些层中，渲染引擎会遍历布局树来创建层树（Update LayerTree）。"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("p")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" \n    "),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("div")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("body")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])])]),a("p",[t._v("在这里我们把 div 的大小限定为 200 * 200 像素，而 div 里面的文字内容比较多，文字所显示的区域肯定会超出 200 * 200 的面积，这时候就产生了剪裁，渲染引擎会把裁剪文字内容的一部分用于显示在 div 区域，下图是运行时的执行结果：")]),t._v(" "),a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/6a/0c/6a583733735edc1e4d7946740eb6fc0c.png?wh=664*466",width:"600"}}),t._v(" "),a("p",[t._v("出现这种裁剪情况的时候，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。")]),t._v(" "),a("p",[t._v("所以说，元素有了层叠上下文的属性或者需要被剪裁，满足其中任意一点，就会被提升成为单独一层。")]),t._v(" "),a("h3",{attrs:{id:"_4-5-图层绘制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-5-图层绘制"}},[t._v("#")]),t._v(" 4.5. 图层绘制")]),t._v(" "),a("p",[t._v("在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制，那么接下来我们看看渲染引擎是怎么实现图层绘制的？")]),t._v(" "),a("p",[t._v("试想一下，如果给你一张纸，让你先把纸的背景涂成蓝色，然后在中间位置画一个红色的圆，最后再在圆上画个绿色三角形。你会怎么操作呢？")]),t._v(" "),a("p",[t._v("通常，你会把你的绘制操作分解为三步：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("绘制蓝色背景；")])]),t._v(" "),a("li",[a("p",[t._v("在中间绘制一个红色的圆；")])]),t._v(" "),a("li",[a("p",[t._v("再在圆上绘制绿色三角形。")])])]),t._v(" "),a("p",[t._v("渲染引擎实现图层的绘制与之类似，会把一个图层的绘制拆分成很多小的"),a("strong",[t._v("绘制指令")]),t._v("，然后再把这些指令按照顺序组成一个待绘制列表，如下图所示：")]),t._v(" "),a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/40/08/40825a55214a7990bba6b9bec6e54108.png?wh=1142*603",width:"600"}}),t._v(" "),a("p",[t._v("从图中可以看出，绘制列表中的指令其实非常简单，就是让其执行一个简单的绘制操作，比如绘制粉色矩形或者黑色的线等。而绘制一个元素通常需要好几条绘制指令，因为每个元素的背景、前景、边框都需要单独的指令去绘制。所以在图层绘制阶段，输出的内容就是这些待绘制列表。")]),t._v(" "),a("h3",{attrs:{id:"_4-6-栅格化-raster-操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-6-栅格化-raster-操作"}},[t._v("#")]),t._v(" 4.6. 栅格化（raster）操作")]),t._v(" "),a("p",[t._v("绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。你可以结合下图来看下渲染主线程和合成线程之间的关系：")]),t._v(" "),a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/46/41/46d33b6e5fca889ecbfab4516c80a441.png?wh=1142*464",width:"600"}}),t._v(" "),a("p",[t._v("如上图所示，当图层的绘制列表准备好之后，主线程会把该绘制列表**提交（commit）**给合成线程，那么接下来合成线程是怎么工作的呢？")]),t._v(" "),a("p",[t._v("那我们得先来看看什么是视口。")]),t._v(" "),a("p",[t._v("通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做"),a("strong",[t._v("视口（viewport）")]),t._v("。")]),t._v(" "),a("p",[t._v("在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。")]),t._v(" "),a("p",[t._v("基于这个原因，"),a("strong",[t._v("合成线程会将图层划分为图块（tile）")]),t._v("，这些图块的大小通常是 256x256 或者 512x512，如下图所示：")]),t._v(" "),a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/bc/52/bcc7f6983d5ece8e2dd716f431d0e052.png?wh=1142*995",width:"500"}}),t._v(" "),a("p",[t._v("然后**合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。**而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的，运行方式如下图所示：")]),t._v(" "),a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/d8/20/d8d77356211e12b47bb9f508e2db8520.png?wh=1142*677",width:"600"}}),t._v(" "),a("p",[t._v("通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。")]),t._v(" "),a("p",[t._v("相信你还记得，GPU 操作是运行在 GPU 进程中，如果栅格化操作使用了 GPU，那么最终生成位图的操作是在 GPU 中完成的，这就涉及到了跨进程操作。具体形式你可以参考下图：")]),t._v(" "),a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/a8/87/a8d954cd8e4722ee03d14afaa14c3987.png?wh=1142*857",width:"600"}}),t._v(" "),a("p",[t._v("从图中可以看出，渲染进程把生成图块的指令发送给 GPU，然后在 GPU 中执行生成图块的位图，并保存在 GPU 的内存中。")]),t._v(" "),a("h3",{attrs:{id:"_4-7-合成和显示"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-7-合成和显示"}},[t._v("#")]),t._v(" 4.7. 合成和显示")]),t._v(" "),a("p",[t._v("一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。")]),t._v(" "),a("p",[t._v("浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。")]),t._v(" "),a("p",[t._v("到这里，经过这一系列的阶段，编写好的 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出漂亮的页面了。")]),t._v(" "),a("h3",{attrs:{id:"_4-8-渲染流水线大总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-8-渲染流水线大总结"}},[t._v("#")]),t._v(" 4.8. 渲染流水线大总结")]),t._v(" "),a("p",[t._v("好了，我们现在已经分析完了整个渲染流程，从 HTML 到 DOM、样式计算、布局、图层、绘制、光栅化、合成和显示。下面我用一张图来总结下这整个渲染流程：")]),t._v(" "),a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/97/37/975fcbf7f83cc20d216f3d68a85d0f37.png?wh=1142*745",width:"600"}}),t._v(" "),a("p",[t._v("结合上图，一个完整的渲染流程大致可总结为如下：")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("渲染进程将 HTML 内容转换为能够读懂的 "),a("strong",[t._v("DOM 树")]),t._v("结构。")])]),t._v(" "),a("li",[a("p",[t._v("渲染引擎将 CSS 样式表转化为浏览器可以理解的 "),a("strong",[t._v("styleSheets")]),t._v("，计算出 DOM 节点的样式。")])]),t._v(" "),a("li",[a("p",[t._v("创建"),a("strong",[t._v("布局树")]),t._v("，并计算元素的布局信息。")])]),t._v(" "),a("li",[a("p",[t._v("对布局树进行分层，并生成"),a("strong",[t._v("分层树")]),t._v("。")])]),t._v(" "),a("li",[a("p",[t._v("为每个图层生成"),a("strong",[t._v("绘制列表")]),t._v("，并将其提交到合成线程。")])]),t._v(" "),a("li",[a("p",[t._v("合成线程将图层分成"),a("strong",[t._v("图块")]),t._v("，并在"),a("strong",[t._v("光栅化线程池")]),t._v("中将图块转换成位图。")])]),t._v(" "),a("li",[a("p",[t._v("合成线程发送绘制图块命令 "),a("strong",[t._v("DrawQuad")]),t._v(" 给浏览器进程。")])]),t._v(" "),a("li",[a("p",[t._v("浏览器进程根据 DrawQuad 消息"),a("strong",[t._v("生成页面")]),t._v("，并"),a("strong",[t._v("显示")]),t._v("到显示器上。")])])]),t._v(" "),a("h3",{attrs:{id:"_4-9-相关概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-9-相关概念"}},[t._v("#")]),t._v(" 4.9. 相关概念")]),t._v(" "),a("p",[t._v("有了上面介绍渲染流水线的基础，我们再来看看三个和渲染流水线相关的概念——"),a("strong",[t._v("“重排”“重绘”和“合成”")]),t._v("。理解了这三个概念对于你后续 Web 的性能优化会有很大帮助。")]),t._v(" "),a("h4",{attrs:{id:"_4-9-1-更新了元素的几何属性-重排"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-9-1-更新了元素的几何属性-重排"}},[t._v("#")]),t._v(" 4.9.1. 更新了元素的几何属性（重排）")]),t._v(" "),a("p",[t._v("你可先参考下图：")]),t._v(" "),a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/b3/e5/b3ed565230fe4f5c1886304a8ff754e5.png?wh=1142*318",width:"600"}}),t._v(" "),a("p",[t._v("从上图可以看出，如果你通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫"),a("strong",[t._v("重排")]),t._v("。无疑，"),a("strong",[t._v("重排需要更新完整的渲染流水线，所以开销也是最大的")]),t._v("。")]),t._v(" "),a("h4",{attrs:{id:"_4-9-2-更新元素的绘制属性-重绘"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-9-2-更新元素的绘制属性-重绘"}},[t._v("#")]),t._v(" 4.9.2. 更新元素的绘制属性（重绘）")]),t._v(" "),a("p",[t._v("接下来，我们再来看看重绘，比如通过 JavaScript 更改某些元素的背景颜色，渲染流水线会怎样调整呢？你可以参考下图：")]),t._v(" "),a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/3c/03/3c1b7310648cccbf6aa4a42ad0202b03.png?wh=1142*286",width:"600"}}),t._v(" "),a("p",[t._v("从图中可以看出，如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫"),a("strong",[t._v("重绘")]),t._v("。相较于重排操作，"),a("strong",[t._v("重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些")]),t._v("。")]),t._v(" "),a("h4",{attrs:{id:"_4-9-3-直接合成阶段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-9-3-直接合成阶段"}},[t._v("#")]),t._v(" 4.9.3. 直接合成阶段")]),t._v(" "),a("p",[t._v("那如果你更改一个既不要布局也不要绘制的属性，会发生什么变化呢？渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做合成。具体流程参考下图：")]),t._v(" "),a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/02/2c/024bf6c83b8146d267f476555d953a2c.png?wh=1142*270",width:"600"}}),t._v(" "),a("p",[t._v("在上图中，我们使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以"),a("strong",[t._v("相对于重绘和重排，合成能大大提升绘制效率")]),t._v("。")]),t._v(" "),a("p",[t._v("至于如何用这些概念去优化页面，我们会在后面相关章节做详细讲解的，这里你只需要先结合“渲染流水线”弄明白这三个概念及原理就行。")]),t._v(" "),a("h3",{attrs:{id:"_4-10-总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-10-总结"}},[t._v("#")]),t._v(" 4.10. 总结")]),t._v(" "),a("p",[t._v("通过本文的分析，你应该可以看到，Chrome 的渲染流水线还是相当复杂晦涩，且难以理解，不过 Chrome 团队在不断添加新功能的同时，也在不断地重构一些子阶段，目的就是"),a("strong",[t._v("让整体渲染架构变得更加简单和高效，正所谓大道至简")]),t._v("。")]),t._v(" "),a("p",[t._v("通过这么多年的生活和工作经验来看，无论是做架构设计、产品设计，还是具体到代码的实现，甚至处理生活中的一些事情，能够把复杂问题简单化的人都是具有大智慧的。所以，在工作或生活中，你若想要简化遇到的问题，就要刻意地练习，练就抓住问题本质的能力，把那些复杂的问题简单化，从而最终真正解决问题。")]),t._v(" "),a("h2",{attrs:{id:"_5-变量提升-javascript-是顺序执行的吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-变量提升-javascript-是顺序执行的吗"}},[t._v("#")]),t._v(" 5. 变量提升：Javascript 是顺序执行的吗？")]),t._v(" "),a("h3",{attrs:{id:"_5-1-javascript-代码的执行流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-javascript-代码的执行流程"}},[t._v("#")]),t._v(" 5.1. JavaScript 代码的执行流程")]),t._v(" "),a("p",[t._v("从概念的字面意义上来看，“变量提升”意味着变量和函数的声明会在物理层面移动到代码的最前面，正如我们所模拟的那样。但，这并不准确。"),a("strong",[t._v("实际上变量和函数声明在代码里的位置是不会改变的，而且是在编译阶段被 JavaScript 引擎放入内存中")]),t._v("。对，你没听错，一段 JavaScript 代码在执行之前需要被 JavaScript 引擎编译，"),a("strong",[t._v("编译")]),t._v("完成之后，才会进入"),a("strong",[t._v("执行")]),t._v("阶段。大致流程你可以参考下图：")]),t._v(" "),a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/64/1e/649c6e3b5509ffd40e13ce9c91b3d91e.png?wh=1142*203",width:"600"}}),t._v(" "),a("h4",{attrs:{id:"_5-1-1-编译阶段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-1-编译阶段"}},[t._v("#")]),t._v(" 5.1.1. 编译阶段")]),t._v(" "),a("p",[t._v("那么编译阶段和变量提升存在什么关系呢？")]),t._v(" "),a("p",[t._v("为了搞清楚这个问题，我们还是回过头来看上面那段模拟变量提升的代码，为了方便介绍，可以把这段代码分成两部分。")]),t._v(" "),a("p",[a("strong",[t._v("第一部分：变量提升部分的代码。")])]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" myname "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("undefined")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("showName")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("console")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'函数showName被执行'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[a("strong",[t._v("第二部分：执行部分的代码。")])]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("showName")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("console")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("myname"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\nmyname "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'极客时间'")]),t._v("\n")])])]),a("p",[t._v("下面我们就可以把 JavaScript 的执行流程细化，如下图所示：")]),t._v(" "),a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/06/13/0655d18ec347a95dfbf843969a921a13.png?wh=1142*634",width:"600"}}),t._v(" "),a("p",[t._v("从上图可以看出，输入一段代码，经过编译后，会生成两部分内容："),a("strong",[t._v("执行上下文（Execution context）和可执行代码")]),t._v("。")]),t._v(" "),a("p",[a("strong",[t._v("执行上下文是 JavaScript 执行一段代码时的运行环境")]),t._v("，比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的诸如 this、变量、对象以及函数等。")]),t._v(" "),a("p",[t._v("在执行上下文中存在一个"),a("strong",[t._v("变量环境的对象（Viriable Environment）")]),t._v("，该对象中保存了变量提升的内容，比如上面代码中的变量 myname 和函数 showName，都保存在该对象中。")]),t._v(" "),a("p",[t._v("你可以简单地把变量环境对象看成是如下结构：")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[t._v("VariableEnvironment"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n     myname "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("undefined")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" \n     showName "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("console")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("myname"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v("了解完变量环境对象的结构后，接下来，我们再结合下面这段代码来分析下是如何生成变量环境对象的。")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("showName")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("console")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("myname"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" myname "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'极客时间'")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("showName")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("console")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'函数showName被执行'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("我们可以一行一行来分析上述代码：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("第 1 行和第 2 行，由于这两行代码不是声明操作，所以 JavaScript 引擎不会做任何处理；")])]),t._v(" "),a("li",[a("p",[t._v("第 3 行，由于这行是经过 var 声明的，因此 JavaScript 引擎将在环境对象中创建一个名为 myname 的属性，并使用 undefined 对其初始化；")])]),t._v(" "),a("li",[a("p",[t._v("第 4 行，JavaScript 引擎发现了一个通过 function 定义的函数，所以它将函数定义存储到堆 (HEAP）中，并在环境对象中创建一个 showName 的属性，然后将该属性值指向堆中函数的位置（不了解堆也没关系，JavaScript 的执行堆和执行栈我会在后续文章中介绍）。")])])]),t._v(" "),a("p",[t._v("这样就生成了变量环境对象。接下来 JavaScript 引擎会把声明以外的代码编译为字节码，至于字节码的细节，我也会在后面文章中做详细介绍，你可以类比如下的模拟代码：")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("showName")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("console")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("myname"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\nmyname "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'极客时间'")]),t._v("\n")])])]),a("p",[t._v("好了，现在有了执行上下文和可执行代码了，那么接下来就到了执行阶段了。")]),t._v(" "),a("h4",{attrs:{id:"_5-1-2-执行阶段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-2-执行阶段"}},[t._v("#")]),t._v(" 5.1.2. 执行阶段")]),t._v(" "),a("p",[t._v("JavaScript 引擎开始执行“可执行代码”，按照顺序一行一行地执行。下面我们就来一行一行分析下这个执行过程：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("当执行到 showName 函数时，JavaScript 引擎便开始在变量环境对象中查找该函数，由于变量环境对象中存在该函数的引用，所以 JavaScript 引擎便开始执行该函数，并输出“函数 showName 被执行”结果。")])]),t._v(" "),a("li",[a("p",[t._v("接下来打印“myname”信息，JavaScript 引擎继续在变量环境对象中查找该对象，由于变量环境存在 myname 变量，并且其值为 undefined，所以这时候就输出 undefined。")])]),t._v(" "),a("li",[a("p",[t._v("接下来执行第 3 行，把“极客时间”赋给 myname 变量，赋值后变量环境中的 myname 属性值改变为“极客时间”，变量环境如下所示：")])])]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[t._v("VariableEnvironment"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n     myname "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"极客时间"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" \n     showName "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("console")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("myname"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v("好了，以上就是一段代码的编译和执行流程。实际上，编译阶段和执行阶段都是非常复杂的，包括了词法分析、语法解析、代码优化、代码生成等。")]),t._v(" "),a("h2",{attrs:{id:"_6-调用栈"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-调用栈"}},[t._v("#")]),t._v(" 6. 调用栈")]),t._v(" "),a("p",[t._v("在上篇文章中，我们讲到了，当一段代码被执行时，JavaScript 引擎先会对其进行编译，并创建执行上下文。但是并没有明确说明到底什么样的代码才算符合规范。")]),t._v(" "),a("p",[t._v("那么接下来我们就来明确下，哪些情况下代码才算是“一段”代码，才会在执行之前就进行编译并创建执行上下文。一般说来，有这么三种情况：")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("当 JavaScript 执行全局代码的时候，会编译全局代码并创建"),a("strong",[t._v("全局执行上下文")]),t._v("，而且在整个页面的生存周期内，全局执行上下文只有一份。")])]),t._v(" "),a("li",[a("p",[t._v("当调用一个函数的时候，函数体内的代码会被编译，并创建"),a("strong",[t._v("函数执行上下文")]),t._v("，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。")])]),t._v(" "),a("li",[a("p",[t._v("当"),a("strong",[t._v("使用 eval 函数")]),t._v("的时候，eval 的代码也会被编译，并创建执行上下文。")])])]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("c"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" b"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v("c\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("addAll")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("c"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" d "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),t._v("\n  result "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("c"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v("  a"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v("result"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v("d\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("addAll")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("6")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v("第一步，"),a("strong",[t._v("创建全局上下文，并将其压入栈底")]),t._v("。如下图所示：")]),t._v(" "),a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/a5/1d/a5d7ec1f8f296412acc045835b85431d.png?wh=1142*765",width:"600"}}),t._v(" "),a("p",[t._v("第二步是"),a("strong",[t._v("调用 addAll 函数")])]),t._v(" "),a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/7d/52/7d6c4c45db4ef9b900678092e6c53652.png?wh=1142*794",width:"600"}}),t._v(" "),a("p",[t._v("第三步，"),a("strong",[t._v("当执行到 add 函数调用语句")]),t._v("时，同样会为其创建执行上下文，并将其压入调用栈")]),t._v(" "),a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/cc/37/ccfe41d906040031a7df1e4f1bce5837.png?wh=1142*843",width:"600"}}),t._v(" "),a("p",[t._v("当 add 函数返回时，该函数的执行上下文就会从栈顶弹出，并将 result 的值设置为 add 函数的返回值，也就是 9")]),t._v(" "),a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/03/96/03ca801a5372f941bf17d6088fee0f96.png?wh=1142*863",width:"600"}}),t._v(" "),a("p",[t._v("紧接着 addAll 执行最后一个相加操作后并返回，addAll 的执行上下文也会从栈顶部弹出，此时调用栈中就只剩下全局上下文了。")]),t._v(" "),a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/d0/7b/d0ac1d6e77735338fa97cc9a3f6c717b.png?wh=1142*641",width:"600"}}),t._v(" "),a("p",[t._v("至此，整个 JavaScript 流程执行结束了。")]),t._v(" "),a("p",[t._v("好了，现在你应该知道了"),a("strong",[t._v("调用栈是 JavaScript 引擎追踪函数执行的一个机制")]),t._v("，当一次有多个函数被调用时，通过调用栈就能够追踪到哪个函数正在被执行以及各函数之间的调用关系。")]),t._v(" "),a("p",[t._v("总结")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("每调用一个函数，JavaScript 引擎会为其创建执行上下文，并把该执行上下文压入调用栈，然后 JavaScript 引擎开始执行函数代码。")])]),t._v(" "),a("li",[a("p",[t._v("如果在一个函数 A 中调用了另外一个函数 B，那么 JavaScript 引擎会为 B 函数创建执行上下文，并将 B 函数的执行上下文压入栈顶。")])]),t._v(" "),a("li",[a("p",[t._v("当前函数执行完毕后，JavaScript 引擎会将该函数的执行上下文弹出栈。")])]),t._v(" "),a("li",[a("p",[t._v("当分配的调用栈空间被占满时，会引发“堆栈溢出”问题。")])])])])}),[],!1,null,null,null);a.default=r.exports}}]);