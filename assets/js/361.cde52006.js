(window.webpackJsonp=window.webpackJsonp||[]).push([[361],{667:function(a,v,_){"use strict";_.r(v);var s=_(25),t=Object(s.a)({},(function(){var a=this,v=a._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("ul",[v("li",[v("a",{attrs:{href:"#1-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"}},[a._v("1. 构造方法")])]),a._v(" "),v("li",[v("a",{attrs:{href:"#2-%E9%87%8D%E8%BD%BD"}},[a._v("2. 重载")])]),a._v(" "),v("li",[v("a",{attrs:{href:"#3-%E7%BB%A7%E6%89%BF"}},[a._v("3. 继承")])]),a._v(" "),v("li",[v("a",{attrs:{href:"#4-%E5%A4%9A%E6%80%81"}},[a._v("4. 多态")])]),a._v(" "),v("li",[v("a",{attrs:{href:"#5-%E6%8E%A5%E5%8F%A3"}},[a._v("5. 接口")])]),a._v(" "),v("li",[v("a",{attrs:{href:"#6-%E5%8C%85"}},[a._v("6. 包")]),a._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"#61-%E5%8C%85%E4%BD%9C%E7%94%A8%E5%9F%9F"}},[a._v("6.1. 包作用域")])])])]),a._v(" "),v("li",[v("a",{attrs:{href:"#7-classpath-%E5%92%8C-jar"}},[a._v("7. classpath 和 jar")])])]),a._v(" "),v("h3",{attrs:{id:"_1-构造方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-构造方法"}},[a._v("#")]),a._v(" 1. 构造方法")]),a._v(" "),v("ol",[v("li",[a._v("实例在创建时通过"),v("code",[a._v("new")]),a._v("操作符会调用其对应的构造方法，构造方法用于初始化实例；")]),a._v(" "),v("li",[a._v("没有定义构造方法时，编译器会自动创建一个默认的无参数构造方法；当有指定的构造方法，无论是有参，无参的构造方法，都不会自动添加无参的构造方法；")]),a._v(" "),v("li",[a._v("构造方法的重载：方法名相同，但参数不同的多个方法，调用是会自动更加不同的参数选择相应的方法；")])]),a._v(" "),v("h3",{attrs:{id:"_2-重载"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-重载"}},[a._v("#")]),a._v(" 2. 重载")]),a._v(" "),v("ol",[v("li",[a._v("方法重载( Overload )是指在同一个类中，多个方法的方法名相同，但各自的参数不同（个数、顺序或类型），与方法的修饰符或返回值没有关系；")]),a._v(" "),v("li",[a._v("重载方法应该完成类似的功能，参考String的indexOf()；")]),a._v(" "),v("li",[a._v("重载方法返回值类型应该相同。")])]),a._v(" "),v("h3",{attrs:{id:"_3-继承"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-继承"}},[a._v("#")]),a._v(" 3. 继承")]),a._v(" "),v("p",[a._v("如果父类没有默认的构造方法，子类就必须显式调用super()并给出参数以便让编译器定位到父类的一个合适的构造方法。")]),a._v(" "),v("p",[a._v("这里还顺带引出了另一个问题：即子类不会继承任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。")]),a._v(" "),v("ol",[v("li",[a._v("Java只允许单继承，所有类最终的根类是Object；")]),a._v(" "),v("li",[a._v("protected允许子类访问父类的字段和方法；")]),a._v(" "),v("li",[a._v("子类的构造方法可以通过super()调用父类的构造方法；")]),a._v(" "),v("li",[a._v("可以安全地向上转型为更抽象的类型；")]),a._v(" "),v("li",[a._v("可以强制向下转型，最好借助instanceof判断；")]),a._v(" "),v("li",[a._v("子类和父类的关系是is，has关系不能用继承。")])]),a._v(" "),v("h3",{attrs:{id:"_4-多态"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-多态"}},[a._v("#")]),a._v(" 4. 多态")]),a._v(" "),v("p",[a._v("override和Overload不同的是：")]),a._v(" "),v("ul",[v("li",[a._v("如果方法签名如果不同，就是Overload，Overload方法是一个新方法；")]),a._v(" "),v("li",[a._v("如果方法签名相同，并且返回值也相同，就是Override。")])]),a._v(" "),v("p",[a._v("方法签名是什么？\n方法的名称和参数类型。")]),a._v(" "),v("ul",[v("li",[a._v("子类可以覆写父类的方法（Override），覆写在子类中改变了父类方法的行为；")]),a._v(" "),v("li",[a._v("Java的方法调用总是作用于运行期对象的实际类型，这种行为称为多态；")]),a._v(" "),v("li",[a._v("final修饰符有多种作用：\n"),v("ul",[v("li",[a._v("final修饰的方法可以阻止被覆写；")]),a._v(" "),v("li",[a._v("final修饰的class可以阻止被继承；")]),a._v(" "),v("li",[a._v("final修饰的field必须在创建对象时初始化，随后不可修改。")])])])]),a._v(" "),v("h3",{attrs:{id:"_5-接口"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-接口"}},[a._v("#")]),a._v(" 5. 接口")]),a._v(" "),v("p",[a._v("interface，就是比抽象类还要抽象的纯抽象接口，因为它连实例字段都不能有（但是可以有静态字段，"),v("code",[a._v("public static final")]),a._v("）。因为接口定义的所有方法默认都是public abstract的，所以这两个修饰符不需要写出来（写不写效果都一样）。")]),a._v(" "),v("h3",{attrs:{id:"_6-包"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-包"}},[a._v("#")]),a._v(" 6. 包")]),a._v(" "),v("p",[a._v("在定义class的时候，我们需要在第一行声明这个class属于哪个包。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("package ming; // 声明包名ming\n")])])]),v("p",[a._v("在Java虚拟机执行的时候，JVM只看完整类名，因此，只要包名不同，类就不同。\n包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系。")]),a._v(" "),v("h4",{attrs:{id:"_6-1-包作用域"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-包作用域"}},[a._v("#")]),a._v(" 6.1. 包作用域")]),a._v(" "),v("p",[a._v("包作用域是指一个类允许访问同一个"),v("code",[a._v("package")]),a._v("的没有"),v("code",[a._v("public")]),a._v("、"),v("code",[a._v("private")]),a._v("修饰的"),v("code",[a._v("class")]),a._v("，以及没有"),v("code",[a._v("public")]),a._v("、"),v("code",[a._v("protected")]),a._v("、"),v("code",[a._v("private")]),a._v("修饰的字段和方法。")]),a._v(" "),v("p",[a._v("Java编译器最终编译出的.class文件只使用完整类名，因此，在代码中，当编译器遇到一个class名称时：")]),a._v(" "),v("ul",[v("li",[a._v("如果是完整类名，就直接根据完整类名查找这个class；")]),a._v(" "),v("li",[a._v("如果是简单类名，按下面的顺序依次查找：\n"),v("ul",[v("li",[a._v("查找当前package是否存在这个class；")]),a._v(" "),v("li",[a._v("查找import的包是否包含这个class；")]),a._v(" "),v("li",[a._v("查找java.lang包是否包含这个class。")])])])]),a._v(" "),v("p",[a._v("因此，编写class的时候，编译器会自动帮我们做两个import动作：")]),a._v(" "),v("ol",[v("li",[a._v("默认自动import当前package的其他class；")]),a._v(" "),v("li",[a._v("默认自动import java.lang.*。")])]),a._v(" "),v("h3",{attrs:{id:"_7-classpath-和-jar"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-classpath-和-jar"}},[a._v("#")]),a._v(" 7. classpath 和 jar")]),a._v(" "),v("ol",[v("li",[a._v("JVM通过环境变量"),v("code",[a._v("classpath")]),a._v("决定搜索"),v("code",[a._v("class")]),a._v("的路径和顺序；")]),a._v(" "),v("li",[a._v("不推荐设置系统环境变量"),v("code",[a._v("classpath")]),a._v("，始终建议通过"),v("code",[a._v("-cp")]),a._v("命令传入；")]),a._v(" "),v("li",[a._v("jar包相当于目录，可以包含很多"),v("code",[a._v(".class")]),a._v("文件，方便下载和使用；")]),a._v(" "),v("li",[v("code",[a._v("MANIFEST.MF")]),a._v("文件可以提供jar包的信息，如"),v("code",[a._v("Main-Class")]),a._v("，这样可以直接运行jar包。")])])])}),[],!1,null,null,null);v.default=t.exports}}]);