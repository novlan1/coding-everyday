(window.webpackJsonp=window.webpackJsonp||[]).push([[278],{585:function(_,v,t){"use strict";t.r(v);var i=t(25),s=Object(i.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("ul",[v("li",[v("a",{attrs:{href:"#1-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA"}},[_._v("1. 支持向量机")]),_._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"#11-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%BF%87%E7%A8%8B"}},[_._v("1.1. 机器学习的过程")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#12-%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98%E5%87%B8%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98"}},[_._v("1.2. 优化问题（凸优化问题、二次规划问题）")]),_._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"#121-%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98"}},[_._v("1.2.1. 二次规划问题")])])])]),_._v(" "),v("li",[v("a",{attrs:{href:"#13-svm%E5%A4%84%E7%90%86%E9%9D%9E%E7%BA%BF%E6%80%A7%E9%97%AE%E9%A2%98"}},[_._v("1.3. SVM处理非线性问题")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#14-%E4%BD%8E%E7%BB%B4%E5%88%B0%E9%AB%98%E7%BB%B4%E6%98%A0%E5%B0%84%CF%86x"}},[_._v("1.4. 低维到高维映射φ(x)")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#15-svm%E7%B2%BE%E9%AB%93"}},[_._v("1.5. SVM精髓")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#16-%E5%8E%9F%E9%97%AE%E9%A2%98%E4%B8%8E%E5%AF%B9%E5%81%B6%E9%97%AE%E9%A2%98"}},[_._v("1.6. 原问题与对偶问题")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#17-%E5%87%B8%E5%87%BD%E6%95%B0"}},[_._v("1.7. 凸函数")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#18-%E5%B0%86%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E7%9A%84%E5%8E%9F%E9%97%AE%E9%A2%98%E8%BD%AC%E4%B8%BA%E5%AF%B9%E5%81%B6%E9%97%AE%E9%A2%98"}},[_._v("1.8. 将支持向量机的原问题转为对偶问题")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#19-%E6%A0%B8%E5%87%BD%E6%95%B0"}},[_._v("1.9. 核函数")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#110-%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81%E7%9A%84%E5%A5%BD%E5%A4%84"}},[_._v("1.10. 交叉验证的好处")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#111-roc%E6%9B%B2%E7%BA%BF"}},[_._v("1.11. ROC曲线")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#112-svm%E5%A4%84%E7%90%86%E5%A4%9A%E7%B1%BB%E9%97%AE%E9%A2%98"}},[_._v("1.12. SVM处理多类问题")])])])])]),_._v(" "),v("h2",{attrs:{id:"_1-支持向量机"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-支持向量机"}},[_._v("#")]),_._v(" 1. 支持向量机")]),_._v(" "),v("p",[_._v("支持向量机（苏联"),v("code",[_._v("Vapnik")]),_._v("发明）问题")]),_._v(" "),v("ol",[v("li",[_._v("如何在线性可分样本集上画一条直线将其分开（找到最好的直线）。")]),_._v(" "),v("li",[_._v("如何将非线性可分样本集分开。")])]),_._v(" "),v("p",[v("strong",[_._v("线性可分样本集就是一条直线能分开的集合")]),_._v("，二者有明显界限。")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("首先要找到一个性能指标，然后根据这个性能指标指出某一条线比其他线指标高。")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("将一条线平行地向一侧移动，直到叉到某一个样本为止，然后平行地向另一侧移动，也是叉到某一个样本为止。这个性能指标就是两条平行线的距离")]),_._v("。这个距离最大的一条线就是最佳的。同时两条平行线的最中间是唯一的。")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("将平行线间的距离称为"),v("code",[_._v("d(margin)")]),_._v("，支持向量机是最大化平行线距离"),v("code",[_._v("d(margin)")]),_._v("的方法")]),_._v("。")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("将平行线叉到的向量称为支持向量，画出这条线的方法只跟支持向量有关系，跟其他向量没关系")]),_._v("，这也是为什么支持向量能够用在小样本集上。")])])]),_._v(" "),v("p",[v("img",{attrs:{src:"http://img.uwayfly.com/article_mike_20200530094549_9847cc2c9a0a.png",alt:"img"}})]),_._v(" "),v("p",[v("img",{attrs:{src:"http://img.uwayfly.com/article_mike_20200530095003_0dfe6ede894a.png",alt:"img"}})]),_._v(" "),v("ol",[v("li",[_._v("定义训练数据和标签："),v("code",[_._v("(X1,y1)、(X2, y2)...(Xn, yn)")]),_._v("，其中"),v("code",[_._v("X = [x1, x2 ..]")]),_._v("，是多维向量，y是"),v("code",[_._v("+1")]),_._v("或"),v("code",[_._v("-1")]),_._v("的标签。")]),_._v(" "),v("li",[_._v("线性模型 "),v("code",[_._v("(W, b)")]),_._v(" => W"),v("sup",[_._v("T")]),_._v("X+ b = 0，描述超平面的线性方程。"),v("code",[_._v("W")]),_._v("是一个向量，如果"),v("code",[_._v("X")]),_._v("是"),v("code",[_._v("n")]),_._v("维的，那么"),v("code",[_._v("W")]),_._v("也是"),v("code",[_._v("n")]),_._v("维的。"),v("code",[_._v("b")]),_._v("是一个常数。W"),v("sup",[_._v("T")]),_._v("X 一个列向量转置然后乘以一个行向量，也是一个数。")]),_._v(" "),v("li",[_._v("线性可分的定义。存在"),v("code",[_._v("(W，b)")]),_._v("，使 y"),v("sub",[_._v("i")]),_._v(" =+1 时，W"),v("sup",[_._v("T")]),_._v("X + b >= 0；y"),v("sub",[_._v("i")]),_._v(" = -1时，W"),v("sup",[_._v("T")]),_._v("X + b < 0。即 y"),v("sub",[_._v("i")]),_._v("[W"),v("sup",[_._v("T")]),_._v("X"),v("sub",[_._v("i")]),_._v(" + b] >= 0（公式一）")])]),_._v(" "),v("h3",{attrs:{id:"_1-1-机器学习的过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-机器学习的过程"}},[_._v("#")]),_._v(" 1.1. 机器学习的过程")]),_._v(" "),v("ol",[v("li",[_._v("确定一个方程；")]),_._v(" "),v("li",[_._v("确定一些要求取的参数，比如这里的"),v("code",[_._v("W")]),_._v("和"),v("code",[_._v("B")]),_._v("；")]),_._v(" "),v("li",[_._v("训练模型，求出参数")])]),_._v(" "),v("h3",{attrs:{id:"_1-2-优化问题-凸优化问题、二次规划问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-优化问题-凸优化问题、二次规划问题"}},[_._v("#")]),_._v(" 1.2. 优化问题（凸优化问题、二次规划问题）")]),_._v(" "),v("p",[v("img",{attrs:{src:"http://img.uwayfly.com/article_mike_20200530095953_595e00bed48c.png",alt:"img"}})]),_._v(" "),v("p",[v("img",{attrs:{src:"http://img.uwayfly.com/article_mike_20200530100315_c0e97b913730.png",alt:"img"}})]),_._v(" "),v("p",[v("img",{attrs:{src:"http://img.uwayfly.com/article_mike_20200530100421_0ac78ffc49b9.png",alt:"img"}})]),_._v(" "),v("ol",[v("li",[_._v("最小化"),v("code",[_._v("minimize")]),_._v("： ||W||"),v("sup",[_._v("2")]),_._v(", 即 W 模的平方。")]),_._v(" "),v("li",[_._v("限制条件"),v("code",[_._v("Subject to")]),_._v("：y"),v("sub",[_._v("i")]),_._v("[W"),v("sup",[_._v("T")]),_._v("X"),v("sub",[_._v("i")]),_._v("+ b] >= 1，其中 i = 1~N")])]),_._v(" "),v("p",[_._v("如何从最大化margin转化到上面的两个问题？")]),_._v(" "),v("blockquote",[v("p",[_._v("事实1. W"),v("sup",[_._v("T")]),_._v("X + b = 0 与 aW"),v("sup",[_._v("T")]),_._v("X + ab = 0 是同一个平面，其中 a 是一个正实数。也就是若"),v("code",[_._v("(W, b)")]),_._v("满足公式一，那么"),v("code",[_._v("（aW, ab）")]),_._v("也满足公式一，a是负数的话符号就相反了。\n事实2. 点 (x"),v("sub",[_._v("0")]),_._v(", y"),v("sub",[_._v("0")]),_._v(") 到平面（w"),v("sub",[_._v("1")]),_._v("x + w"),v("sub",[_._v("2")]),_._v("y + b = 0）的最短距离：d = |w"),v("sub",[_._v("1")]),_._v("x"),v("sub",[_._v("0")]),_._v(" + w"),v("sub",[_._v("2")]),_._v("y"),v("sub",[_._v("0")]),_._v(" + b| / √(w"),v("sub",[_._v("1")]),v("sup",[_._v("2")]),_._v(" + w"),v("sub",[_._v("2")]),v("sup",[_._v("2")]),_._v(")")]),_._v(" "),v("p",[_._v("那么高维上，向量 X"),v("sub",[_._v("0")]),_._v(" 到超平面 W"),v("sup",[_._v("T")]),_._v("X + b = 0的距离，就是：|W"),v("sup",[_._v("T")]),_._v("X"),v("sub",[_._v("0")]),_._v("+ b|/ || W ||，其中分母 W 的模就是 √(w"),v("sub",[_._v("1")]),v("sup",[_._v("2")]),_._v(" + w"),v("sub",[_._v("2")]),v("sup",[_._v("2")]),_._v(" + w"),v("sub",[_._v("3")]),v("sup",[_._v("2")]),_._v(" ...)")])]),_._v(" "),v("p",[_._v("那么，")]),_._v(" "),v("ol",[v("li",[_._v("我们可以用 a 缩放（W，b）得到（aW, ab），最终使所有支持向量 X"),v("sub",[_._v("0")]),_._v(" 上，有 |W"),v("sup",[_._v("T")]),_._v("X"),v("sub",[_._v("0")]),_._v(" + b| = 1 ，那么非支持向量上，|W"),v("sup",[_._v("T")]),_._v("X"),v("sub",[_._v("0")]),_._v("+ b| >1，从而得证限制条件；")]),_._v(" "),v("li",[_._v("此时支持向量与平面的距离 "),v("strong",[_._v("d = 1/|| W ||")]),_._v("，从而最小化 || W || 可以使 d 最大，得证最小化条件")])]),_._v(" "),v("p",[_._v("注意：")]),_._v(" "),v("ol",[v("li",[_._v("限制条件最后的1可以是2、3、4...等任意整数，它们的区别只是一个常数"),v("code",[_._v("a")]),_._v("。")]),_._v(" "),v("li",[_._v("只要线性可分，一定存在 W 和 b，反之如果线性不可分，找不到 W 和 b 满足限制条件")])]),_._v(" "),v("h4",{attrs:{id:"_1-2-1-二次规划问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-1-二次规划问题"}},[_._v("#")]),_._v(" 1.2.1. 二次规划问题")]),_._v(" "),v("ol",[v("li",[v("strong",[_._v("目标函数是二次项，限制条件是一次项")]),_._v("。")]),_._v(" "),v("li",[v("strong",[_._v("要么无解，要么只有一个极值")]),_._v("。")])]),_._v(" "),v("p",[_._v("支持向量机效果好，是因为"),v("strong",[_._v("数学理论漂亮，漂亮在转化为了一个凸优化问题，这类问题在全局上有一个最优解")]),_._v("。")]),_._v(" "),v("h3",{attrs:{id:"_1-3-svm处理非线性问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-svm处理非线性问题"}},[_._v("#")]),_._v(" 1.3. SVM处理非线性问题")]),_._v(" "),v("p",[v("img",{attrs:{src:"http://img.uwayfly.com/article_mike_20200530101006_fb2818704a8d.png",alt:"img"}})]),_._v(" "),v("p",[_._v("优化问题：")]),_._v(" "),v("ol",[v("li",[v("strong",[_._v("最小化 ||W||"),v("sup",[_._v("2")]),_._v(" / 2 + C∑ε"),v("sub",[_._v("i")])])]),_._v(" "),v("li",[_._v("限制条件\n"),v("ul",[v("li",[v("strong",[_._v("y"),v("sub",[_._v("i")]),_._v("[W"),v("sup",[_._v("T")]),_._v("X"),v("sub",[_._v("i")]),_._v(" + b] >= 1 - ε"),v("sub",[_._v("i")])])]),_._v(" "),v("li",[v("strong",[_._v("ε"),v("sub",[_._v("i")]),_._v(" >= 0")]),_._v(" ，其中 i = 1~N")])])])]),_._v(" "),v("p",[_._v("理解：")]),_._v(" "),v("ol",[v("li",[_._v("有上面知道非线性情况下，找不到满足 y"),v("sub",[_._v("i")]),_._v("[W"),v("sup",[_._v("T")]),_._v("X"),v("sub",[_._v("i")]),_._v(" + b] >= 1 的（W，b）；")]),_._v(" "),v("li",[_._v("因此，放宽条件，"),v("strong",[_._v("当 ε"),v("sub",[_._v("i")]),_._v(" 很大的时候，1-ε"),v("sub",[_._v("i")]),_._v(" 很小，就能满足限制条件")]),_._v("；")]),_._v(" "),v("li",[_._v("同时又不能让 ε"),v("sub",[_._v("i")]),_._v(" 很大，否则问题会很发散，所以把它又放在最小化里面。")]),_._v(" "),v("li",[_._v("ε"),v("sub",[_._v("i")]),_._v(" 称为"),v("strong",[_._v("松弛变量")]),_._v("，"),v("code",[_._v("slack variable")]),_._v(".")])]),_._v(" "),v("p",[_._v("所以，已知条件有X"),v("sub",[_._v("i")]),_._v("、Y"),v("sub",[_._v("i")]),_._v("，即训练样本，要求的有 W、b、ε"),v("sub",[_._v("i")])]),_._v(" "),v("ul",[v("li",[_._v("C∑ε"),v("sub",[_._v("i")]),_._v("被称为"),v("strong",[_._v("正则项")]),_._v("，"),v("code",[_._v("regulation term")]),_._v("，C 的作用是平衡每一项 ε"),v("sub",[_._v("i")]),_._v("，使它们都不要太大。")]),_._v(" "),v("li",[v("strong",[_._v("C 是事先设定的参数，起到平衡前后两项的作用")]),_._v("。通常没有固定的值，一般根据经验在某个范围内去一个个试。")])]),_._v(" "),v("p",[_._v("为什么要加正则项？")]),_._v(" "),v("ol",[v("li",[_._v("以前没有解，要使其有解，就需要加正则项。")]),_._v(" "),v("li",[_._v("目标函数有解，但其解并不想要的，比如目标函数凹凸不平，也需要加正则项。")])]),_._v(" "),v("h3",{attrs:{id:"_1-4-低维到高维映射φ-x"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-低维到高维映射φ-x"}},[_._v("#")]),_._v(" 1.4. 低维到高维映射φ(x)")]),_._v(" "),v("p",[v("img",{attrs:{src:"http://img.uwayfly.com/article_mike_20200530100957_f551e4cbe5e0.png",alt:"img"}})]),_._v(" "),v("p",[_._v("问题：之前的解都是求解直线，但如果最优解其实是圆形怎么办？比如一堆1包围了0。")]),_._v(" "),v("p",[v("code",[_._v("vapnik")]),_._v("一个创意的想法是，不在低维的空间找圆形、椭圆等其他形状，而是在高维的空间还是找直线。"),v("code",[_._v("x => φ(x)")])]),_._v(" "),v("p",[_._v("举例："),v("code",[_._v("x1(0, 0)")]),_._v("和"),v("code",[_._v("x2(1,1)")]),_._v("属于第一类，"),v("code",[_._v("x3(1, 0)")]),_._v("和"),v("code",[_._v("x4(0, 1)")]),_._v("属于第二类。一个映射方案是[a,b] =>[a"),v("sup",[_._v("2")]),_._v(", b"),v("sup",[_._v("2")]),_._v(", a, b, ab]")]),_._v(" "),v("p",[_._v("那么\nx1: [0, 0] => [0, 0, 0, 0, 0]\nx2: [1, 1] => [1, 1, 1, 1, 1]\nx3: [1, 0] => [1, 0, 1, 0, 0]\nx4: [0, 1] => [0, 1, 0, 1, 0] (转置)")]),_._v(" "),v("p",[_._v("如何求解 W 和 b ？\n一个解是：W = [-1，-1，-1，-1, 6]，b = 1")]),_._v(" "),v("p",[v("strong",[_._v("维度越高，被线性分开的可能性越高")]),_._v("，如果是无限维，被线性分开的概率为1。")]),_._v(" "),v("h3",{attrs:{id:"_1-5-svm精髓"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-svm精髓"}},[_._v("#")]),_._v(" 1.5. SVM精髓")]),_._v(" "),v("blockquote",[v("p",[_._v("我们可以不知道无限维映射 φ(x) 的显式表达，我们只要知道一个核函数 kernal function，K(x1, x2) = φ(x1)"),v("sup",[_._v("T")]),_._v("φ(x2)，那么 ||W||"),v("sup",[_._v("2")]),_._v("/2 + C∑ε"),v("sub",[_._v("i")]),_._v(" 这个优化式仍然可解。")])]),_._v(" "),v("p",[_._v("φ(x1)"),v("sup",[_._v("T")]),_._v("φ(x2) 是两个无限维向量的内积，就是一个数，也就是不需要 φ(x) 的具体表达式，只要知道核函数就行了。")]),_._v(" "),v("p",[_._v("常见的核函数有高斯核和多项式核函数等，具体公式见下文。")]),_._v(" "),v("p",[_._v("核函数 K(x1, x2) 能写成 φ(x1)"),v("sup",[_._v("T")]),_._v("φ(x2)的充要条件是（"),v("code",[_._v("Mercer's Theorem")]),_._v("）：")]),_._v(" "),v("ol",[v("li",[_._v("满足交换律 K(x1, x2) = K(x2, x1)")]),_._v(" "),v("li",[_._v("半正定性，对于所有的 C"),v("sub",[_._v("i")]),_._v(" 和 X"),v("sub",[_._v("i")]),_._v("， 有 ∑"),v("sub",[_._v("i")]),_._v("∑"),v("sub",[_._v("j")]),_._v("C"),v("sub",[_._v("i")]),_._v("C"),v("sub",[_._v("j")]),_._v("K(X"),v("sub",[_._v("i")]),_._v(", Y"),v("sub",[_._v("i")]),_._v(") >= 0。其中 C"),v("sub",[_._v("i")]),_._v(" 是常数，X"),v("sub",[_._v("i")]),_._v(" 是向量。")])]),_._v(" "),v("h3",{attrs:{id:"_1-6-原问题与对偶问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-6-原问题与对偶问题"}},[_._v("#")]),_._v(" 1.6. 原问题与对偶问题")]),_._v(" "),v("p",[v("img",{attrs:{src:"http://img.uwayfly.com/article_mike_20200530101609_8bed8bc8927f.png",alt:"img"}})]),_._v(" "),v("p",[_._v("原问题"),v("code",[_._v("Prime Problem")]),_._v("：")]),_._v(" "),v("ol",[v("li",[v("strong",[_._v("最小化 f(ω)")])]),_._v(" "),v("li",[_._v("限制条件\n"),v("ul",[v("li",[v("strong",[_._v("g"),v("sub",[_._v("i")]),_._v("(ω) <= 0")]),_._v("，其中 i = 1~K；")]),_._v(" "),v("li",[v("strong",[_._v("h"),v("sub",[_._v("i")]),_._v("(ω) = 0")]),_._v("，其中 i = 1~M")])])])]),_._v(" "),v("p",[_._v("原问题非常普适，最小化可以转为最大化问题，限制条件大于等于可以转为小于等于，后面的 h(ω) = 0 可以转为 h(ω) - C = 0。")]),_._v(" "),v("p",[v("img",{attrs:{src:"http://img.uwayfly.com/article_mike_20200530101757_9c7e0a4eeccc.png",alt:"img"}})]),_._v(" "),v("p",[_._v("对偶问题"),v("code",[_._v("Dual Problem")]),_._v("：")]),_._v(" "),v("p",[_._v("先定义函数：L(ω, α, β) = f(ω) + ∑"),v("sub",[_._v("i")]),_._v("α"),v("sub",[_._v("i")]),_._v("g"),v("sub",[_._v("i")]),_._v("(ω) + ∑"),v("sub",[_._v("i")]),_._v("β"),v("sub",[_._v("i")]),_._v("h"),v("sub",[_._v("i")]),_._v("(ω) = f(ω) + α"),v("sup",[_._v("T")]),_._v("g(ω) + β"),v("sup",[_._v("T")]),_._v("h(ω)，其中后面的形式是向量的形式。")]),_._v(" "),v("p",[_._v("对偶问题定义：")]),_._v(" "),v("ol",[v("li",[_._v("最大化 θ(α, β) = inf"),v("sub",[_._v("所有ω")]),_._v("( L(ω, α, β) )，")]),_._v(" "),v("li",[_._v("α"),v("sub",[_._v("i")]),_._v(" >= 0，其中 i = 1~K")])]),_._v(" "),v("p",[_._v("inf 指求括号内的最小值，即在限定了 α 和 β ，去遍历所有的 ω，求 L 的最小值。所以每确定一个 α 和 β，都能算出一个最小值，θ(α, β)只和 α, β 有关。然后再针对所有的 α, β，再求 θ 的最大值。里面求最小，外面求最大。")]),_._v(" "),v("p",[v("img",{attrs:{src:"http://img.uwayfly.com/article_mike_20200530101929_b4d5211ddc9f.png",alt:"img"}})]),_._v(" "),v("p",[_._v("定理："),v("strong",[_._v("如果"),v("code",[_._v("ω*")]),_._v("是原问题的解，而"),v("code",[_._v("α*")]),_._v(", "),v("code",[_._v("β*")]),_._v("是对偶问题的解，则有"),v("code",[_._v("f(ω*) >= θ(α*, β*)")])])]),_._v(" "),v("p",[_._v("证明："),v("code",[_._v("θ(α*, β*)")]),_._v(" = inf"),v("sub",[_._v("所有ω")]),_._v("( L(ω, α*, β*) ) <= "),v("code",[_._v("L(ω*, α*, β*)")]),_._v(" = f(ω*) + ∑"),v("sub",[_._v("i")]),_._v("α*"),v("sub",[_._v("i")]),_._v("g"),v("sub",[_._v("i")]),_._v("(ω*) + ∑"),v("sub",[_._v("i")]),_._v("β*"),v("sub",[_._v("i")]),_._v("h"),v("sub",[_._v("i")]),_._v("(ω*) .\n其中 h"),v("sub",[_._v("i")]),_._v("(ω*) = 0，g"),v("sub",[_._v("i")]),_._v("(ω*) <= 0，α*"),v("sub",[_._v("i")]),_._v(" >= 0，得证。")]),_._v(" "),v("p",[_._v("定义：G = f(ω*) - θ(α*, β*) >= 0，G叫做原问题与对偶问题的间距（"),v("code",[_._v("Duality Gap")]),_._v("）。对于某些特定的优化问题，可以证明 G 等于0。")]),_._v(" "),v("p",[v("img",{attrs:{src:"http://img.uwayfly.com/article_mike_20200530102141_d3d6d00c1bf0.png",alt:"img"}})]),_._v(" "),v("p",[v("strong",[_._v("强对偶定理")]),_._v("："),v("strong",[_._v("若 f(ω) 为凸函数， g(ω) = aω+b，h(ω）=cω+d，则此优化问题的原问题与对偶问题间距为0。即 f(ω*) = θ(α*, β*) => 对于所有的 i = 1 - K，α*"),v("sub",[_._v("i")]),_._v(" = 0 或者 g"),v("sub",[_._v("i")]),_._v("(ω*) = 0")])]),_._v(" "),v("h3",{attrs:{id:"_1-7-凸函数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-7-凸函数"}},[_._v("#")]),_._v(" 1.7. 凸函数")]),_._v(" "),v("p",[_._v("凸函数："),v("strong",[_._v("如果在函数图像上任取两点，函数图像在这两点之间的部分都在两点线段的下边")]),_._v("，那么就成为凸函数，否则称为凹函数。凸函数只有一个极小值，比如 x"),v("sup",[_._v("2")]),_._v("，而 sinx 有多个极值。")]),_._v(" "),v("p",[v("img",{attrs:{src:"http://img.uwayfly.com/article_mike_20200528214447_e910fef0804c.png",alt:"img"}})]),_._v(" "),v("p",[_._v("对于任意（0,1）中有理数 λ，有")]),_._v(" "),v("p",[v("img",{attrs:{src:"http://img.uwayfly.com/article_mike_20200528214748_ff695c8b9b58.png",alt:"img"}})]),_._v(" "),v("p",[_._v("如果 f 连续，那么 λ 可以改变成区间（0,1）中的任意实数。")]),_._v(" "),v("p",[_._v("几何意义只是一维的，而代数的定义可以是向量，即任意维。")]),_._v(" "),v("h3",{attrs:{id:"_1-8-将支持向量机的原问题转为对偶问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-8-将支持向量机的原问题转为对偶问题"}},[_._v("#")]),_._v(" 1.8. 将支持向量机的原问题转为对偶问题")]),_._v(" "),v("p",[v("img",{attrs:{src:"http://img.uwayfly.com/article_mike_20200529210955_f6ed337621e6.png",alt:"img"}})]),_._v(" "),v("p",[_._v("注意转化后的对偶问题中的 β"),v("sub",[_._v("i")]),_._v(" 和 α"),v("sub",[_._v("i")]),_._v(" 对应着原来对偶问题的一个 α"),v("sub",[_._v("i")]),_._v("，因为 g"),v("sub",[_._v("i")]),_._v("(ω) <= 0，而支持向量机的不等式的限制条件有两个，所以都写上了。")]),_._v(" "),v("p",[_._v("对向量求偏导，就是对其每个分量求偏导。")]),_._v(" "),v("p",[v("img",{attrs:{src:"http://img.uwayfly.com/article_mike_20200529212107_e3e6d36bf061.png",alt:"img"}})]),_._v(" "),v("p",[v("img",{attrs:{src:"http://img.uwayfly.com/article_mike_20200529213304_24d17d6ca511.png",alt:"img"}})]),_._v(" "),v("p",[v("img",{attrs:{src:"http://img.uwayfly.com/article_mike_20200529213739_c06bf7c80e81.png",alt:"img"}})]),_._v(" "),v("p",[_._v("W"),v("sup",[_._v("T")]),_._v("W，蹦出来个 α"),v("sub",[_._v("j")]),_._v("，只是个符号，因为写 α"),v("sub",[_._v("i")]),_._v(" 不合适了")]),_._v(" "),v("p",[_._v("对于上面的推倒后的式子，"),v("strong",[_._v("已知的是所有的 y，和 kernal 函数，未知的是所有的 α。怎么把求 α 转化为求 W 和 b")]),_._v("？根据上面 W 的公式就可以。")]),_._v(" "),v("p",[_._v("KKT条件对应到SVM上：")]),_._v(" "),v("p",[v("img",{attrs:{src:"http://img.uwayfly.com/article_mike_20200529220202_0255892fd81e.png",alt:"img"}})]),_._v(" "),v("p",[_._v("SVM算法流程分为训练流程和测试流程，训练时，"),v("strong",[_._v("先求出所有的α，再算b")])]),_._v(" "),v("p",[v("img",{attrs:{src:"http://img.uwayfly.com/article_mike_20200529220957_f88bdd4d0d17.png",alt:"img"}})]),_._v(" "),v("p",[v("img",{attrs:{src:"http://img.uwayfly.com/article_mike_20200530105545_5808b6f24016.png",alt:"img"}})]),_._v(" "),v("p",[v("img",{attrs:{src:"http://img.uwayfly.com/article_mike_20200529221338_263e6f61cd00.png",alt:"img"}})]),_._v(" "),v("p",[_._v("可见所有的 φ(x) 都转成了 kernel 函数")]),_._v(" "),v("h3",{attrs:{id:"_1-9-核函数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-9-核函数"}},[_._v("#")]),_._v(" 1.9. 核函数")]),_._v(" "),v("p",[v("img",{attrs:{src:"http://img.uwayfly.com/article_mike_20200530113130_6e55884198ad.png",alt:"img"}})]),_._v(" "),v("p",[_._v("线性核等于没用，解原问题和解对偶问题的复杂度一样。多项式核函数d是几维，就对应到几维。高斯核是低维映射到高维。")]),_._v(" "),v("p",[_._v("每个核函数都要调参数，"),v("strong",[_._v("多项式核函数要调的参数是d，高斯核要调的是方差")]),_._v("。")]),_._v(" "),v("p",[_._v("SVM训练时的一个经验是，必须归一化，"),v("strong",[_._v("一般用高斯归一化，即减掉均值，然后除以平均值，而不是最小最大归一化")]),_._v("。")]),_._v(" "),v("p",[v("img",{attrs:{src:"http://img.uwayfly.com/article_mike_20200529224607_54b3bac80e4e.png",alt:"img"}})]),_._v(" "),v("p",[_._v("SVM 用高斯核的话，只有两个参数要调，"),v("strong",[_._v("一个是 C 平衡前面的 W 和后面的 ε"),v("sub",[_._v("i")]),_._v("，另一个是高斯核中的方差")]),_._v("。")]),_._v(" "),v("p",[_._v("C范围：2"),v("sup",[_._v("-5~15")]),_._v("，方差范围：2"),v("sup",[_._v("-15~23")]),_._v("，组合有21*19种")]),_._v(" "),v("h3",{attrs:{id:"_1-10-交叉验证的好处"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-10-交叉验证的好处"}},[_._v("#")]),_._v(" 1.10. 交叉验证的好处")]),_._v(" "),v("ul",[v("li",[_._v("不使用训练样本进行测试，因为无法验出真实水平。")]),_._v(" "),v("li",[_._v("尽可能地充分利用训练样本，比如只有5000个样本，分成abcde五组，每次取出4份进行训练，另一份进行测试，保证每一次训练时，样本足够的多。")])]),_._v(" "),v("p",[_._v("折数越多，训练模型越多，10折就是10个模型，5折就是训练5次。5000个样本，最多5000折，每次取4999个进行训练，1个进行测试。这种称为"),v("code",[_._v("leave-one-out cross validation")])]),_._v(" "),v("p",[_._v("支持向量20%左右正常，如果特别多，说明没有训练好，或者数据本身就没有规律。")]),_._v(" "),v("h3",{attrs:{id:"_1-11-roc曲线"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-11-roc曲线"}},[_._v("#")]),_._v(" 1.11. ROC曲线")]),_._v(" "),v("p",[v("img",{attrs:{src:"http://img.uwayfly.com/article_mike_20200530085813_a46199bd60a7.png",alt:"img"}})]),_._v(" "),v("p",[v("img",{attrs:{src:"http://img.uwayfly.com/article_mike_20200530085844_76f9642475aa.png",alt:"img"}})]),_._v(" "),v("p",[_._v("为什么同一个系统中TP增加，FP也增加？小平同志说，改革开放了，好的东西进来了，蚊子苍蝇也进来了。因为自身性能不变，把更多的正例识别成正例，那么一定也会将更多的反例识别为正例。同理FN增加=>TN增加。")]),_._v(" "),v("p",[v("img",{attrs:{src:"http://img.uwayfly.com/article_mike_20200530090535_b0a7b797e2bf.png",alt:"img"}})]),_._v(" "),v("p",[_._v("ROC ("),v("code",[_._v("Receiver Operating Character")]),_._v(")曲线， 是一条横坐标 FP，纵坐标 TP 的曲线")]),_._v(" "),v("p",[_._v("给定一个模型，怎么画出ROC曲线？从小到大变换下面的阈值，每次变换一个阈值，测出 TP 和 FP。FP 等于0时，表示把所有的样本判为负例，此时 TP 也为0，FP 等于1表示把所有的样本判为正例。")]),_._v(" "),v("p",[v("img",{attrs:{src:"http://img.uwayfly.com/article_mike_20200530090758_76f5253b610a.png",alt:"img"}})]),_._v(" "),v("p",[_._v("等错误率 ("),v("code",[_._v("Equal Error Rate")]),_._v(", EER)是两类错误 FP 和 FN 相等时候的错误率，可以直观的表示系统性能。")]),_._v(" "),v("p",[v("img",{attrs:{src:"http://img.uwayfly.com/article_mike_20200530091324_585563440221.png",alt:"img"}})]),_._v(" "),v("p",[_._v("对于不同的应用，判别模型好坏的标准不同。对于人脸开锁的应用而言，容忍错误低，即要 FP 最小，或者是0情况下，FP 的最大值。")]),_._v(" "),v("p",[_._v("ROC 下的面积称为 AUC，面积越大，一般性能越好。")]),_._v(" "),v("p",[_._v("可以用 ROC 曲线、EER、AUC，但不要单纯用识别率来判断，识别率高不代表性能就好（这是机器学习领域懂和不懂的人的一个区别）。")]),_._v(" "),v("h3",{attrs:{id:"_1-12-svm处理多类问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-12-svm处理多类问题"}},[_._v("#")]),_._v(" 1.12. SVM处理多类问题")]),_._v(" "),v("ol",[v("li",[_._v("改造优化的目标函数和限制条件，使之能处理多类。论文 "),v("code",[_._v("SVM-Multiclass Multi-class Support Vector Machine")])]),_._v(" "),v("li",[_._v("一类 VS 其他类")]),_._v(" "),v("li",[_._v("一类 VS 另一类")])]),_._v(" "),v("p",[_._v("一类 VS 其他类：")]),_._v(" "),v("p",[v("img",{attrs:{src:"http://img.uwayfly.com/article_mike_20200530092951_5d571f049682.png",alt:"img"}})]),_._v(" "),v("p",[_._v("如果一个样本被判为 C1 或 C2，那就看哪一个负的多，因为 y = -1，说明...是负的，看更偏向于谁。")]),_._v(" "),v("p",[_._v("一类 VS 另一类：")]),_._v(" "),v("p",[v("img",{attrs:{src:"http://img.uwayfly.com/article_mike_20200530105719_5b342b643041.png",alt:"img"}})]),_._v(" "),v("p",[_._v("根据经验，改造公式的方法并不好用，因为SVM适合在两类中寻找最大间隔。")]),_._v(" "),v("p",[_._v("如果有 N 类，一类VS其他类的方法要做 N 个 SVM 模型，一类VS另一类要做 (N*(N-1))/2 个SVM模型。根据经验，后者更佳。")])])}),[],!1,null,null,null);v.default=s.exports}}]);