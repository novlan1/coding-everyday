(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{354:function(_,v,t){"use strict";t.r(v);var a=t(25),r=Object(a.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("ul",[v("li",[v("a",{attrs:{href:"#1-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E4%B9%8B%E8%BF%9B%E7%A8%8B%E5%AE%9E%E4%BD%93"}},[_._v("1. 进程管理之进程实体")]),_._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"#11-%E8%BF%9B%E7%A8%8B"}},[_._v("1.1. 进程")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#12-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9E%E4%BD%93"}},[_._v("1.2. 进程的实体")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#13-%E8%BF%9B%E7%A8%8B-process-%E4%B8%8E%E7%BA%BF%E7%A8%8B-thread"}},[_._v("1.3. 进程 Process 与线程 Thread")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#14-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AF%B9%E6%AF%94"}},[_._v("1.4. 进程和线程的对比")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#15-%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91%E7%9A%84%E5%8C%BA%E5%88%AB"}},[_._v("1.5. 并行和并发的区别")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#16-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"}},[_._v("1.6. 什么是线程安全？")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#17-python%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84"}},[_._v("1.7. Python哪些操作是线程安全的？")])])])]),_._v(" "),v("li",[v("a",{attrs:{href:"#2-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E4%B9%8B%E4%BA%94%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B"}},[_._v("2. 进程管理之五状态模型")]),_._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"#21-%E5%B0%B1%E7%BB%AA%E7%8A%B6%E6%80%81"}},[_._v("2.1. 就绪状态")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#22-%E6%89%A7%E8%A1%8C%E7%8A%B6%E6%80%81"}},[_._v("2.2. 执行状态")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#23-%E9%98%BB%E5%A1%9E%E7%8A%B6%E6%80%81"}},[_._v("2.3. 阻塞状态")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#24-%E5%88%9B%E5%BB%BA%E7%8A%B6%E6%80%81"}},[_._v("2.4. 创建状态")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#25-%E7%BB%88%E6%AD%A2%E7%8A%B6%E6%80%81"}},[_._v("2.5. 终止状态")])])])]),_._v(" "),v("li",[v("a",{attrs:{href:"#3-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E4%B9%8B%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"}},[_._v("3. 进程管理之进程同步")]),_._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"#31-%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90"}},[_._v("3.1. 临界资源")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#32-%E8%BF%9B%E7%A8%8B%E9%97%B4%E5%90%8C%E6%AD%A5%E7%9A%84%E5%8E%9F%E5%88%99"}},[_._v("3.2. 进程间同步的原则")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#33-%E8%BF%9B%E7%A8%8B%E9%97%B4%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%B9%E6%B3%95"}},[_._v("3.3. 进程间同步的方法")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#34-python%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B"}},[_._v("3.4. Python中如何使用多进程？")]),_._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"#341-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"}},[_._v("3.4.1. 进程同步之共享内存")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#342-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8Bunix%E5%9F%9F%E5%A5%97%E6%8E%A5%E5%AD%97"}},[_._v("3.4.2. 进程同步之Unix域套接字")])])])]),_._v(" "),v("li",[v("a",{attrs:{href:"#35-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"}},[_._v("3.5. 线程同步")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#36-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%B9%E5%BC%8F"}},[_._v("3.6. 线程同步的方式")]),_._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"#361-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E4%BA%92%E6%96%A5%E9%87%8F"}},[_._v("3.6.1. 线程同步之互斥量")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#362-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E8%87%AA%E6%97%8B%E9%94%81"}},[_._v("3.6.2. 线程同步之自旋锁")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#363-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E8%AF%BB%E5%86%99%E9%94%81"}},[_._v("3.6.3. 线程同步之读写锁")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#364-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"}},[_._v("3.6.4. 线程同步之条件变量")])])])]),_._v(" "),v("li",[v("a",{attrs:{href:"#37-python%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B"}},[_._v("3.7. python中如何使用多线程？")])])])]),_._v(" "),v("li",[v("a",{attrs:{href:"#4-linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"}},[_._v("4. Linux进程管理")]),_._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"#41-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%B1%BB%E5%9E%8B"}},[_._v("4.1. 进程的类型")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#42-%E5%89%8D%E5%8F%B0%E8%BF%9B%E7%A8%8B"}},[_._v("4.2. 前台进程")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#43-%E5%90%8E%E5%8F%B0%E8%BF%9B%E7%A8%8B"}},[_._v("4.3. 后台进程")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#44-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-daemon-"}},[_._v("4.4. 守护进程( "),v("code",[_._v("daemon")]),_._v(" )")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#45-%E7%89%B9%E6%AE%8A%E8%BF%9B%E7%A8%8B"}},[_._v("4.5. 特殊进程")])]),_._v(" "),v("li",[v("a",{attrs:{href:"#46-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%B1%A0"}},[_._v("4.6. 什么是线程池")]),_._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"#461-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0"}},[_._v("4.6.1. 为什么使用线程池")])])])])])]),_._v(" "),v("li",[v("a",{attrs:{href:"#5-%E4%BD%BF%E7%94%A8fork%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B"}},[_._v("5. 使用"),v("code",[_._v("fork")]),_._v("系统调用创建进程")])])]),_._v(" "),v("h3",{attrs:{id:"_1-进程管理之进程实体"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-进程管理之进程实体"}},[_._v("#")]),_._v(" 1. 进程管理之进程实体")]),_._v(" "),v("h4",{attrs:{id:"_1-1-进程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-进程"}},[_._v("#")]),_._v(" 1.1. 进程")]),_._v(" "),v("p",[_._v("没有配置OS之前，所有资源属于当前运行的程序")]),_._v(" "),v("ol",[v("li",[_._v("进程是系统进行资源分配和调度的基本单位")]),_._v(" "),v("li",[_._v("进程作为程序独立运行的载体保障程序的正常运行")]),_._v(" "),v("li",[_._v("进程使资源的利用率大幅提升")])]),_._v(" "),v("h4",{attrs:{id:"_1-2-进程的实体"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-进程的实体"}},[_._v("#")]),_._v(" 1.2. 进程的实体")]),_._v(" "),v("ol",[v("li",[_._v("主存中进程形态：标识符、状态、优先级、序计数器、内存指针、上下文数据、IO状态信息、记账信息")]),_._v(" "),v("li",[_._v("可分为进程标识符、处理机状态、进程调度信息、进程控制信息等几类")])]),_._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[_._v("标识符：\n唯一标记一个进程（id）\n\n状态：\n标记进程状态，如运行态\n\n程序计数器：\n进程即将被执行的下一条指令的地址\n\n内存指针：\n程序代码、进程数据相关指针\n\n上下文数据：\n进程执行时处理器存储的数据\n\nIO状态信息：\n被进程IO操作所占用的文件列表（如磁盘、内存、文件等）\n\n记账信息：\n使用处理器时间、时钟数总和等\n\nPCB进程控制块：\n1. 用于描述和控制进程运行的通用数据结构\n2. 经常被读取，常驻内存，存放在系统专门开辟的PCB区域内\n")])])]),v("h4",{attrs:{id:"_1-3-进程-process-与线程-thread"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-进程-process-与线程-thread"}},[_._v("#")]),_._v(" 1.3. 进程 Process 与线程 Thread")]),_._v(" "),v("ul",[v("li",[_._v("线程是操作系统进行运行调度的最小单位")]),_._v(" "),v("li",[_._v("包含在进程之中，是进程中实际运行工作的单位")]),_._v(" "),v("li",[_._v("一个进程可以并发多个线程，每个线程执行不同的任务")]),_._v(" "),v("li",[_._v("进程的线程共享进程资源")])]),_._v(" "),v("h4",{attrs:{id:"_1-4-进程和线程的对比"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-进程和线程的对比"}},[_._v("#")]),_._v(" 1.4. 进程和线程的对比")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th"),_._v(" "),v("th",[_._v("进程")]),_._v(" "),v("th",[_._v("线程")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("资源")]),_._v(" "),v("td",[_._v("资源分配的基本单位")]),_._v(" "),v("td",[_._v("不拥有资源")])]),_._v(" "),v("tr",[v("td",[_._v("调度")]),_._v(" "),v("td",[_._v("独立调度的基本单位")]),_._v(" "),v("td",[_._v("独立调度的最小单位")])]),_._v(" "),v("tr",[v("td",[_._v("系统开销")]),_._v(" "),v("td",[_._v("进程系统开销大")]),_._v(" "),v("td",[_._v("线程系统开销小")])]),_._v(" "),v("tr",[v("td",[_._v("通信")]),_._v(" "),v("td",[_._v("进程IPC")]),_._v(" "),v("td",[_._v("读写同一进程数据通信")])])])]),_._v(" "),v("h4",{attrs:{id:"_1-5-并行和并发的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-并行和并发的区别"}},[_._v("#")]),_._v(" 1.5. 并行和并发的区别")]),_._v(" "),v("ol",[v("li",[_._v("并行："),v("strong",[_._v("真正多核"),v("code",[_._v("cpu")]),_._v("去执行")]),_._v("（"),v("code",[_._v("python")]),_._v("不能同时利用多个"),v("code",[_._v("cpu")]),_._v("，只能说是并发）")]),_._v(" "),v("li",[_._v("并发：看似是并行，其实通过"),v("code",[_._v("cpu")]),_._v("的时间片轮转来切换任务，"),v("strong",[_._v("同一时刻还是只能执行一个线程")]),_._v("，对外界来说营造了一种同时执行的效果")])]),_._v(" "),v("h4",{attrs:{id:"_1-6-什么是线程安全"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-6-什么是线程安全"}},[_._v("#")]),_._v(" 1.6. 什么是线程安全？")]),_._v(" "),v("ol",[v("li",[_._v("线程安全就是"),v("strong",[_._v("多线程访问时")]),_._v("，采用了"),v("strong",[_._v("加锁机制")]),_._v("，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。")]),_._v(" "),v("li",[_._v("线程不安全就是"),v("strong",[_._v("不提供数据访问保护")]),_._v("，"),v("strong",[_._v("有可能出现多个线程先后更改数据造成所得到的数据是脏数据")])])]),_._v(" "),v("h4",{attrs:{id:"_1-7-python哪些操作是线程安全的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-7-python哪些操作是线程安全的"}},[_._v("#")]),_._v(" 1.7. Python哪些操作是线程安全的？")]),_._v(" "),v("ol",[v("li",[_._v("一个操作可以在多线程环境中安全使用，获取正确结果")]),_._v(" "),v("li",[_._v("线程安全的操作好比线程是顺序执行而不是并发执行的("),v("code",[_._v("i += 1")]),_._v(" 不是线程安全)")]),_._v(" "),v("li",[_._v("一般如果涉及到写操作需要考虑如何让多个线程安全访问数据")])]),_._v(" "),v("h3",{attrs:{id:"_2-进程管理之五状态模型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-进程管理之五状态模型"}},[_._v("#")]),_._v(" 2. 进程管理之五状态模型")]),_._v(" "),v("p",[_._v("就绪、阻塞、执行、创建、终止")]),_._v(" "),v("h4",{attrs:{id:"_2-1-就绪状态"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-就绪状态"}},[_._v("#")]),_._v(" 2.1. 就绪状态")]),_._v(" "),v("ul",[v("li",[_._v("当进程被分配到CPU以外所有其他的资源（只差CPU资源）")]),_._v(" "),v("li",[_._v("就绪队列：多个处于就绪状态的进程组成一个队列")])]),_._v(" "),v("h4",{attrs:{id:"_2-2-执行状态"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-执行状态"}},[_._v("#")]),_._v(" 2.2. 执行状态")]),_._v(" "),v("ul",[v("li",[_._v("进程获得CPU，其程序正在执行")]),_._v(" "),v("li",[_._v("在单处理机（单核）中，某个时刻只能有一个进程处于执行状态")])]),_._v(" "),v("h4",{attrs:{id:"_2-3-阻塞状态"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-阻塞状态"}},[_._v("#")]),_._v(" 2.3. 阻塞状态")]),_._v(" "),v("ul",[v("li",[_._v("进程因某种原因（如其他设备未就绪而无法继续执行）放弃CPU的状态")]),_._v(" "),v("li",[_._v("阻塞队列：多个阻塞状态的进程组成的队列")])]),_._v(" "),v("h4",{attrs:{id:"_2-4-创建状态"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-创建状态"}},[_._v("#")]),_._v(" 2.4. 创建状态")]),_._v(" "),v("ul",[v("li",[_._v("进程创建过程：分配PCB => 插入就绪队列")]),_._v(" "),v("li",[_._v("创建进程时拥有PCB但其他资源尚未就绪的状态")])]),_._v(" "),v("h4",{attrs:{id:"_2-5-终止状态"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-终止状态"}},[_._v("#")]),_._v(" 2.5. 终止状态")]),_._v(" "),v("ul",[v("li",[_._v("系统清理 =>  PCB归还")]),_._v(" "),v("li",[_._v("进程结束后由系统清理或归还PCB的状态称为终止状态")])]),_._v(" "),v("p",[v("img",{attrs:{src:"/imgs/process_five_status.png",alt:"进程管理之五状态模型"}})]),_._v(" "),v("h3",{attrs:{id:"_3-进程管理之进程同步"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-进程管理之进程同步"}},[_._v("#")]),_._v(" 3. 进程管理之进程同步")]),_._v(" "),v("p",[_._v("生产者-消费者模型：\n"),v("img",{attrs:{src:"/imgs/process_consumer_producter.png",alt:"生产者-消费者模型"}})]),_._v(" "),v("ul",[v("li",[_._v("生产者A：寄存器从缓存区 取值，然后加1，再放到缓存区；消费者B是减1")]),_._v(" "),v("li",[_._v("举例：当并发执行时，A寄存器由10变成11，这时B寄存器从取出10然后减1变成9，然后这两不论谁先放回，都会造成数据不一致")]),_._v(" "),v("li",[v("strong",[_._v("缓冲区")]),_._v("属于临界资源\n"),v("img",{attrs:{src:"/imgs/process_consumer_producter2.png",alt:"生产者-消费者模型"}})])]),_._v(" "),v("p",[_._v("哲学家进餐问题：\n"),v("img",{attrs:{src:"/imgs/process_example.png",alt:"哲学家进餐问题"}})]),_._v(" "),v("ul",[v("li",[_._v("五个人同时拿起左边筷子，然后一起等待右边筷子的释放，但谁都不释放，都饿死了")]),_._v(" "),v("li",[_._v("筷子属于临界资源")]),_._v(" "),v("li",[_._v("这两个模型根源问题：彼此之间没有通信")])]),_._v(" "),v("h4",{attrs:{id:"_3-1-临界资源"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-临界资源"}},[_._v("#")]),_._v(" 3.1. 临界资源")]),_._v(" "),v("ul",[v("li",[_._v("一些作为共享资源却无法同时被多个线程共同访问的共享资源。")])]),_._v(" "),v("h4",{attrs:{id:"_3-2-进程间同步的原则"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-进程间同步的原则"}},[_._v("#")]),_._v(" 3.2. 进程间同步的原则")]),_._v(" "),v("ul",[v("li",[_._v("空闲让进：资源无占用，允许使用")]),_._v(" "),v("li",[_._v("忙则等待：资源有占用，请求进程等待")]),_._v(" "),v("li",[_._v("有限等待：保证有限等待时间能够使用资源")]),_._v(" "),v("li",[_._v("让权等待：等待时，进程需要让出 CPU（执行变成阻塞状态）")])]),_._v(" "),v("h4",{attrs:{id:"_3-3-进程间同步的方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-进程间同步的方法"}},[_._v("#")]),_._v(" 3.3. 进程间同步的方法")]),_._v(" "),v("ol",[v("li",[_._v("管道/匿名管道/有名管道("),v("code",[_._v("pipe")]),_._v(")")]),_._v(" "),v("li",[_._v("信号("),v("code",[_._v("Signal")]),_._v(")：比如用户使用"),v("code",[_._v("Ctrl+c")]),_._v("产生"),v("code",[_._v("SIGINT")]),_._v("程序终止信号")]),_._v(" "),v("li",[_._v("消息队列（"),v("code",[_._v("Message")]),_._v("）")]),_._v(" "),v("li",[_._v("共享内存（"),v("code",[_._v("share memory")]),_._v("）")]),_._v(" "),v("li",[_._v("信号量（"),v("code",[_._v("Semphare")]),_._v("）")]),_._v(" "),v("li",[_._v("套接字（"),v("code",[_._v("socket")]),_._v("）：最常用的方式，web应用都是这种方式")])]),_._v(" "),v("h4",{attrs:{id:"_3-4-python中如何使用多进程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-python中如何使用多进程"}},[_._v("#")]),_._v(" 3.4. Python中如何使用多进程？")]),_._v(" "),v("p",[_._v("Python有GIL，可以用多进程实现cpu密集程序")]),_._v(" "),v("ol",[v("li",[v("code",[_._v("multiprocessing")]),_._v("多进程模块")]),_._v(" "),v("li",[v("code",[_._v("multiprocessing.Process")]),_._v("类实现多进程")]),_._v(" "),v("li",[_._v("一般在"),v("code",[_._v("CPU")]),_._v("密集程序里，避免"),v("code",[_._v("GIL")]),_._v("的影响")])]),_._v(" "),v("h5",{attrs:{id:"_3-4-1-进程同步之共享内存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-1-进程同步之共享内存"}},[_._v("#")]),_._v(" 3.4.1. 进程同步之共享内存")]),_._v(" "),v("ul",[v("li",[_._v("多进程共同使用物理内存")]),_._v(" "),v("li",[_._v("由于操作系统的进程管理，进程间的内存空间是独立的")]),_._v(" "),v("li",[v("strong",[_._v("进程默认不能访问进程空间之外的内存空间")])])]),_._v(" "),v("p",[v("img",{attrs:{src:"/imgs/linux_share_memory.png",alt:"共享内存"}})]),_._v(" "),v("p",[_._v("共享内存特点：")]),_._v(" "),v("ul",[v("li",[_._v("共享内存允许"),v("strong",[_._v("不相关的进程访问同一片物理内存")])]),_._v(" "),v("li",[_._v("共享内存是两个进程之间共享和传递数据最快的方式（常用）")]),_._v(" "),v("li",[_._v("共享内存未提供同步机制，需要借助其他机制管理访问（自己设置"),v("code",[_._v("can_read")]),_._v("，即加锁/解锁）")])]),_._v(" "),v("p",[_._v("步骤：")]),_._v(" "),v("ol",[v("li",[_._v("申请共享内存")]),_._v(" "),v("li",[_._v("连接到进程空间")]),_._v(" "),v("li",[_._v("使用共享内存")]),_._v(" "),v("li",[_._v("脱离进程空间&删除")])]),_._v(" "),v("h5",{attrs:{id:"_3-4-2-进程同步之unix域套接字"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-2-进程同步之unix域套接字"}},[_._v("#")]),_._v(" 3.4.2. 进程同步之Unix域套接字")]),_._v(" "),v("ul",[v("li",[_._v("域套接字是高级的进程间通信的方法")]),_._v(" "),v("li",[_._v("提供了单机 简单可靠的进程通信同步服务")]),_._v(" "),v("li",[_._v("只能在单机使用，不能跨机器使用")]),_._v(" "),v("li",[_._v("Unix 域套接字提供了类似 "),v("strong",[_._v("网络套接字")]),_._v("的功能")])]),_._v(" "),v("p",[_._v("服务端使用：")]),_._v(" "),v("ul",[v("li",[_._v("创建套接字、绑定、监听套接字，接收并处理信息\n客户端使用：")]),_._v(" "),v("li",[_._v("创建套接字、连接套接字，发送信息")])]),_._v(" "),v("h4",{attrs:{id:"_3-5-线程同步"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-5-线程同步"}},[_._v("#")]),_._v(" 3.5. 线程同步")]),_._v(" "),v("ul",[v("li",[_._v("因为进程的线程共享进程资源，所以也需要同步")]),_._v(" "),v("li",[_._v("方法：互斥量、读写锁、自旋锁、条件变量")])]),_._v(" "),v("h4",{attrs:{id:"_3-6-线程同步的方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-6-线程同步的方式"}},[_._v("#")]),_._v(" 3.6. 线程同步的方式")]),_._v(" "),v("ol",[v("li",[_._v("互斥量（锁）：通过互斥机制防止多个线程同时访问公共资源（缺点：同一时刻只有一个线程访问公共资源）")]),_._v(" "),v("li",[_._v("信号量（"),v("code",[_._v("Semphare")]),_._v("）：控制同一时刻多个线程访问同一个资源的线程数")]),_._v(" "),v("li",[_._v("事件（信号）：通过通知的方式保持多个线程同步")])]),_._v(" "),v("h5",{attrs:{id:"_3-6-1-线程同步之互斥量"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-6-1-线程同步之互斥量"}},[_._v("#")]),_._v(" 3.6.1. 线程同步之互斥量")]),_._v(" "),v("p",[_._v("当一个线程操作的时候，阻止另一个线程访问这个临界资源（加锁、解锁）")]),_._v(" "),v("ul",[v("li",[_._v("生产者、消费者模型的根本：两个线程的指令交叉执行")]),_._v(" "),v("li",[_._v("互斥量可以"),v("strong",[_._v("保证先后执行")])])]),_._v(" "),v("p",[_._v("原子性定义：")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("一系列操作不可被中断")]),_._v("的特性")]),_._v(" "),v("li",[_._v("这"),v("strong",[_._v("一系列操作要么全部执行完，要么全部没有执行")])]),_._v(" "),v("li",[_._v("不存在部分执行部分未执行的情况")])]),_._v(" "),v("p",[_._v("互斥量：")]),_._v(" "),v("ul",[v("li",[_._v("互斥量是最简单的线程同步的方法")]),_._v(" "),v("li",[_._v("互斥量（互斥锁），处于两态之一的变量：解锁和加锁")]),_._v(" "),v("li",[_._v("两个状态可以"),v("strong",[_._v("保证资源访问的串行")])])]),_._v(" "),v("h5",{attrs:{id:"_3-6-2-线程同步之自旋锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-6-2-线程同步之自旋锁"}},[_._v("#")]),_._v(" 3.6.2. 线程同步之自旋锁")]),_._v(" "),v("p",[_._v("使用临界资源之前加锁，使用再解锁，和互斥锁一样")]),_._v(" "),v("p",[_._v("与互斥锁不同点：")]),_._v(" "),v("ul",[v("li",[_._v("使用自旋锁的线程会"),v("strong",[_._v("反复检查锁变量是否可用")])]),_._v(" "),v("li",[_._v("自旋锁"),v("strong",[_._v("不会让出CPU")]),_._v("，是一种"),v("strong",[_._v("忙等待")]),_._v("状态")]),_._v(" "),v("li",[v("strong",[_._v("死循环")]),_._v("，等待锁被释放")])]),_._v(" "),v("p",[_._v("特点：")]),_._v(" "),v("ul",[v("li",[_._v("自旋锁"),v("strong",[_._v("避免了进程或线程上下文切换的开销")])]),_._v(" "),v("li",[_._v("操作系统内部很多地方使用的是自旋锁")]),_._v(" "),v("li",[_._v("自旋锁"),v("strong",[_._v("不适合在单核CPU使用")])])]),_._v(" "),v("p",[_._v("相当于痴心汉不断地纠缠")]),_._v(" "),v("h5",{attrs:{id:"_3-6-3-线程同步之读写锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-6-3-线程同步之读写锁"}},[_._v("#")]),_._v(" 3.6.3. 线程同步之读写锁")]),_._v(" "),v("ul",[v("li",[_._v("临界资源"),v("strong",[_._v("多读少写")])]),_._v(" "),v("li",[_._v("读取时候并不会改变临界资源的值")])]),_._v(" "),v("p",[_._v("读写锁特点：")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("特殊的自旋锁")])]),_._v(" "),v("li",[_._v("允许"),v("strong",[_._v("多个读者同时访问资源")]),_._v("以提高性能")]),_._v(" "),v("li",[_._v("对于"),v("strong",[_._v("写操作则是互斥的")])])]),_._v(" "),v("p",[_._v("读和读不互斥，读和写互斥，写和写互斥")]),_._v(" "),v("h5",{attrs:{id:"_3-6-4-线程同步之条件变量"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-6-4-线程同步之条件变量"}},[_._v("#")]),_._v(" 3.6.4. 线程同步之条件变量")]),_._v(" "),v("ul",[v("li",[_._v("条件变量是相对复杂的线程同步方法")]),_._v(" "),v("li",[_._v("条件变量"),v("strong",[_._v("允许线程睡眠，直到满足条件")])]),_._v(" "),v("li",[_._v("当满足条件时，可以向该线程发送信号，"),v("strong",[_._v("通知唤醒")])]),_._v(" "),v("li",[_._v("配合互斥量使用")])]),_._v(" "),v("p",[_._v("具体：")]),_._v(" "),v("ol",[v("li",[_._v("缓冲区小于等于"),v("code",[_._v("0")]),_._v("时，不允许消费者消费，消费者必须等待")]),_._v(" "),v("li",[_._v("缓冲区满时，不允许生产者往缓冲区生产，生产者必须等待")]),_._v(" "),v("li",[_._v("前者情况，当生产者生产一个产品时，唤醒可能等待的消费者")]),_._v(" "),v("li",[_._v("后者情况，当消费者消费一个产品时，唤醒可能等待的生产者")])]),_._v(" "),v("p",[_._v("对比：")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("同步方法")]),_._v(" "),v("th",[_._v("描述")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("互斥锁")]),_._v(" "),v("td",[v("strong",[_._v("最简单")]),_._v("的一种线程同步方式，会"),v("strong",[_._v("阻塞线程")])])]),_._v(" "),v("tr",[v("td",[_._v("自旋锁")]),_._v(" "),v("td",[v("strong",[_._v("避免切换")]),_._v("的一种线程同步方法，属于“"),v("strong",[_._v("忙等待")]),_._v("”")])]),_._v(" "),v("tr",[v("td",[_._v("读写锁")]),_._v(" "),v("td",[_._v("为“"),v("strong",[_._v("读多写少")]),_._v("”的资源设计的线程同步方法，可以"),v("strong",[_._v("显著提高性能")])])]),_._v(" "),v("tr",[v("td",[_._v("条件变量")]),_._v(" "),v("td",[_._v("相对复杂的一种线程同步方法，有"),v("strong",[_._v("更灵活的使用场景")])])])])]),_._v(" "),v("h4",{attrs:{id:"_3-7-python中如何使用多线程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-7-python中如何使用多线程"}},[_._v("#")]),_._v(" 3.7. python中如何使用多线程？")]),_._v(" "),v("p",[v("code",[_._v("threading")]),_._v("模块")]),_._v(" "),v("ol",[v("li",[v("code",[_._v("threading.Thread")]),_._v("类用来创建线程")]),_._v(" "),v("li",[v("code",[_._v("start()")]),_._v(" 方法启动线程")]),_._v(" "),v("li",[v("code",[_._v("join()")]),_._v("方法等待线程结束")])]),_._v(" "),v("h3",{attrs:{id:"_4-linux进程管理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-linux进程管理"}},[_._v("#")]),_._v(" 4. Linux进程管理")]),_._v(" "),v("h4",{attrs:{id:"_4-1-进程的类型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-进程的类型"}},[_._v("#")]),_._v(" 4.1. 进程的类型")]),_._v(" "),v("ol",[v("li",[_._v("前台进程")]),_._v(" "),v("li",[_._v("后台进程")]),_._v(" "),v("li",[_._v("守护进程")])]),_._v(" "),v("h4",{attrs:{id:"_4-2-前台进程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-前台进程"}},[_._v("#")]),_._v(" 4.2. 前台进程")]),_._v(" "),v("p",[_._v("具有终端，可以和用户交互的进程（占用了终端shell）")]),_._v(" "),v("h4",{attrs:{id:"_4-3-后台进程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-后台进程"}},[_._v("#")]),_._v(" 4.3. 后台进程")]),_._v(" "),v("ol",[v("li",[_._v("没有占用终端（可能有打印，但不影响使用Shell，同时Ctrl+C也不会停止）")]),_._v(" "),v("li",[_._v("不和用户交互，优先级比前台进程低")]),_._v(" "),v("li",[_._v("将需要执行的命令以&符号结束")])]),_._v(" "),v("h4",{attrs:{id:"_4-4-守护进程-daemon"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-守护进程-daemon"}},[_._v("#")]),_._v(" 4.4. 守护进程( "),v("code",[_._v("daemon")]),_._v(" )")]),_._v(" "),v("ol",[v("li",[_._v("特殊的后台进程")]),_._v(" "),v("li",[_._v("很多在在系统引导的时候启动，一直运行直到系统关闭")]),_._v(" "),v("li",[_._v("进程名字一般以d结尾，比如 crond、httpd、sshd、mysqld")])]),_._v(" "),v("p",[_._v("进程的标记：")]),_._v(" "),v("ul",[v("li",[_._v("[ ] 进程ID")]),_._v(" "),v("li",[_._v("[ ] 进程的状态标记")])]),_._v(" "),v("p",[_._v("进程状态标记：\n"),v("img",{attrs:{src:"/imgs/process_status_symbol.jpg",alt:"进程状态标记"}})]),_._v(" "),v("p",[_._v("父子进程关系（"),v("code",[_._v("pstree")]),_._v("命令）：")]),_._v(" "),v("p",[v("img",{attrs:{src:"/imgs/process_extention.png",alt:"父子进程关系"}})]),_._v(" "),v("h4",{attrs:{id:"_4-5-特殊进程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-5-特殊进程"}},[_._v("#")]),_._v(" 4.5. 特殊进程")]),_._v(" "),v("ul",[v("li",[_._v("ID为 0 的进程是"),v("code",[_._v("idle")]),_._v("进程，是系统创建的第一个进程")]),_._v(" "),v("li",[_._v("ID为 1 的进程是"),v("code",[_._v("init")]),_._v("进程，是 0 号进程的子进程，完成系统初始化")]),_._v(" "),v("li",[_._v("init 进程是所有用户进程的祖先进程")])]),_._v(" "),v("h4",{attrs:{id:"_4-6-什么是线程池"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-6-什么是线程池"}},[_._v("#")]),_._v(" 4.6. 什么是线程池")]),_._v(" "),v("ul",[v("li",[_._v("线程池是"),v("strong",[_._v("存放多个线程的容器")])]),_._v(" "),v("li",[_._v("CPU调度线程执行后"),v("strong",[_._v("不会销毁线程")])]),_._v(" "),v("li",[_._v("将线程放回线程池 "),v("strong",[_._v("重复利用")])])]),_._v(" "),v("h5",{attrs:{id:"_4-6-1-为什么使用线程池"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-6-1-为什么使用线程池"}},[_._v("#")]),_._v(" 4.6.1. 为什么使用线程池")]),_._v(" "),v("ul",[v("li",[_._v("线程是"),v("strong",[_._v("稀缺资源")]),_._v("，"),v("strong",[_._v("不应该频繁创建和销毁")])]),_._v(" "),v("li",[_._v("架构解耦，线程创建和业务处理解耦，更加优雅")]),_._v(" "),v("li",[_._v("线程池是使用线程的"),v("strong",[_._v("最佳实践")])])]),_._v(" "),v("h3",{attrs:{id:"_5-使用fork系统调用创建进程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-使用fork系统调用创建进程"}},[_._v("#")]),_._v(" 5. 使用"),v("code",[_._v("fork")]),_._v("系统调用创建进程")]),_._v(" "),v("ul",[v("li",[_._v("[ ] "),v("code",[_._v("fork")]),_._v("系统调用用于创建进程")]),_._v(" "),v("li",[_._v("[ ] "),v("code",[_._v("fork")]),_._v("创建的进程"),v("strong",[_._v("初始化状态与父进程一样")]),_._v("，"),v("strong",[_._v("初始时内存空间一样")]),_._v("，后来不一样")]),_._v(" "),v("li",[_._v("[ ] 系统为"),v("code",[_._v("fork")]),_._v("的进程分配新的资源")])]),_._v(" "),v("p",[v("code",[_._v("fork")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("[ ] "),v("code",[_._v("fork")]),_._v("系统调用无参数")]),_._v(" "),v("li",[_._v("[ ] "),v("code",[_._v("fork")]),_._v("会"),v("strong",[_._v("返回两次")]),_._v("，分别返回子进程"),v("code",[_._v("id")]),_._v("和"),v("code",[_._v("0")])]),_._v(" "),v("li",[_._v("[ ] 第一次由父进程返回，第二次由子进程返回，"),v("strong",[_._v("返回子进程"),v("code",[_._v("id")]),_._v("的是父进程")]),_._v("，"),v("strong",[_._v("返回"),v("code",[_._v("0")]),_._v("的是子进程")])])])])}),[],!1,null,null,null);v.default=r.exports}}]);