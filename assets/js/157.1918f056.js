(window.webpackJsonp=window.webpackJsonp||[]).push([[157],{458:function(t,e,o){"use strict";o.r(e);var r=o(25),a=Object(r.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h3",{attrs:{id:"_1-mobx-的流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-mobx-的流程"}},[t._v("#")]),t._v(" 1. mobx 的流程")]),t._v(" "),e("p",[t._v("触发action，在action中修改state，通过computed拿到state的计算值，自动触发对应的reactions，这里包含autorun，渲染视图等。\n有一点需要注意：相对于react来说，mobx没有一个全局的状态树，状态分散在各个独立的store中。\nmobx的工作原理非常简单，使用"),e("code",[t._v("Object.defineProperty")]),t._v("来拦截对数据的访问，一旦值发生变化，将会调用react的render方法来实现重新渲染视图的功能或者触发autorun等。")]),t._v(" "),e("h3",{attrs:{id:"_2-redux-和-mobx-对比"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-redux-和-mobx-对比"}},[t._v("#")]),t._v(" 2. redux 和 mobx 对比")]),t._v(" "),e("ol",[e("li",[t._v("redux将数据保存在单一的store中，mobx将"),e("strong",[t._v("数据保存在分散的多个store中")])]),t._v(" "),e("li",[t._v("redux使用plain object保存数据，需要手动处理变化后的操作；mobx使用"),e("code",[t._v("observable")]),t._v("保存数据，数据变化后自动处理响应的操作")]),t._v(" "),e("li",[t._v("redux使用不可变状态，这意味着"),e("strong",[t._v("状态是只读的，不能直接去修改它，而是应该返回一个新的状态")]),t._v("，同时使用纯函数；"),e("strong",[t._v("mobx中的状态是可变的，可以直接对其进行修改")])]),t._v(" "),e("li",[t._v("mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系列的中间件来处理异步和副作用")]),t._v(" "),e("li",[t._v("mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易")])])])}),[],!1,null,null,null);e.default=a.exports}}]);