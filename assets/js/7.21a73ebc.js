(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{471:function(_,v,t){_.exports=t.p+"assets/img/os_memory_take_back.6abd0df3.png"},472:function(_,v,t){_.exports=t.p+"assets/img/small_memory_fragment.31c51c62.png"},473:function(_,v,t){_.exports=t.p+"assets/img/linux_memory_page.d95ebedf.png"},474:function(_,v,t){_.exports=t.p+"assets/img/os_page_memory_manage.29c014ce.png"},475:function(_,v,t){_.exports=t.p+"assets/img/os_multi_page_memory_manage.e6e81197.png"},476:function(_,v,t){_.exports=t.p+"assets/img/linux_memory_segment.2b4f9ad1.png"},477:function(_,v,t){_.exports=t.p+"assets/img/os_photograph_memory_manage.58716998.png"},478:function(_,v,t){_.exports=t.p+"assets/img/os_page_photograph_memory_manage.d4ae2130.png"},479:function(_,v,t){_.exports=t.p+"assets/img/os_vitual_memory.eeb1690a.png"},665:function(_,v,t){"use strict";t.r(v);var a=t(42),s=Object(a.a)({},(function(){var _=this,v=_.$createElement,a=_._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[a("ul",[a("li",[a("a",{attrs:{href:"#1-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E4%B9%8B%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6"}},[_._v("1. 存储管理之内存分配与回收")]),_._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#11-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B"}},[_._v("1.1. 内存分配过程")])]),_._v(" "),a("li",[a("a",{attrs:{href:"#12-%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"}},[_._v("1.2. 动态分区分配数据结构")])]),_._v(" "),a("li",[a("a",{attrs:{href:"#13-%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"}},[_._v("1.3. 动态分区分配算法")])]),_._v(" "),a("li",[a("a",{attrs:{href:"#14-%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E7%9A%84%E8%BF%87%E7%A8%8B"}},[_._v("1.4. 内存回收的过程")])])])]),_._v(" "),a("li",[a("a",{attrs:{href:"#2-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E4%B9%8B%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"}},[_._v("2. 存储管理之段页式存储管理")]),_._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#21-%E5%AD%97%E5%9D%97%E5%92%8C%E9%A1%B5%E9%9D%A2"}},[_._v("2.1. 字块和页面")])]),_._v(" "),a("li",[a("a",{attrs:{href:"#22-%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"}},[_._v("2.2. 页式存储管理")]),_._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#221-%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6"}},[_._v("2.2.1. 什么是分页机制？")])])])]),_._v(" "),a("li",[a("a",{attrs:{href:"#23-%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"}},[_._v("2.3. 段式存储管理")]),_._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#231-%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6"}},[_._v("2.3.1. 什么是分段机制？")])])])]),_._v(" "),a("li",[a("a",{attrs:{href:"#24-%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"}},[_._v("2.4. 段页式存储管理")]),_._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#241-%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%8A%96%E5%8A%A8%E9%A2%A0%E7%B0%B8"}},[_._v("2.4.1. 什么是内存抖动（颠簸）？")])])])])])]),_._v(" "),a("li",[a("a",{attrs:{href:"#3-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E4%B9%8B%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"}},[_._v("3. 存储管理之虚拟内存")]),_._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#31-%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"}},[_._v("3.1. 程序的局部性原理")])]),_._v(" "),a("li",[a("a",{attrs:{href:"#32-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"}},[_._v("3.2. 虚拟内存的置换算法")])])])]),_._v(" "),a("li",[a("a",{attrs:{href:"#4-linux%E7%9A%84%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"}},[_._v("4. Linux的存储管理")]),_._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#41-%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F"}},[_._v("4.1. 伙伴系统")])]),_._v(" "),a("li",[a("a",{attrs:{href:"#42-linux%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4"}},[_._v("4.2. Linux交换空间")])])])])]),_._v(" "),a("h2",{attrs:{id:"存储管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#存储管理"}},[_._v("#")]),_._v(" 存储管理 ")]),_._v(" "),a("h3",{attrs:{id:"_1-存储管理之内存分配与回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-存储管理之内存分配与回收"}},[_._v("#")]),_._v(" 1. 存储管理之内存分配与回收")]),_._v(" "),a("h4",{attrs:{id:"_1-1-内存分配过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-内存分配过程"}},[_._v("#")]),_._v(" 1.1. 内存分配过程")]),_._v(" "),a("ol",[a("li",[a("strong",[_._v("单一连续分配")]),_._v("：只能在单用户、单进程的操作系统中使用，主存分为系统区和用户区")]),_._v(" "),a("li",[a("strong",[_._v("固定分区分配")]),_._v("：内存空间分为若干固定大小的区域，每个分区只提供给一个程序使用，互不干扰（多道程序中存储管理的最简单方式）")]),_._v(" "),a("li",[a("strong",[_._v("动态分区分配")]),_._v("（最常用）")])]),_._v(" "),a("h4",{attrs:{id:"_1-2-动态分区分配数据结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-动态分区分配数据结构"}},[_._v("#")]),_._v(" 1.2. 动态分区分配数据结构")]),_._v(" "),a("ol",[a("li",[_._v("动态分区"),a("strong",[_._v("空闲表")]),_._v("数据结构")]),_._v(" "),a("li",[_._v("动态分区"),a("strong",[_._v("空闲链")]),_._v("数据结构（节点合并，节点需要记录可存储的容量）")])]),_._v(" "),a("h4",{attrs:{id:"_1-3-动态分区分配算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-动态分区分配算法"}},[_._v("#")]),_._v(" 1.3. 动态分区分配算法")]),_._v(" "),a("ol",[a("li",[a("strong",[_._v("首次适应")]),_._v("算法（"),a("code",[_._v("FF")]),_._v("算法）（从开始顺序查找适合内存区，若没有合适的空闲区，则该次分配失败，一般是链表结构，每次从头部开始，使得头部地址空间不断被划分，循环适应算法，从上一次结束的位置开始）")]),_._v(" "),a("li",[a("strong",[_._v("最佳适应")]),_._v("算法（"),a("code",[_._v("BF")]),_._v("算法）（按照容量大小排序，找到最佳合适空闲区）")]),_._v(" "),a("li",[a("strong",[_._v("快速使用")]),_._v("算法（"),a("code",[_._v("QF")]),_._v("算法）（有多个空闲区链表，每个链表存储一种容量的空闲区）")])]),_._v(" "),a("h4",{attrs:{id:"_1-4-内存回收的过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-内存回收的过程"}},[_._v("#")]),_._v(" 1.4. 内存回收的过程")]),_._v(" "),a("p",[_._v("四种情况：")]),_._v(" "),a("p",[a("img",{attrs:{src:t(471),alt:"内存回收"}})]),_._v(" "),a("ul",[a("li",[a("p",[_._v("第一种，回收区在空闲区"),a("strong",[_._v("后面")]),_._v("：")]),_._v(" "),a("ul",[a("li",[_._v("不需要新建空闲链表节点")]),_._v(" "),a("li",[_._v("只需要把空闲区1的容量增大到回收区即可")])])]),_._v(" "),a("li",[a("p",[_._v("第二种，回收区在空闲区"),a("strong",[_._v("前面")]),_._v("：")]),_._v(" "),a("ul",[a("li",[_._v("将回收区与空闲区合并")]),_._v(" "),a("li",[_._v("新的空闲区使用回收区的地址")])])]),_._v(" "),a("li",[a("p",[_._v("第三种，回收区在两个空闲区"),a("strong",[_._v("中间")]),_._v("：")]),_._v(" "),a("ul",[a("li",[_._v("将空闲区1、空闲区2和回收区合并")]),_._v(" "),a("li",[_._v("新的空闲区使用空闲区1地址")])])]),_._v(" "),a("li",[a("p",[_._v("第四种，"),a("strong",[_._v("单一")]),_._v("的回收区：")]),_._v(" "),a("ul",[a("li",[_._v("为回收区创建新的空闲节点")]),_._v(" "),a("li",[_._v("插入到相应的空闲区链表中去")])])])]),_._v(" "),a("h3",{attrs:{id:"_2-存储管理之段页式存储管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-存储管理之段页式存储管理"}},[_._v("#")]),_._v(" 2. 存储管理之段页式存储管理")]),_._v(" "),a("p",[_._v("段页式是进程角度，上面是物理内存角度")]),_._v(" "),a("h4",{attrs:{id:"_2-1-字块和页面"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-字块和页面"}},[_._v("#")]),_._v(" 2.1. 字块和页面")]),_._v(" "),a("ol",[a("li",[_._v("字块是相对物理设备的定义")]),_._v(" "),a("li",[_._v("页面是相对逻辑空间的定义")])]),_._v(" "),a("h4",{attrs:{id:"_2-2-页式存储管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-页式存储管理"}},[_._v("#")]),_._v(" 2.2. 页式存储管理")]),_._v(" "),a("ol",[a("li",[_._v("将进程逻辑空间 等分成若干大小的页面")]),_._v(" "),a("li",[_._v("相应的把物理内存空间分成与页面大小相同的物理块")]),_._v(" "),a("li",[_._v("以页面为单位把进程空间装进物理内存中分散的物理块")])]),_._v(" "),a("p",[_._v("注意：")]),_._v(" "),a("ol",[a("li",[_._v("页面大小应该适中，过大难以分配，过小内存碎片过多")]),_._v(" "),a("li",[_._v("页面大小通常是"),a("code",[_._v("512B~8kB")])])]),_._v(" "),a("p",[a("img",{attrs:{src:t(472),alt:"内存碎片"}})]),_._v(" "),a("h5",{attrs:{id:"_2-2-1-什么是分页机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-1-什么是分页机制"}},[_._v("#")]),_._v(" 2.2.1. 什么是分页机制？")]),_._v(" "),a("ul",[a("li",[_._v("操作系统为了"),a("strong",[_._v("高效管理内存，减少碎片")])]),_._v(" "),a("li",[a("strong",[_._v("逻辑地址和物理地址分离")]),_._v("的内存分配管理方案")]),_._v(" "),a("li",[_._v("程序的逻辑地址划分为固定大小的页("),a("code",[_._v("Page")]),_._v(")")]),_._v(" "),a("li",[_._v("物理地址划分为同样大小的帧("),a("code",[_._v("Frame")]),_._v(") （不一定连续）")]),_._v(" "),a("li",[_._v("通过页表对应逻辑地址和物理地址")])]),_._v(" "),a("p",[_._v("页表记录进程逻辑空间与物理空间的映射，"),a("strong",[_._v("页面号和字块号")]),_._v("的映射关系。地址中"),a("strong",[_._v("页号")]),_._v("相当于"),a("strong",[_._v("字号")]),_._v("、"),a("strong",[_._v("页内偏移")]),_._v("相当于"),a("strong",[_._v("字块内偏移")])]),_._v(" "),a("p",[a("img",{attrs:{src:t(473),alt:"什么是分页机制"}}),_._v(" "),a("img",{attrs:{src:t(474),alt:"页式存储管理"}})]),_._v(" "),a("p",[_._v("多级页表，减少页表占用的空间，按需取页表，加载到内存中：")]),_._v(" "),a("p",[a("img",{attrs:{src:t(475),alt:"多级页表"}})]),_._v(" "),a("p",[_._v("问题：有一段连续的逻辑分布在多个页面中，将大大降低执行效率")]),_._v(" "),a("h4",{attrs:{id:"_2-3-段式存储管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-段式存储管理"}},[_._v("#")]),_._v(" 2.3. 段式存储管理")]),_._v(" "),a("ol",[a("li",[_._v("将进程逻辑空间划分为若干段（非等分）")]),_._v(" "),a("li",[_._v("段的长度由"),a("strong",[_._v("连续逻辑的长度")]),_._v("决定")]),_._v(" "),a("li",[_._v("主函数MAIN、子程序段X、子函数Y等")])]),_._v(" "),a("h5",{attrs:{id:"_2-3-1-什么是分段机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-1-什么是分段机制"}},[_._v("#")]),_._v(" 2.3.1. 什么是分段机制？")]),_._v(" "),a("ul",[a("li",[_._v("分段是为了满足代码的一些逻辑需求")]),_._v(" "),a("li",[_._v("数据共享，数据保护，动态链接等(比如编写一个忘记递归出口的函数导致栈溢出)")]),_._v(" "),a("li",[_._v("通过段表实现逻辑地址和物理地址的映射关系")]),_._v(" "),a("li",[_._v("每个段内部是连续内存分配，段和段之间是离散分配的")])]),_._v(" "),a("p",[_._v("段表：")]),_._v(" "),a("ol",[a("li",[_._v("段号")]),_._v(" "),a("li",[_._v("基址（起始地址）")]),_._v(" "),a("li",[_._v("段长")])]),_._v(" "),a("p",[a("img",{attrs:{src:t(476),alt:"什么是分段机制"}})]),_._v(" "),a("p",[a("img",{attrs:{src:t(477),alt:"段式存储管理"}})]),_._v(" "),a("p",[_._v("段式存储和页式存储的对比：")]),_._v(" "),a("ol",[a("li",[_._v("段式存储和页式存储都离散地管理了进程的逻辑空间")]),_._v(" "),a("li",[a("strong",[_._v("页是物理单位")]),_._v("，"),a("strong",[_._v("段是逻辑单位")])]),_._v(" "),a("li",[a("strong",[_._v("分页是为了合理利用空间")]),_._v("，"),a("strong",[_._v("分段是满足用户要求")])]),_._v(" "),a("li",[a("strong",[_._v("页的大小固定")]),_._v("，"),a("strong",[_._v("段长度可以动态变化")])]),_._v(" "),a("li",[_._v("页表信息是一维的，段表信息是二维的")])]),_._v(" "),a("h4",{attrs:{id:"_2-4-段页式存储管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-段页式存储管理"}},[_._v("#")]),_._v(" 2.4. 段页式存储管理")]),_._v(" "),a("ol",[a("li",[_._v("分页可以提高内存利用率（虽然存在内存碎片），分段可以更好的满足用户需求")]),_._v(" "),a("li",[_._v("先将逻辑空间按段式管理分成若干段")]),_._v(" "),a("li",[_._v("再将段内空间按页式管理分成若干页")])]),_._v(" "),a("p",[_._v("段页地址")]),_._v(" "),a("ol",[a("li",[_._v("段号")]),_._v(" "),a("li",[_._v("段内页号")]),_._v(" "),a("li",[_._v("页内地址")])]),_._v(" "),a("p",[_._v("示例：")]),_._v(" "),a("p",[a("img",{attrs:{src:t(478),alt:"段页式存储管理"}})]),_._v(" "),a("h5",{attrs:{id:"_2-4-1-什么是内存抖动-颠簸"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-1-什么是内存抖动-颠簸"}},[_._v("#")]),_._v(" 2.4.1. 什么是内存抖动（颠簸）？")]),_._v(" "),a("p",[_._v("本质是"),a("strong",[_._v("频繁的页调度行为")])]),_._v(" "),a("ul",[a("li",[_._v("频繁的页调度，进程不断产出缺页中断。交换内存到硬盘时，需要一种策略，比如当前不用的话把它交换进去，策略有"),a("code",[_._v("LRU")]),_._v("、"),a("code",[_._v("LFU")]),_._v("、"),a("code",[_._v("先进先出")]),_._v("，策略使用不当时，更换一个页，进入到一个硬盘里，后面又需要它，又把它交换回来（用户电脑性能急剧下降）")]),_._v(" "),a("li",[_._v("置换一个页，又不断再次需要这个页")]),_._v(" "),a("li",[_._v("运行程序太多；页面替换策略不好。终止进程或者增加物理内存")])]),_._v(" "),a("h3",{attrs:{id:"_3-存储管理之虚拟内存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-存储管理之虚拟内存"}},[_._v("#")]),_._v(" 3. 存储管理之虚拟内存")]),_._v(" "),a("p",[_._v("一个游戏十几G，而物理内存只有4G，怎么运行起来？")]),_._v(" "),a("p",[_._v("产生原因：")]),_._v(" "),a("ol",[a("li",[_._v("有些进程实际需要的内存很大，超过物理内存的容量")]),_._v(" "),a("li",[_._v("多道程序设计，使得每个进程可用物理内存更加稀缺")])]),_._v(" "),a("p",[_._v("原理：\n把程序使用内存划分，将部分暂时不用的内存放置在辅存")]),_._v(" "),a("p",[_._v("什么是虚拟内存？\n把一部分"),a("strong",[_._v("暂时不用的内存信息放到硬盘上")])]),_._v(" "),a("ul",[a("li",[_._v("局部性原理（包括空间和时间），程序运行时只有部分必要的信息装入内存\n"),a("ul",[a("li",[_._v("时间局部性：一块内存被访问时，很有可能在不远的将来还会被访问")]),_._v(" "),a("li",[_._v("空间局部性：一块内存被访问时，那么它周围的内存也很有可能被访问")])])]),_._v(" "),a("li",[_._v("内存中暂时不需要的内容放到硬盘上，需要的时候再把它交换回来")]),_._v(" "),a("li",[_._v("系统似乎提供了比实际内存大得多的容量，称之为虚拟内存")])]),_._v(" "),a("p",[a("img",{attrs:{src:t(479),alt:"虚拟内存"}})]),_._v(" "),a("h4",{attrs:{id:"_3-1-程序的局部性原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-程序的局部性原理"}},[_._v("#")]),_._v(" 3.1. 程序的局部性原理")]),_._v(" "),a("p",[_._v("指CUP访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。")]),_._v(" "),a("ol",[a("li",[_._v("程序运行时，"),a("strong",[_._v("无需全部装入内存")]),_._v("，装载部分即可")]),_._v(" "),a("li",[_._v("如果访问页不在内存，则发出"),a("strong",[_._v("缺页中断")]),_._v("，发起"),a("strong",[_._v("页面置换")])]),_._v(" "),a("li",[_._v("从用户角度看，程序拥有很大的空间，即是"),a("strong",[_._v("虚拟内存")])]),_._v(" "),a("li",[_._v("虚拟内存实际是对物理内存的补充，速度接近于内存，成本接近于辅存")])]),_._v(" "),a("h4",{attrs:{id:"_3-2-虚拟内存的置换算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-虚拟内存的置换算法"}},[_._v("#")]),_._v(" 3.2. 虚拟内存的置换算法")]),_._v(" "),a("ol",[a("li",[_._v("先进先出算法("),a("code",[_._v("FIFO")]),_._v(")")]),_._v(" "),a("li",[_._v("最不经常使用算法("),a("code",[_._v("LFU")]),_._v(")")]),_._v(" "),a("li",[_._v("最近最少使用算法("),a("code",[_._v("LRU")]),_._v(")")])]),_._v(" "),a("h3",{attrs:{id:"_4-linux的存储管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-linux的存储管理"}},[_._v("#")]),_._v(" 4. Linux的存储管理")]),_._v(" "),a("p",[_._v("Buddy内存管理算法")]),_._v(" "),a("ol",[a("li",[_._v("解决内存外碎片问题")]),_._v(" "),a("li",[_._v("经典的内存管理算法")]),_._v(" "),a("li",[_._v("算法基于计算机处理二进制的优势具有极高的效率")]),_._v(" "),a("li",[_._v("将内存外碎片问题转移到内存内碎片问题")])]),_._v(" "),a("p",[_._v("页内碎片：")]),_._v(" "),a("ul",[a("li",[_._v("已经被分配出去（能明确指出属于哪个进程）的内存空间大于请求所需的内存空间，不能被利用的内存空间")])]),_._v(" "),a("p",[_._v("页外碎片：")]),_._v(" "),a("ul",[a("li",[_._v("还没有被分配出去（不属于任何进程），但由于太小无法分配给申请内存空间的新进程的内存空闲块。")])]),_._v(" "),a("p",[_._v("类比：")]),_._v(" "),a("ol",[a("li",[_._v("页外碎片相当于太挫找不到对象")]),_._v(" "),a("li",[_._v("页内碎片相当于太优秀而对象太垃圾")])]),_._v(" "),a("p",[_._v("原则")]),_._v(" "),a("ul",[a("li",[_._v("向上取整为2的幂大小\n"),a("ul",[a("li",[a("code",[_._v("70k => 128k")])]),_._v(" "),a("li",[a("code",[_._v("129k => 256k")])]),_._v(" "),a("li",[a("code",[_._v("666k => 1024k")])])])])]),_._v(" "),a("h4",{attrs:{id:"_4-1-伙伴系统"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-伙伴系统"}},[_._v("#")]),_._v(" 4.1. 伙伴系统")]),_._v(" "),a("ul",[a("li",[_._v("一片连续内存的伙伴是"),a("strong",[_._v("相邻")]),_._v("的另一片"),a("strong",[_._v("大小一样")]),_._v("的连续内存")]),_._v(" "),a("li",[_._v("创建一系列空闲块链表，每一种都是"),a("strong",[_._v("2的幂")])]),_._v(" "),a("li",[_._v("以100k为例，看有没有"),a("code",[_._v("128k")]),_._v("、"),a("code",[_._v("256k")]),_._v("、"),a("code",[_._v("512k")]),_._v("、"),a("code",[_._v("1M")]),_._v("有没有空闲空间，直到找到"),a("code",[_._v("1M")]),_._v("才有，然后从"),a("code",[_._v("1M")]),_._v("拆下"),a("code",[_._v("512k")]),_._v("，再拆下"),a("code",[_._v("256k")]),_._v("，再"),a("strong",[_._v("拆下")]),a("code",[_._v("128k")]),_._v("，分配完毕。")]),_._v(" "),a("li",[_._v("回收的时候，以后一点点拼回"),a("code",[_._v("1M")])])]),_._v(" "),a("h4",{attrs:{id:"_4-2-linux交换空间"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-linux交换空间"}},[_._v("#")]),_._v(" 4.2. Linux交换空间")]),_._v(" "),a("ol",[a("li",[_._v("交换空间"),a("code",[_._v("(Swap")]),_._v(")是磁盘的一个分区")]),_._v(" "),a("li",[a("code",[_._v("Linux")]),_._v("物理内存满时，会把一些内存交换至Swap空间")]),_._v(" "),a("li",[a("code",[_._v("Swap")]),_._v("空间是初始化系统时配置的")])]),_._v(" "),a("p",[_._v("Linux交换空间")]),_._v(" "),a("ul",[a("li",[_._v("[ ] 冷启动内存依赖")]),_._v(" "),a("li",[_._v("[ ] 系统睡眠依赖")]),_._v(" "),a("li",[_._v("[ ] 大进程空间依赖")])]),_._v(" "),a("p",[a("code",[_._v("Swap")]),_._v("空间与虚拟内存对比：")]),_._v(" "),a("ol",[a("li",[_._v("都存在于磁盘，都与主存发生置换")]),_._v(" "),a("li",[a("code",[_._v("Swap")]),_._v("空间是"),a("strong",[_._v("操作系统概念")]),_._v("，"),a("strong",[_._v("虚拟内存是进程概念")])]),_._v(" "),a("li",[a("code",[_._v("Swap")]),_._v("空间解决"),a("strong",[_._v("系统物理内存不足")]),_._v("的问题，虚拟内存解决"),a("strong",[_._v("进程物理内存不足")]),_._v("的问题")])])])}),[],!1,null,null,null);v.default=s.exports}}]);