(window.webpackJsonp=window.webpackJsonp||[]).push([[184],{796:function(e,t,a){"use strict";a.r(t);var n=a(42),s=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"vue实例挂载的实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue实例挂载的实现"}},[e._v("#")]),e._v(" Vue实例挂载的实现")]),e._v(" "),a("p",[e._v("入口的路径为：\n1、 "),a("code",[e._v("src/platforms/web/entry-runtime-with-compiler.js")]),e._v("，运行时+编译版本的打包入口，重写了"),a("code",[e._v("$mount")]),e._v("=>\n2、 "),a("code",[e._v("src/platforms/web/runtime/index.js")]),e._v("，Vue入口，对Vue的扩展=>\n3、 "),a("code",[e._v("src/core/index.js")]),e._v("，对Vue初始化，initGlobalAPI(src/core/global-api/index.js，一些全局API)=>")]),e._v(" "),a("p",[e._v("4、 "),a("a",{attrs:{href:"https://github.com/vuejs/vue/blob/2.6/src/core/instance/index.js#8",target:"_blank",rel:"noopener noreferrer"}},[e._v("src/core/instance/index.js"),a("OutboundLink")],1),e._v("，Vue的定义文件")]),e._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("function")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("Vue")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[e._v("options")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("if")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("process"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("env"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token constant"}},[e._v("NODE_ENV")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("!==")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'production'")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("&&")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("!")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("this")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("instanceof")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Vue")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("warn")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'Vue is a constructor and should be called with the `new` keyword'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("_init")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("options"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[a("code",[e._v("this instanceof Vue")]),e._v("如果不是用"),a("code",[e._v("new")]),e._v("创建Vue实例的话，"),a("code",[e._v("this")]),e._v("会指向上下文，放在全局就是"),a("code",[e._v("window")]),e._v("，会触发警告。")]),e._v(" "),a("p",[e._v("然后会调用 "),a("a",{attrs:{href:"https://github.com/vuejs/vue/blob/2.6/src/core/instance/init.js#16",target:"_blank",rel:"noopener noreferrer"}},[e._v("_init"),a("OutboundLink")],1),e._v(" 方法，该方法在"),a("code",[e._v("src/core/instance/init.js")]),e._v("中，主要做了初始化生命周期、初始化事件、初始化渲染等。")]),e._v(" "),a("p",[a("code",[e._v("_init")]),e._v("方法主要最后调用了"),a("code",[e._v("$mount")]),e._v("方法，"),a("code",[e._v("compiler")]),e._v("版本的 "),a("a",{attrs:{href:"https://github.com/vuejs/vue/blob/2.6/src/platforms/web/entry-runtime-with-compiler.js#L18",target:"_blank",rel:"noopener noreferrer"}},[e._v("$mount"),a("OutboundLink")],1),e._v(" 定义在"),a("code",[e._v("src/platforms/web/entry-runtime-with-compiler.js")]),e._v("中。")]),e._v(" "),a("p",[e._v("先缓存了原型上的"),a("code",[e._v("$mount")]),e._v("，然后判断如果没有定义"),a("code",[e._v("render")]),e._v("方法的话，就把"),a("code",[e._v("el")]),e._v("或者"),a("code",[e._v("template")]),e._v("转为"),a("code",[e._v("render")]),e._v("，这个转化的过程是调用"),a("code",[e._v("compileToFunctions")]),e._v("方法实现的。")]),e._v(" "),a("p",[e._v("最后调用原先原型上的"),a("code",[e._v("$mount")]),e._v("方法实现挂载。")]),e._v(" "),a("p",[e._v("原先原型上的 "),a("a",{attrs:{href:"https://github.com/vuejs/vue/blob/2.6/src/platforms/web/runtime/index.js#L37",target:"_blank",rel:"noopener noreferrer"}},[e._v("$mount"),a("OutboundLink")],1),e._v(" 方法在src/platforms/web/runtime/index.js中。")]),e._v(" "),a("p",[a("code",[e._v("$mount")]),e._v("方法实际上会去调用 "),a("a",{attrs:{href:"https://github.com/vuejs/vue/blob/2.6/src/core/instance/lifecycle.js#L141",target:"_blank",rel:"noopener noreferrer"}},[e._v("mountComponent"),a("OutboundLink")],1),e._v(" 方法，这个方法定义在"),a("code",[e._v("src/core/instance/lifecycle.js")]),e._v("文件中。")]),e._v(" "),a("p",[a("code",[e._v("mountComponent")]),e._v(" 核心就是先实例化一个渲染Watcher，在它的回调函数中会调用 "),a("code",[e._v("updateComponent")]),e._v(" 方法，在此方法中调用 "),a("code",[e._v("vm._render")]),e._v(" 方法先生成虚拟 "),a("code",[e._v("Node")]),e._v("，最终调用 "),a("code",[e._v("vm._update")]),e._v(" 更新 DOM。")]),e._v(" "),a("p",[e._v("Watcher 在这里起到两个作用，一个是初始化的时候会执行回调函数，另一个是当 "),a("code",[e._v("vm")]),e._v(" 实例中的监测的数据发生变化的时候执行回调函数。")]),e._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("if")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("vm"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("$vnode "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("==")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  vm"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("_isMounted "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("true")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("callHook")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("vm"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'mounted'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("这里注意 "),a("code",[e._v("vm.$vnode")]),e._v(" 表示 Vue 实例的父虚拟 Node，所以它为 Null 则表示当前是根 Vue 的实例。")]),e._v(" "),a("h2",{attrs:{id:"render"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#render"}},[e._v("#")]),e._v(" render")]),e._v(" "),a("p",[e._v("Vue 的 "),a("a",{attrs:{href:"https://github.com/vuejs/vue/blob/2.6/src/core/instance/render.js#L62",target:"_blank",rel:"noopener noreferrer"}},[e._v("_render"),a("OutboundLink")],1),e._v(" 方法是实例的一个私有方法，它用来把实例渲染成一个虚拟 Node。它的定义在 "),a("code",[e._v("src/core/instance/render.js")]),e._v(" 文件中。")]),e._v(" "),a("p",[e._v("这段代码最关键的是 "),a("a",{attrs:{href:"https://github.com/vuejs/vue/blob/2.6/src/core/instance/render.js#L79",target:"_blank",rel:"noopener noreferrer"}},[e._v("render"),a("OutboundLink")],1),e._v(" 方法的调用，在 Vue 的官方文档中介绍了 render 函数的第一个参数是 createElement，那么结合之前的例子：")]),e._v(" "),a("div",{staticClass:"language-html extra-class"},[a("pre",{pre:!0,attrs:{class:"language-html"}},[a("code",[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("<")]),e._v("div")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("id")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[e._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v('"')]),e._v("app"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v('"')])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v("\n  {{ message }}\n"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("</")]),e._v("div")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v("\n")])])]),a("p",[e._v("相当于我们编写如下 render 函数：")]),e._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function-variable function"}},[e._v("render")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("function")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[e._v("createElement")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("return")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("createElement")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'div'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n     attrs"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n        id"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'app'")]),e._v("\n      "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("message"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("再回到 "),a("code",[e._v("_render")]),e._v(" 函数中的 "),a("code",[e._v("render")]),e._v(" 方法的调用：")]),e._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[e._v("vnode "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("render")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("call")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("vm"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("_renderProxy"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" vm"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("$createElement"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n")])])]),a("p",[e._v("可以看到，"),a("code",[e._v("render")]),e._v(" 函数中的 "),a("code",[e._v("createElement")]),e._v(" 方法就是 "),a("code",[e._v("vm.$createElement")]),e._v(" 方法。")]),e._v(" "),a("p",[a("code",[e._v("vm.$createElement")]),e._v(" 方法定义是在执行 "),a("code",[e._v("initRender")]),e._v(" 方法的时候，可以看到除了 "),a("code",[e._v("vm.$createElement")]),e._v(" 方法，还有一个 vm._c 方法，它是被模板编译成的 "),a("code",[e._v("render")]),e._v(" 函数使用，而 "),a("code",[e._v("vm.$createElement")]),e._v("是用户手写 "),a("code",[e._v("render")]),e._v(" 方法使用的， 这俩个方法支持的参数相同，并且内部都调用了 "),a("code",[e._v("createElement")]),e._v(" 方法。")]),e._v(" "),a("h2",{attrs:{id:"createelement"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#createelement"}},[e._v("#")]),e._v(" createElement")]),e._v(" "),a("p",[a("code",[e._v("Vue.js")]),e._v("利用 "),a("a",{attrs:{href:"https://github.com/vuejs/vue/blob/2.6/src/core/vdom/create-element.js#L28",target:"_blank",rel:"noopener noreferrer"}},[e._v("createElement"),a("OutboundLink")],1),e._v(" 方法创建 VNode，它定义在 "),a("code",[e._v("src/core/vdom/create-element.js")]),e._v(" 中：")]),e._v(" "),a("p",[a("code",[e._v("createElement")]),e._v(" 方法实际上是对 "),a("a",{attrs:{href:"https://github.com/vuejs/vue/blob/2.6/src/core/vdom/create-element.js#L47",target:"_blank",rel:"noopener noreferrer"}},[e._v("_createElement"),a("OutboundLink")],1),e._v(" 方法的封装，它允许传入的参数更加灵活，在处理这些参数后，调用真正创建 "),a("code",[e._v("VNode")]),e._v(" 的函数 "),a("code",[e._v("_createElement")])]),e._v(" "),a("p",[e._v("主要分析下"),a("code",[e._v("children")]),e._v("的规范化以及"),a("code",[e._v("VNode")]),e._v("的创建。")]),e._v(" "),a("h3",{attrs:{id:"children的规范化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#children的规范化"}},[e._v("#")]),e._v(" "),a("code",[e._v("children")]),e._v("的规范化")]),e._v(" "),a("p",[e._v("由于 Virtual DOM 实际上是一个树状结构，每一个 VNode 可能会有若干个子节点，这些子节点应该也是 VNode 的类型。_createElement 接收的第 4 个参数 children 是任意类型的，因此我们需要把它们规范成 VNode 类型。")]),e._v(" "),a("p",[e._v("这里根据 normalizationType 的不同，调用了 "),a("a",{attrs:{href:"https://github.com/vuejs/vue/blob/2.6/src/core/vdom/helpers/normalize-children.js#31",target:"_blank",rel:"noopener noreferrer"}},[e._v("normalizeChildren(children)"),a("OutboundLink")],1),e._v(" 和 "),a("a",{attrs:{href:"https://github.com/vuejs/vue/blob/2.6/src/core/vdom/helpers/normalize-children.js#18",target:"_blank",rel:"noopener noreferrer"}},[e._v("simpleNormalizeChildren(children)"),a("OutboundLink")],1),e._v(" 方法，它们的定义都在 src/core/vdom/helpers/normalzie-children.js 中。")]),e._v(" "),a("p",[e._v("simpleNormalizeChildren 方法调用场景是 render 函数是编译生成的。理论上编译生成的 children 都已经是 VNode 类型的，但这里有一个例外，就是 functional component 函数式组件返回的是一个数组而不是一个根节点，所以会通过 Array.prototype.concat 方法把整个 children 数组打平，让它的深度只有一层。")]),e._v(" "),a("p",[e._v("normalizeChildren 方法的调用场景有 2 种，一个场景是 render 函数是用户手写的，当 children 只有一个节点的时候，Vue.js 从接口层面允许用户把 children 写成基础类型用来创建单个简单的文本节点，这种情况会调用 createTextVNode 创建一个文本节点的 VNode；另一个场景是当编译 slot、v-for 的时候会产生嵌套数组的情况，会调用 "),a("a",{attrs:{href:"https://github.com/vuejs/vue/blob/2.6/src/core/vdom/helpers/normalize-children.js#L43",target:"_blank",rel:"noopener noreferrer"}},[e._v("normalizeArrayChildren"),a("OutboundLink")],1),e._v(" 方法，接下来看一下它的实现。")]),e._v(" "),a("p",[e._v("normalizeArrayChildren 接收 2 个参数，children 表示要规范的子节点，nestedIndex 表示嵌套的索引，因为单个 child 可能是一个数组类型。 normalizeArrayChildren 主要的逻辑就是遍历 children，获得单个节点 c，然后对 c 的类型判断，如果是一个数组类型，则递归调用 normalizeArrayChildren; 如果是基础类型，则通过 createTextVNode 方法转换成 VNode 类型；否则就已经是 VNode 类型了，如果 children 是一个列表并且列表还存在嵌套的情况，则根据 nestedIndex 去更新它的 key。这里需要注意一点，在遍历的过程中，对这 3 种情况都做了如下处理：如果存在两个连续的 text 节点，会把它们合并成一个 text 节点。")]),e._v(" "),a("p",[e._v("经过对 children 的规范化，children 变成了一个类型为 VNode 的 Array。")]),e._v(" "),a("h3",{attrs:{id:"vnode的创建"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vnode的创建"}},[e._v("#")]),e._v(" "),a("code",[e._v("VNode")]),e._v("的创建")]),e._v(" "),a("p",[e._v("这里先对 tag 做判断，如果是 string 类型，则接着判断如果是内置的一些节点，则直接创建一个普通 VNode，如果是为已注册的组件名，则通过 createComponent 创建一个组件类型的 VNode，否则创建一个未知的标签的 VNode。 如果是 tag 一个 Component 类型，则直接调用 createComponent 创建一个组件类型的 VNode 节点，本质上它还是返回了一个 VNode")]),e._v(" "),a("p",[e._v("回到 mountComponent 函数的过程，我们已经知道 vm._render 是如何创建了一个 VNode，接下来就是要把这个 VNode 渲染成一个真实的 DOM 并渲染出来，这个过程是通过 vm._update 完成的")]),e._v(" "),a("h2",{attrs:{id:"update"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#update"}},[e._v("#")]),e._v(" update")]),e._v(" "),a("p",[e._v("Vue 的 "),a("a",{attrs:{href:"https://github.com/vuejs/vue/blob/2.6/src/core/instance/lifecycle.js#L59",target:"_blank",rel:"noopener noreferrer"}},[e._v("_update"),a("OutboundLink")],1),e._v(" 是实例的一个私有方法，它被调用的时机有 2 个，一个是首次渲染，一个是数据更新的时候。"),a("code",[e._v("_update")]),e._v(" 方法的作用是把 VNode 渲染成真实的 DOM，它的定义在 "),a("code",[e._v("src/core/instance/lifecycle.js")]),e._v(" 中：")]),e._v(" "),a("p",[e._v("_update 的核心就是调用 "),a("code",[e._v("vm.__patch__")]),e._v(" 方法，这个方法实际上在不同的平台，比如 web 和 weex 上的定义是不一样的，因此在 web 平台中它的定义在 "),a("code",[e._v("src/platforms/web/runtime/index.js")]),e._v(" 中：")]),e._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Vue")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("prototype"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("__patch__ "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" inBrowser "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("?")]),e._v(" patch "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" noop\n")])])]),a("p",[e._v("可以看到，甚至在 web 平台上，是否是服务端渲染也会对这个方法产生影响。因为在服务端渲染中，没有真实的浏览器 DOM 环境，所以不需要把 VNode 最终转换成 DOM，因此是一个空函数，而在浏览器端渲染中，它指向了 "),a("a",{attrs:{href:"https://github.com/vuejs/vue/blob/2.6/src/platforms/web/runtime/patch.js#L12",target:"_blank",rel:"noopener noreferrer"}},[e._v("patch"),a("OutboundLink")],1),e._v(" 方法，它的定义在 "),a("code",[e._v("src/platforms/web/runtime/patch.js")]),e._v("中")]),e._v(" "),a("p",[e._v("该方法的定义是调用 "),a("code",[e._v("createPatchFunction")]),e._v(" 方法的返回值，这里传入了一个对象，包含 nodeOps 参数和 modules 参数。其中，nodeOps 封装了一系列 DOM 操作的方法，modules 定义了一些模块的钩子函数的实现，来看一下 "),a("a",{attrs:{href:"https://github.com/vuejs/vue/blob/2.6/src/core/vdom/patch.js#L70",target:"_blank",rel:"noopener noreferrer"}},[e._v("createPatchFunction"),a("OutboundLink")],1),e._v(" 的实现，它定义在 "),a("code",[e._v("src/core/vdom/patch.js")]),e._v(" 中")]),e._v(" "),a("p",[a("code",[e._v("createPatchFunction")]),e._v(" 内部定义了一系列的辅助方法，最终返回了一个 "),a("a",{attrs:{href:"https://github.com/vuejs/vue/blob/2.6/src/core/vdom/patch.js#L700",target:"_blank",rel:"noopener noreferrer"}},[e._v("patch"),a("OutboundLink")],1),e._v(" 方法，这个方法就赋值给了 "),a("code",[e._v("vm._update")]),e._v(" 函数里调用的 "),a("code",[e._v("vm.__patch__")]),e._v("。")]),e._v(" "),a("p",[a("code",[e._v("patch")]),e._v("方法，它接收 4个参数，oldVnode 表示旧的 VNode 节点，它也可以不存在或者是一个 DOM 对象；vnode 表示执行 _render 后返回的 VNode 的节点；hydrating 表示是否是服务端渲染；removeOnly 是给 transition-group 用的，之后会介绍。")]),e._v(" "),a("p",[e._v("patch 的逻辑看上去相对复杂，因为它有着非常多的分支逻辑，为了方便理解，我们并不会在这里介绍所有的逻辑，仅会针对我们之前的例子分析它的执行逻辑。之后我们对其它场景做源码分析的时候会再次回顾 "),a("code",[e._v("patch")]),e._v(" 方法")]),e._v(" "),a("p",[e._v("先来回顾我们的例子：")]),e._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("var")]),e._v(" app "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("new")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Vue")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  el"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'#app'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[e._v("render")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("function")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[e._v("createElement")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("return")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("createElement")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'div'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n      attrs"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n        id"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'app'")]),e._v("\n      "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("message"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  data"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    message"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'Hello Vue!'")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n")])])]),a("p",[e._v("然后我们在 vm._update 的方法里是这么调用 patch 方法的：")]),e._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// initial render")]),e._v("\nvm"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("$el "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" vm"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("__patch__")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("vm"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("$el"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" vnode"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" hydrating"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("false")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("/* removeOnly */")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n")])])]),a("p",[e._v("结合我们的例子，我们的场景是首次渲染，所以在执行 "),a("code",[e._v("patch")]),e._v(" 函数的时候，传入的 "),a("code",[e._v("vm.$el")]),e._v(" 对应的是例子中 id 为 app 的 DOM 对象，这个也就是我们在 "),a("code",[e._v("index.html")]),e._v(" 模板中写的"),a("code",[e._v('<div id="app">')]),e._v("， "),a("code",[e._v("vm.$el")]),e._v(" 的赋值是在之前 "),a("code",[e._v("mountComponent")]),e._v(" 函数做的，vnode 对应的是调用 "),a("code",[e._v("render")]),e._v(" 函数的返回值，"),a("code",[e._v("hydrating")]),e._v(" 在非服务端渲染情况下为 "),a("code",[e._v("false")]),e._v("，"),a("code",[e._v("removeOnly")]),e._v(" 为 "),a("code",[e._v("false")]),e._v("。")]),e._v(" "),a("p",[e._v("确定了这些入参后，我们回到 patch 函数的执行过程，看几个关键步骤。")]),e._v(" "),a("p",[e._v("由于我们传入的 oldVnode 实际上是一个 DOM container，所以 isRealElement 为 true，接下来又通过 emptyNodeAt 方法把 oldVnode 转换成 VNode 对象，然后再调用 "),a("a",{attrs:{href:"https://github.com/vuejs/vue/blob/2.6/src/core/vdom/patch.js#L125",target:"_blank",rel:"noopener noreferrer"}},[e._v("createElm"),a("OutboundLink")],1),e._v(" 方法，这个方法在这里非常重要，来看一下它的实现：")]),e._v(" "),a("p",[e._v("createElm 的作用是通过虚拟节点创建真实的 DOM 并插入到它的父节点中。 我们来看一下它的一些关键逻辑，createComponent 方法目的是尝试创建子组件，这个逻辑在之后组件的章节会详细介绍，在当前这个 case 下它的返回值为 false；接下来判断 vnode 是否包含 tag，如果包含，先简单对 tag 的合法性在非生产环境下做校验，看是否是一个合法标签；然后再去调用平台 DOM 的操作去创建一个占位符元素。")])])}),[],!1,null,null,null);t.default=s.exports}}]);