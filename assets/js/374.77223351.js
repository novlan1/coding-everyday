(window.webpackJsonp=window.webpackJsonp||[]).push([[374],{647:function(o,e,n){"use strict";n.r(e);var a=n(14),l=Object(a.a)({},(function(){var o=this,e=o._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":o.$parent.slotKey}},[e("p",[o._v("首先我们先来看 Go 可执行程序项目的典型结构布局。")]),o._v(" "),e("p",[o._v("可执行程序项目是以构建可执行程序为目的的项目，Go 社区针对这类 Go 项目所形成的典型结构布局是这样的：")]),o._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[o._v("$tree -F exe-layout \nexe-layout\n├── cmd/\n│   ├── app1/\n│   │   └── main.go\n│   └── app2/\n│       └── main.go\n├── go.mod\n├── go.sum\n├── internal/\n│   ├── pkga/\n│   │   └── pkg_a.go\n│   └── pkgb/\n│       └── pkg_b.go\n├── pkg1/\n│   └── pkg1.go\n├── pkg2/\n│   └── pkg2.go\n└── vendor/\n")])])]),e("p",[o._v("这样的一个 Go 项目典型布局就是“脱胎”于 Go 创世项目的最新结构布局，我现在跟你解释一下这里面的几个要点。")]),o._v(" "),e("p",[o._v("我们从上往下按顺序来，先来看 cmd 目录。cmd 目录就是存放项目要编译构建的可执行文件对应的 main 包的源文件。如果你的项目中有多个可执行文件需要构建，每个可执行文件的 main 包单独放在一个子目录中，比如图中的 app1、app2，cmd 目录下的各 app 的 main 包将整个项目的依赖连接在一起。")]),o._v(" "),e("p",[o._v("而且通常来说，main 包应该很简洁。我们在 main 包中会做一些命令行参数解析、资源初始化、日志设施初始化、数据库连接初始化等工作，之后就会将程序的执行权限交给更高级的执行控制对象。另外，也有一些 Go 项目将 cmd 这个名字改为 app 或其他名字，但它的功能其实并没有变。")]),o._v(" "),e("p",[o._v("接着我们来看 pkgN 目录，这是一个存放项目自身要使用、同样也是可执行文件对应 main 包所要依赖的库文件，同时这些目录下的包还可以被外部项目引用。")]),o._v(" "),e("p",[o._v("然后是 go.mod 和 go.sum ，它们是 Go 语言包依赖管理使用的配置文件。我们前面说过，Go 1.11 版本引入了 Go Module 构建机制，这里我建议你所有新项目都基于 Go Module 来进行包依赖管理，因为这是目前 Go 官方推荐的标准构建模式。")]),o._v(" "),e("p",[o._v("对于还没有使用 Go Module 进行包依赖管理的遗留项目，比如之前采用 dep、glide 等作为包依赖管理工具的，建议尽快迁移到 Go Module 模式。Go 命令支持直接将 dep 的 Gopkg.toml/Gopkg.lock 或 glide 的 glide.yaml/glide.lock 转换为 go.mod。")]),o._v(" "),e("p",[o._v("最后我们再来看看 vendor 目录。vendor 是 Go 1.5 版本引入的用于在项目本地缓存特定版本依赖包的机制，在 Go Modules 机制引入前，基于 vendor 可以实现可重现构建，保证基于同一源码构建出的可执行程序是等价的。")]),o._v(" "),e("p",[o._v("不过呢，我们这里将 vendor 目录视为一个可选目录。原因在于，Go Module 本身就支持可再现构建，而无需使用 vendor。 当然 Go Module 机制也保留了 vendor 目录（通过 go mod vendor 可以生成 vendor 下的依赖包，通过 go build -mod=vendor 可以实现基于 vendor 的构建）。一般我们仅保留项目根目录下的 vendor 目录，否则会造成不必要的依赖选择的复杂性。")]),o._v(" "),e("p",[o._v("当然了，有些开发者喜欢借助一些第三方的构建工具辅助构建，比如：make、bazel 等。你可以将这类外部辅助构建工具涉及的诸多脚本文件（比如 Makefile）放置在项目的顶层目录下，就像 Go 创世项目中的 all.bash 那样。")]),o._v(" "),e("p",[o._v("另外，这里只要说明一下的是，Go 1.11 引入的 module 是一组同属于一个版本管理单元的包的集合。并且 Go 支持在一个项目 / 仓库中存在多个 module，但这种管理方式可能要比一定比例的代码重复引入更多的复杂性。 因此，如果项目结构中存在版本管理的“分歧”，比如：app1 和 app2 的发布版本并不总是同步的，那么我建议你将项目拆分为多个项目（仓库），每个项目单独作为一个 module 进行单独的版本管理和演进。")]),o._v(" "),e("p",[o._v("当然如果你非要在一个代码仓库中存放多个 module，那么新版 Go 命令也提供了很好的支持。比如下面代码仓库 multi-modules 下面有三个 module：mainmodule、module1 和 module2：")]),o._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[o._v("$tree multi-modules\nmulti-modules\n├── go.mod // mainmodule\n├── module1\n│   └── go.mod // module1\n└── module2\n    └── go.mod // module2\n")])])]),e("p",[o._v("我们可以通过 git tag 名字来区分不同 module 的版本。其中 vX.Y.Z 形式的 tag 名字用于代码仓库下的 mainmodule；而 module1/vX.Y.Z 形式的 tag 名字用于指示 module1 的版本；同理，module2/vX.Y.Z 形式的 tag 名字用于指示 module2 版本。")]),o._v(" "),e("p",[o._v("如果 Go 可执行程序项目有一个且只有一个可执行程序要构建，那就比较好办了，我们可以将上面项目布局进行简化：")]),o._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[o._v("$tree -F -L 1 single-exe-layout\nsingle-exe-layout\n├── go.mod\n├── internal/\n├── main.go\n├── pkg1/\n├── pkg2/\n└── vendor/\n")])])]),e("p",[o._v("你可以看到，我们删除了 cmd 目录，将唯一的可执行程序的 main 包就放置在项目根目录下，而其他布局元素的功用不变。")]),o._v(" "),e("p",[o._v("好了到这里，我们已经了解了 Go 可执行程序项目的典型布局，现在我们再来看看 "),e("strong",[o._v("Go 库项目的典型结构布局是怎样的")]),o._v("。")]),o._v(" "),e("p",[o._v("Go 库项目仅对外暴露 Go 包，这类项目的典型布局形式是这样的：")]),o._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[o._v("$tree -F lib-layout \nlib-layout\n├── go.mod\n├── internal/\n│   ├── pkga/\n│   │   └── pkg_a.go\n│   └── pkgb/\n│       └── pkg_b.go\n├── pkg1/\n│   └── pkg1.go\n└── pkg2/\n    └── pkg2.go\n")])])]),e("p",[o._v("我们看到，库类型项目相比于 Go 可执行程序项目的布局要简单一些。因为这类项目不需要构建可执行程序，所以去除了 cmd 目录。")]),o._v(" "),e("p",[o._v("而且，在这里，vendor 也不再是可选目录了。对于库类型项目而言，我们并不推荐在项目中放置 vendor 目录去缓存库自身的第三方依赖，库项目仅通过 go.mod 文件明确表述出该项目依赖的 module 或包以及版本要求就可以了。")]),o._v(" "),e("p",[o._v("Go 库项目的初衷是为了对外部（开源或组织内部公开）暴露 API，对于仅限项目内部使用而不想暴露到外部的包，可以放在项目顶层的 internal 目录下面。当然 internal 也可以有多个并存在于项目结构中的任一目录层级中，关键是项目结构设计人员要明确各级 internal 包的应用层次和范围。")]),o._v(" "),e("p",[o._v("对于有一个且仅有一个包的 Go 库项目来说，我们也可以将上面的布局做进一步简化，简化的布局如下所示：")]),o._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[o._v("$tree -L 1 -F single-pkg-lib-layout\nsingle-pkg-lib-layout\n├── feature1.go\n├── feature2.go\n├── go.mod\n└── internal/\n")])])]),e("p",[o._v("简化后，我们将这唯一包的所有源文件放置在项目的顶层目录下（比如上面的 feature1.go 和 feature2.go），其他布局元素位置和功用不变。")]),o._v(" "),e("h3",{attrs:{id:"注意早期-go-可执行程序项目的典型布局"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#注意早期-go-可执行程序项目的典型布局"}},[o._v("#")]),o._v(" 注意早期 Go 可执行程序项目的典型布局")]),o._v(" "),e("p",[o._v("很多早期接纳 Go 语言的开发者所建立的 Go 可执行程序项目，深受 Go 创世项目 1.4 版本之前的布局影响，这些项目将所有可暴露到外面的 Go 包聚合在 pkg 目录下，就像前面 Go 1.3 版本中的布局那样，它们的典型布局结构是这样的：")]),o._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[o._v("$tree -L 3 -F early-project-layout\nearly-project-layout\n└── exe-layout/\n    ├── cmd/\n    │   ├── app1/\n    │   └── app2/\n    ├── go.mod\n    ├── internal/\n    │   ├── pkga/\n    │   └── pkgb/\n    ├── pkg/\n    │   ├── pkg1/\n    │   └── pkg2/\n    └── vendor/\n")])])]),e("p",[o._v("我们看到，原本放在项目顶层目录下的 pkg1 和 pkg2 公共包被统一聚合到 pkg 目录下了。而且，这种早期 Go 可执行程序项目的典型布局在 Go 社区内部也不乏受众，很多新建的 Go 项目依然采用这样的项目布局。")]),o._v(" "),e("p",[o._v("所以，当你看到这样的布局也不要奇怪，并且在我的讲解后，你应该就明确在这样的布局下 pkg 目录所起到的“聚类”的作用了。不过，在这里还是建议你在创建新的 Go 项目时，优先采用前面的标准项目布局。")]),o._v(" "),e("h3",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[o._v("#")]),o._v(" 总结")]),o._v(" "),e("p",[o._v("首先，对于以生产可执行程序为目的的 Go 项目，它的典型项目结构分为五部分：")]),o._v(" "),e("ul",[e("li",[e("p",[o._v("放在项目顶层的 Go Module 相关文件，包括 go.mod 和 go.sum；")])]),o._v(" "),e("li",[e("p",[o._v("cmd 目录：存放项目要编译构建的可执行文件所对应的 main 包的源码文件；")])]),o._v(" "),e("li",[e("p",[o._v("项目包目录：每个项目下的非 main 包都“平铺”在项目的根目录下，每个目录对应一个 Go 包；")])]),o._v(" "),e("li",[e("p",[o._v("internal 目录：存放仅项目内部引用的 Go 包，这些包无法被项目之外引用；")])]),o._v(" "),e("li",[e("p",[o._v("vendor 目录：这是一个可选目录，为了兼容 Go 1.5 引入的 vendor 构建模式而存在的。这个目录下的内容均由 Go 命令自动维护，不需要开发者手工干预。")])])]),o._v(" "),e("p",[o._v("第二，对于以生产可复用库为目的的 Go 项目，它的典型结构则要简单许多，我们可以直接理解为在 Go 可执行程序项目的基础上去掉 cmd 目录和 vendor 目录。")]),o._v(" "),e("p",[o._v("最后，早期接纳 Go 语言的开发者所建立的项目的布局深受 Go 创世项目 1.4 版本之前布局的影响，将可导出的公共包放入单独的 pkg 目录下，我们了解这种情况即可。对于新建 Go 项目，我依旧建议你采用前面介绍的标准布局形式。")])])}),[],!1,null,null,null);e.default=l.exports}}]);