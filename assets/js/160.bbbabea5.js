(window.webpackJsonp=window.webpackJsonp||[]).push([[160],{761:function(t,o,s){"use strict";s.r(o);var a=s(42),_=Object(a.a)({},(function(){var t=this,o=t.$createElement,s=t._self._c||o;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("ul",[s("li",[s("a",{attrs:{href:"#1-react-hooks"}},[t._v("1. React Hooks")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#11-hook-%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99"}},[t._v("1.1. Hook 使用规则")])]),t._v(" "),s("li",[s("a",{attrs:{href:"#12-hook-%E5%A6%82%E4%BD%95%E6%8A%8A%E8%B0%83%E7%94%A8%E5%92%8C%E7%BB%84%E4%BB%B6%E8%81%94%E7%B3%BB%E8%B5%B7%E6%9D%A5%E7%9A%84"}},[t._v("1.2. Hook 如何把调用和组件联系起来的？")])]),t._v(" "),s("li",[s("a",{attrs:{href:"#13-%E7%B1%BB%E7%BB%84%E4%BB%B6%E7%9A%84%E4%B8%8D%E8%B6%B3"}},[t._v("1.3. 类组件的不足")])]),t._v(" "),s("li",[s("a",{attrs:{href:"#14-hooks-%E4%BC%98%E5%8A%BF"}},[t._v("1.4. hooks 优势")])])])])]),t._v(" "),s("h2",{attrs:{id:"_1-react-hooks"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-react-hooks"}},[t._v("#")]),t._v(" 1. React Hooks")]),t._v(" "),s("p",[t._v("Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数。Hook 不能在 class 组件中使用")]),t._v(" "),s("h3",{attrs:{id:"_1-1-hook-使用规则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-hook-使用规则"}},[t._v("#")]),t._v(" 1.1. Hook 使用规则")]),t._v(" "),s("ul",[s("li",[t._v("只能在函数最外层调用 Hook。不可在循环、条件判断或者子函数中调用。")]),t._v(" "),s("li",[t._v("只能在 React 的函数组件或自定义的 Hook 中调用 Hook。不要在其他 JavaScript 函数中调用。")])]),t._v(" "),s("p",[t._v("可以使用"),s("code",[t._v("eslint-plugin-react-hooks")]),t._v("来检测，在 Webpack 中添加配置如下：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('  "eslintConfig": {\n    "extends": "react-app",\n    "plugins": [\n      "react-hooks"\n    ],\n    "rules": {\n      "react-hooks/rules-of-hooks":"error"\n    }\n  },\n')])])]),s("h3",{attrs:{id:"_1-2-hook-如何把调用和组件联系起来的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-hook-如何把调用和组件联系起来的"}},[t._v("#")]),t._v(" 1.2. Hook 如何把调用和组件联系起来的？")]),t._v(" "),s("p",[t._v("React 保持对当先渲染中的组件的追踪。多亏了 Hook 规范，我们得知 Hook 只会在 React 组件中被调用（或自定义 Hook —— 同样只会在 React 组件中被调用）。")]),t._v(" "),s("p",[t._v("每个组件内部都有一个「记忆单元格」列表。它们只不过是我们用来存储一些数据的 JavaScript 对象。当你用 useState() 调用一个 Hook 的时候，它会读取当前的单元格（或在首次渲染时将其初始化），然后把指针移动到下一个。这就是多个 useState() 调用会得到各自独立的本地 state 的原因。")]),t._v(" "),s("h3",{attrs:{id:"_1-3-类组件的不足"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-类组件的不足"}},[t._v("#")]),t._v(" 1.3. 类组件的不足")]),t._v(" "),s("ul",[s("li",[t._v("状态逻辑难以复用\n"),s("ul",[s("li",[t._v("缺少复用机制\n"),s("ul",[s("li",[t._v("不方便封装逻辑，使用渲染属性和高阶组件也有缺点")])])]),t._v(" "),s("li",[t._v("渲染属性和高阶组件导致层级冗余\n"),s("ul",[s("li",[t._v("无论是高阶组件还是渲染属性，都相当与在原来的组件之上增加了新的组件层次。尤其是在 Chrome 调试器上会看到为了服用逻辑而添加的狠多组件层级，显得十分臃肿。不仅是调试体验问题、也存在着运行性能的问题")])])])])]),t._v(" "),s("li",[t._v("趋向复杂时难以维护\n"),s("ul",[s("li",[t._v("生命周期函数函数混杂不相干逻辑")]),t._v(" "),s("li",[t._v("相关逻辑代码经常会打散到不同生命周期中")])])]),t._v(" "),s("li",[t._v("this 指向困扰\n"),s("ul",[s("li",[t._v("内联函数需要绑定 this, 否则每次渲染都创建一个箭头函数")]),t._v(" "),s("li",[t._v("类成员函数不能保证 this")])])])]),t._v(" "),s("h3",{attrs:{id:"_1-4-hooks-优势"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-hooks-优势"}},[t._v("#")]),t._v(" 1.4. hooks 优势")]),t._v(" "),s("ul",[s("li",[t._v("函数组件无类实例 this 问题\n"),s("ul",[s("li",[t._v("hooks 是函数组件环境，所有逻辑都在函数内部，没有实例化概念，无复杂的 this 问题")])])]),t._v(" "),s("li",[t._v("自定义 Hook 函数方便复用状态逻辑\n"),s("ul",[s("li",[t._v("hooks 指的是在函数内部调用的特殊函数，我们可以自定义 hooks 函数，在 hooks 函数内部，依旧可以调用 useState 和 useEffect 等 hooks 函数。这样就可以非常高效的将可复用逻辑提取出来")])])]),t._v(" "),s("li",[t._v("副作用的关注点分离\n"),s("ul",[s("li",[t._v("hooks 天生优化了副作用代码逻辑\n"),s("ul",[s("li",[t._v("每个 useEffect 来实现一个逻辑，不同逻辑写在不同的 useEffect 中，比冗在同一生命周期中好很多")]),t._v(" "),s("li",[t._v("以前副作用大都是写在生命函数周期中")])])]),t._v(" "),s("li",[t._v("副作用：\n"),s("ul",[s("li",[t._v("发送网络请求")]),t._v(" "),s("li",[t._v("访问原始 DOM 元素")]),t._v(" "),s("li",[t._v("访问本地存储")]),t._v(" "),s("li",[t._v("绑定解绑事件")])])])])])])])}),[],!1,null,null,null);o.default=_.exports}}]);