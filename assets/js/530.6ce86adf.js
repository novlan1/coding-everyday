(window.webpackJsonp=window.webpackJsonp||[]).push([[530],{804:function(_,v,t){"use strict";t.r(v);var s=t(14),a=Object(s.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h2",{attrs:{id:"_1-笔记"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-笔记"}},[_._v("#")]),_._v(" 1. 笔记")]),_._v(" "),v("h3",{attrs:{id:"_1-1-开篇词-怎样成长为优秀的软件架构师"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-开篇词-怎样成长为优秀的软件架构师"}},[_._v("#")]),_._v(" 1.1. 开篇词 | 怎样成长为优秀的软件架构师？")]),_._v(" "),v("p",[_._v("让我们来想象一下，如果把信息世界看成一座大厦，把程序员看成这个世界的建筑师，那么，现在的你在负责什么样的工作呢？")]),_._v(" "),v("p",[_._v("当我们"),v("strong",[_._v("把程序员类比成建筑师时")]),_._v("，按照能力水平来分，我觉得大体可以分为三个层次："),v("strong",[_._v("搬砖师、工程师、架构师")]),_._v("。")]),_._v(" "),v("p",[v("strong",[_._v("软件搬砖师")]),_._v("之名对应到建筑行业的建筑工人，他们的编程能力和业务基本上停留在堆叠代码，按照要求去实现功能需求的层面。")]),_._v(" "),v("p",[_._v("只要能让程序跑起来，能正确地实现业务逻辑，就可以称为“会编程”的人。有时候，我们也会看见程序员自称为“码农”“搬砖的”，虽然二者的工种不同，但从基础工作的相似度来说，确实有可类比的成分。")]),_._v(" "),v("p",[_._v("然而，"),v("strong",[_._v("只让代码跑起来是不够的。这个世界是不断变化的")]),_._v("，作为程序员，"),v("strong",[_._v("我们更多的时间是用来维护代码：增加新的需求，对已有的功能进行调整，修改之前代码遗留下来的问题，优化性能等等")]),_._v("。")]),_._v(" "),v("p",[_._v("这是因为一个软件诞生之后，后续就是需要花费大量的代价去维护它，演进它。一个人是完全维护不过来的，需要更多的人，很多的团队一起协作。如果面临了员工离职、岗位调整等情况，还会导致软件代码在不同人之间流转。")]),_._v(" "),v("p",[_._v("所以，一些有追求的程序员会关注代码的质量。代码质量的评判可以有这样一些基本维度："),v("strong",[_._v("可阅读性（方便代码流转）、可扩展性 / 可维护性（方便修改功能，添加新功能）、可测试性（质量管理）、可复用性（简化后续功能开发的难度）")]),_._v("。")]),_._v(" "),v("p",[_._v("这一类致力于不断提升软件代码的工程质量的程序员，我们可以称他们为"),v("strong",[_._v("软件工程师")]),_._v("。")]),_._v(" "),v("p",[_._v("工程师不会简单把写代码看作一门工作，把任务交代过去就完事。他们会有“洁癖”，"),v("strong",[_._v("代码在他们眼里是一种艺术，是自己生命的一部分")]),_._v("。")]),_._v(" "),v("p",[_._v("他们会把写出来的代码改了又改，直到让自己满意为止。阅读和维护软件工程师写的代码会有一种赏心悦目的感觉。")]),_._v(" "),v("p",[_._v("光靠把控软件工程师的水平，依赖他们自觉保障的工程质量，是远远不够的。软件工程是一项"),v("strong",[_._v("非常复杂的系统工程")]),_._v("，它需要依赖一个能够掌控整个工程全局的团队，来规划和引导整个系统的演变过程。这个团队就是架构师团队。")]),_._v(" "),v("p",[v("strong",[_._v("软件架构师的职责，并不单单是我们通常理解的，对软件系统进行边界划分和模块规格的定义")]),_._v("。")]),_._v(" "),v("p",[_._v("从根本目标来说，软件架构师要对软件工程的执行结果负责，这包括：按时按质进行软件的迭代和发布、敏捷地响应需求变更、防范软件质量风险（避免发生软件质量事故）、降低迭代维护成本。")]),_._v(" "),v("p",[v("strong",[_._v("那怎么才能成长为优秀的软件架构师？软件架构师和软件工程师最根本的差别又在哪里？我认为关键在于四个字：掌控全局。")])]),_._v(" "),v("p",[_._v("掌控全局，就是对系统的全貌了然于胸。从传统的建筑工程来说，建筑架构师并不单单要会画建筑图纸，而是要对地基构建、土质、材料、建筑工艺等等所有有可能影响建筑质量的因素都要了然于胸。")]),_._v(" "),v("p",[_._v("掌控全局，并不是无所不能，不是成为全栈。怎么做到掌控全局？核心在于对知识脉络的体系化梳理。这是架构能力构建和全面提升的关键。这种方法不单单是在软件工程中适用。")]),_._v(" "),v("p",[_._v("掌控全局的前提是：在自己心中去重新构建出整个世界。在这个过程中，你不需要一上来沉浸在某个技术的实现细节（除非它影响了你对这个世界构建过程的理解），但是你知道整个世界的脉络，知道整个世界的骨架。")]),_._v(" "),v("p",[_._v("这个时候，你对这个世界的感觉是完全不同的，因为，"),v("strong",[_._v("你已经成为了这个世界的构建者")]),_._v("。")]),_._v(" "),v("p",[_._v("而架构的本质，不也正是构建和创造么？")]),_._v(" "),v("p",[_._v("重构类图书主要讲怎么把坏代码一步步改进到好代码。我认为这是最实用的一类。"),v("strong",[_._v("但在没有优秀架构师主导的情况下，大部分公司的代码不可避免地越变越坏，直到不堪重负最后不得不重写")]),_._v("。实际上，"),v("strong",[_._v("一个模块最初的地基是最重要的，基本决定了这座大厦能够撑多久")]),_._v("，而重构更多侧重于大厦建成之后，在服务于人的前提下怎么去修修补补，延长生命。")]),_._v(" "),v("h3",{attrs:{id:"_1-2-架构设计的宏观视角"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-架构设计的宏观视角"}},[_._v("#")]),_._v(" 1.2. 架构设计的宏观视角")]),_._v(" "),v("p",[_._v("整体来说，对于一个客户端应用程序来说，其完整的架构体系大体如下：")]),_._v(" "),v("img",{attrs:{src:"https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2024/2/own_mike_7063cdd060d78ace56.png",width:"500"}}),_._v(" "),v("p",[_._v("对于一个服务端应用程序来说，其完整的架构体系大体如下：")]),_._v(" "),v("img",{attrs:{src:"https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2024/2/own_mike_b5f0a23c0ae2c9257c.png",width:"500"}}),_._v(" "),v("p",[v("strong",[_._v("如果我们把写代码的能力比作武功招式，那么架构能力就好比内功。内功修炼好了，武功招式的运用才能得心应手。")])]),_._v(" "),v("p",[_._v("而架构能力的提升，本质上是对你的知识脉络（全身经络）的反复梳理与融会贯通的过程。具备架构思维并不难，而且极有必要。不管今天的你是不是团队里的一位架构师，对任何一位程序员来说，具备架构思维将会成为让你脱颖而出的关键。")]),_._v(" "),v("p",[_._v("这就像你没有从事云计算行业，但是你仍然需要理解云计算的本质，需要驾驭云计算。你也不必去做出一个浏览器，但是你"),v("strong",[_._v("需要理解它们的思考方式")]),_._v("，因为你在深度依赖于它们。")]),_._v(" "),v("h3",{attrs:{id:"_1-3-大厦基石-无生有-有生万物"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-大厦基石-无生有-有生万物"}},[_._v("#")]),_._v(" 1.3. 大厦基石：无生有，有生万物")]),_._v(" "),v("p",[v("strong",[_._v("我们应该如何去分析架构设计中涉及的每一个零部件。换一句话说，当我们设计或分析一个零部件时，我们会关心哪些问题")]),_._v("。")]),_._v(" "),v("p",[v("strong",[_._v("第一个问题，是需求")]),_._v("。这个零部件的作用是什么？它能被用来做哪些事情？（某种意义上来说更重要的是）它不会被用来做哪些事情？")]),_._v(" "),v("p",[_._v("你可能会说，呀，这个问题很简单，既然我设计了这个零部件，自然知道它是用来干嘛的。但实质上这里真正艰难的是“为什么”：为何这个零件被设计成用来干这些事情的，而不是多干一点事情，或者为什么不是少干某些事情？")]),_._v(" "),v("p",[v("strong",[_._v("第二个问题，是规格")]),_._v("。这个零部件接口是什么样的？它如何与其他零件连接在一起的？")]),_._v(" "),v("p",[_._v("规格是零部件的连接需求的抽象。符合规格的零部件可以有非常多种可能的实现方案，但是，一旦规格中某个条件不能满足了，它就无法正常完成与其他零件的连接，以达到预期的需求目标。")]),_._v(" "),v("p",[_._v("规格的约束条件会非常多样化，可能是外观（比如形状和颜色），可能是交互方式（比如用键盘、鼠标，或者语音和触摸屏），也可能是质量（比如硬度、耐热性等等）。")]),_._v(" "),v("p",[_._v("架构的第一步是需求分析。"),v("strong",[_._v("从需求分析角度来说，关键要抓住需求的稳定点和变化点。需求的稳定点，往往是系统的核心价值点、核心能力；而需求的变化点，则往往需要相应去做开放性设计、扩展性设计。")])]),_._v(" "),v("h3",{attrs:{id:"_1-4-编程语言的进化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-编程语言的进化"}},[_._v("#")]),_._v(" 1.4. 编程语言的进化")]),_._v(" "),v("p",[_._v("从架构设计角度来看，编程语言的选择对架构的影响是什么？")]),_._v(" "),v("p",[_._v("站在唯技术论的角度，业务架构与语言无关，影响的只是模块规格的描述语法。但语言的选择在实践中对业务架构决策的影响仍然极其关键。")]),_._v(" "),v("p",[v("strong",[_._v("原因之一是开发效率")]),_._v("。"),v("strong",[_._v("抛开语言本身的开发效率差异不谈，不同语言会有不同的社区资源")]),_._v("。语言长期以来的演进，社区所沉淀下来的框架和基础库，还有你所在的企业长期发展形成的框架和基础库，都会导致巨大的开发效率上的差异。")]),_._v(" "),v("p",[v("strong",[_._v("原因之二是后期维护")]),_._v("。语言的历史通常都很悠久，很难实质性地消亡。但是"),v("strong",[_._v("语言的确有它的生命周期，语言也会走向衰落")]),_._v("。"),v("strong",[_._v("选择公司现在更熟悉的语言，还是选择一个面向未来更优的语言")]),_._v("，对架构师来说也是一个两难选择。")]),_._v(" "),v("h3",{attrs:{id:"_1-5-思考题解读-如何实现可自我迭代的计算机"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-思考题解读-如何实现可自我迭代的计算机"}},[_._v("#")]),_._v(" 1.5. 思考题解读：如何实现可自我迭代的计算机")]),_._v(" "),v("p",[_._v("做架构，第一件事情要学会做需求分析。")]),_._v(" "),v("p",[_._v("需求分析的重要性怎么形容都不过分。准确的需求分析是做出良好架构设计的基础。我个人认为，架构师在整个架构的过程中，至少应该花费三分之一的精力在需求分析上。")]),_._v(" "),v("p",[_._v("这也是为什么很多非常优秀的架构师换到一个新领域后，一上来并不能保证一定能够设计出良好的架构，而是往往需要经过几次迭代才趋于稳定，原因就在于："),v("strong",[_._v("领域的需求理解是需要一个过程的，对客户需求的理解不可能一蹴而就。")])]),_._v(" "),v("p",[_._v("所以，一个优秀的架构师除了需要“在心里对需求反复推敲”的严谨态度外，对客户反馈的尊重之心也至关重要。只有心里装着客户，才能理解好需求，做好架构。")]),_._v(" "),v("p",[v("strong",[_._v("需求分析的重要性在于，它本身就是一个需求从模糊到细化并最终清晰定义的过程。")])]),_._v(" "),v("h3",{attrs:{id:"_1-6-操作系统进场"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-6-操作系统进场"}},[_._v("#")]),_._v(" 1.6. 操作系统进场")]),_._v(" "),v("p",[_._v("从客户需求来说，操作系统的核心价值在于：")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("实现软件治理，让多个软件和谐共处")]),_._v("；")]),_._v(" "),v("li",[v("strong",[_._v("提供基础的编程接口，降低软件开发难度")]),_._v("。")])]),_._v(" "),v("p",[_._v("从商业价值来说，操作系统是刚性需求，核心的流量入口，兵家必争之地。所以，围绕它的核心能力，操作系统必然会不断演化出新的形态。")]),_._v(" "),v("p",[_._v("我们把"),v("strong",[_._v("引入了“账号 - 支付 - 应用市场”商业闭环的收税模式")]),_._v("的操作系统，称为现代操作系统。")]),_._v(" "),v("h3",{attrs:{id:"_1-7-进程内协同-同步、互斥与通讯"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-7-进程内协同-同步、互斥与通讯"}},[_._v("#")]),_._v(" 1.7. 进程内协同：同步、互斥与通讯")]),_._v(" "),v("p",[_._v("锁的最大问题在于不容易控制。锁 Lock 了但是忘记 Unlock 后是灾难性的，因为相当于服务器挂了，所有和该锁相关的代码都不能被执行。")]),_._v(" "),v("div",{staticClass:"language-c extra-class"},[v("pre",{pre:!0,attrs:{class:"language-c"}},[v("code",[_._v("mutex"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[_._v("Lock")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),_._v("\ntry "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("{")]),_._v("\n    "),v("span",{pre:!0,attrs:{class:"token function"}},[_._v("doSth")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),_._v("\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("}")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token function"}},[_._v("catch")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),_._v("e Exception"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("{")]),_._v("\n    mutex"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[_._v("Unlock")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),_._v("\n    throw e\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("}")]),_._v("\nmutex"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[_._v("Unlock")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),_._v("\n")])])]),v("p",[_._v("锁不容易控制的另一个表现是锁粒度的问题。例如上面 doSth 函数里面如果调用了网络 IO 请求，而网络 IO 请求在少数特殊情况下可能会出现慢请求，要好几秒才返回。那么这几秒对服务器来说就好像挂了，无法处理请求。")]),_._v(" "),v("p",[_._v("对服务器来说这是极为致命的。对后端程序员来说，有一句箴言要牢记：")]),_._v(" "),v("blockquote",[v("p",[_._v("不要在锁里面执行费时操作。")])]),_._v(" "),v("p",[_._v("读写锁的特性就是：")]),_._v(" "),v("ul",[v("li",[v("p",[v("strong",[_._v("读操作不阻止读操作，阻止写操作；")])])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("写操作阻止一切，不管读操作还是写操作。")])])])]),_._v(" "),v("h3",{attrs:{id:"_1-8-如何判断架构设计的优劣"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-8-如何判断架构设计的优劣"}},[_._v("#")]),_._v(" 1.8. 如何判断架构设计的优劣？")]),_._v(" "),v("h4",{attrs:{id:"_1-8-1-架构设计的基本准则"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-8-1-架构设计的基本准则"}},[_._v("#")]),_._v(" 1.8.1. 架构设计的基本准则")]),_._v(" "),v("p",[_._v("架构设计会有它的一些基本准则。比如：")]),_._v(" "),v("ul",[v("li",[_._v("KISS：简单比复杂好；")]),_._v(" "),v("li",[_._v("Modularity：着眼于模块而不是框架；")]),_._v(" "),v("li",[_._v("Testable：保证可测试性；")]),_._v(" "),v("li",[_._v("Orthogonal Decomposition：正交分解。")])]),_._v(" "),v("p",[_._v("KISS  全称是 Keep it Simple, Stupid，用最直白的话说，“简单就是美”。不增加无谓的复杂性。正确理解系统的需求之后才进行设计。要避免过度设计，除非有人为复杂性买单。")]),_._v(" "),v("p",[_._v("KISS 的“简单”，强调的是易实施性。让模块容易实现，实现的时候心智负担低，比复杂的优化更重要。")]),_._v(" "),v("p",[_._v("KISS 的“简单”，也是主张让你的代码，包括接口，符合惯例。接口语义要自然，最好让人一看方法名就知道怎么回事，避免惊异。")]),_._v(" "),v("p",[_._v("Modularity，强调的是模块化。从架构设计角度来说，模块的规格，也就是模块的接口，比模块的实现机制更重要。")]),_._v(" "),v("p",[_._v("我们应着眼于模块而不是框架。框架是易变的。框架是业务流，可复用性相对更低。框架都将经历不断发展演化的过程，逐步得到完善。")]),_._v(" "),v("p",[_._v("所以不让模块为框架买单。模块设计时应忽略框架的存在。认真审视模块的接口，发现其中“过度的（或多余的）” 约束条件，把它提高到足够通用的、普适的场景来看。")]),_._v(" "),v("p",[_._v("Testable，强调的是模块的可测试性。设计应该以可测试性为第一目标。")]),_._v(" "),v("p",[_._v("可测试往往意味着低耦合。一个模块可以很方便地进行测试，那么就可以说它是一个设计优良的模块。模块测试的第一步是环境模拟。模块依赖的模块列表、模块的输入输出，这些是模块测试的需要，也是模块耦合度的表征。")]),_._v(" "),v("p",[_._v("当然，可测试性不单单因为是耦合的需要。测试让我们能够发现模块构架调整的潜在问题。通常模块在架构调整期（代码重构）最容易引入 Bug。 只有在模块开发过程中我们就不断积累典型的测试数据，以案例的形式固化所有已知 Bug，才可能在架构调整等最容易引发问题的情形下获得最佳的效果。")]),_._v(" "),v("p",[_._v("Orthogonal Decomposition，中文的意思是 “正交分解”。架构就是不断地对系统进行正交分解的过程。")]),_._v(" "),v("p",[_._v("相信大家都听过一个设计原则：“优先考虑组合，而不是继承”。如果我们用正交分解的角度来诠释这句话，它本质上是鼓励我们做乘法而不是做加法。组合是乘法，它是让我们用相互正交、完全没有相关性的模块，组合出我们要的业务场景。而继承是加法，通过叠加能力把一个模块改造成另一个模块。")]),_._v(" "),v("h4",{attrs:{id:"_1-8-2-核心系统的伤害值"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-8-2-核心系统的伤害值"}},[_._v("#")]),_._v(" 1.8.2. 核心系统的伤害值")]),_._v(" "),v("p",[_._v("正交分解，第一件事情就是要分出哪些是核心系统，哪些是周边子系统。核心系统构成了业务的最小功能集，而后通过不断增加新的周边功能，而演变成功能强大的复杂系统。")]),_._v(" "),v("p",[_._v("对于核心系统的变更要额外小心。如果某新功能早期没有规划，后期却被界定为属于核心功能，我们就需要认真评估它对既有架构的破坏性。")]),_._v(" "),v("p",[_._v("至于周边功能，我们核心考虑的是，如何降低添加一个新的周边功能对核心系统的影响？")]),_._v(" "),v("p",[_._v("不论哪一种情况，如果我们不够小心，系统就会由于不断增加功能而变老化，散发出臭味。")]),_._v(" "),v("p",[_._v("为了减少一个功能带来的负面影响，这个功能相关代码首先要做到尽可能内聚。")]),_._v(" "),v("p",[_._v("代码不一定要写到独立的模块（如果代码量不算大的话），但一定要写到独立的文件里面。对于周边系统，这部分独立出来的代码算是它的功能实现代码，不隶属于核心系统。")]),_._v(" "),v("p",[_._v("我们的关注点是某个周边功能对核心系统的影响。为了添加这个功能，它必然要求核心系统添加相关的代码以获得执行的机会。")]),_._v(" "),v("p",[_._v("我们根据经验可以初步判断，核心系统为这个周边功能增加的代码量越少，那么这个功能与核心系统的耦合就越低。那么，是否有可能把一个功能的添加对核心系统的影响降低到零，也就是不改一行代码？")]),_._v(" "),v("p",[_._v("这当然是可能的，只不过这要求核心系统需要提供所谓 “插件机制”。")]),_._v(" "),v("h3",{attrs:{id:"_1-9-少谈点框架-多谈点业务"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-9-少谈点框架-多谈点业务"}},[_._v("#")]),_._v(" 1.9. 少谈点框架，多谈点业务")]),_._v(" "),v("p",[_._v("模块的接口，是架构设计的核心。")]),_._v(" "),v("p",[_._v("接口代表什么？接口代表业务。架构图代表什么？架构图代表框架。")]),_._v(" "),v("p",[_._v("不要让框架绑架业务。")]),_._v(" "),v("p",[_._v("在架构的两侧，一边是用户需求，一边是技术。接口代表用户需求，代表业务。框架代表技术，是我们满足需求的方法。")]),_._v(" "),v("p",[_._v("框架它是重要的。但是不要让框架反客为主，溢出模块边界。在系统迭代的过程中，框架会经受变化，以适应需求的演进过程。")]),_._v(" "),v("p",[_._v("抓住稳定的东西，比追逐变化更重要。")]),_._v(" "),v("p",[_._v("框架，体现的是需求泛化的能力。从架构思维角度上来说，它是通过抽象出需求模板，把多个需求场景中变化的部分抽离出来，形成相对稳定的泛化需求。")]),_._v(" "),v("p",[v("strong",[_._v("每个模块都是一个业务。这里我们说的模块是一种泛指，它包括：函数、类、接口、包、子系统、网络服务程序、桌面程序等等。")])]),_._v(" "),v("h2",{attrs:{id:"_2-后记"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-后记"}},[_._v("#")]),_._v(" 2. 后记")]),_._v(" "),v("p",[_._v("后面实在看不下去了，有兴趣的自己去看吧。延伸的地方挺多的，脱离代码、脱离日常工作有点远了。并不是说这么课不好，恰恰相反，是我层次不够，暂时沉不下来心来看，先记着，后面有空再来看。")])])}),[],!1,null,null,null);v.default=a.exports}}]);