(window.webpackJsonp=window.webpackJsonp||[]).push([[150],{420:function(e,t,_){"use strict";_.r(t);var a=_(14),v=Object(a.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("ul",[t("li",[t("a",{attrs:{href:"#1-fiber"}},[e._v("1. Fiber")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#11-react-15-%E7%9A%84%E9%97%AE%E9%A2%98"}},[e._v("1.1. React 15 的问题")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#12-%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF"}},[e._v("1.2. 解决思路")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#13-react-fiber"}},[e._v("1.3. React Fiber")])])])])]),e._v(" "),t("h2",{attrs:{id:"_1-fiber"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-fiber"}},[e._v("#")]),e._v(" 1. Fiber")]),e._v(" "),t("h3",{attrs:{id:"_1-1-react-15-的问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-react-15-的问题"}},[e._v("#")]),e._v(" 1.1. React 15 的问题")]),e._v(" "),t("p",[e._v("在页面元素很多，且需要频繁刷新的场景下，React 15 会出现掉帧的现象。")]),e._v(" "),t("p",[e._v("其根本原因，是大量的同步计算任务阻塞了浏览器的 UI 渲染。默认情况下，JS 运算、页面布局和页面绘制都是运行在浏览器的主线程当中，他们之间是互斥的关系。如果 JS 运算持续占用主线程，页面就没法得到及时的更新。")]),e._v(" "),t("p",[e._v("当我们调用"),t("code",[e._v("setState")]),e._v("更新页面的时候，React 会遍历应用的所有节点，计算出差异，然后再更新 UI。整个过程是一气呵成，不能被打断的。如果页面元素很多，整个过程占用的时机就可能超过 16 毫秒，就容易出现掉帧的现象。")]),e._v(" "),t("h3",{attrs:{id:"_1-2-解决思路"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-解决思路"}},[e._v("#")]),e._v(" 1.2. 解决思路")]),e._v(" "),t("p",[e._v("解决主线程长时间被 JS 运算占用这一问题的基本思路，是将运算切割为多个步骤，分批完成。也就是说在完成一部分任务之后，将控制权交回给浏览器，让浏览器有时间进行页面的渲染。等浏览器忙完之后，再继续之前未完成的任务。")]),e._v(" "),t("p",[e._v("旧版 React 通过递归的方式进行渲染，使用的是 JS 引擎自身的函数调用栈，它会一直执行到栈空为止。而"),t("code",[e._v("Fiber")]),e._v("实现了自己的组件调用栈，它以"),t("strong",[e._v("链表")]),e._v("的形式遍历组件树，可以灵活的暂停、继续和丢弃执行的任务。实现方式是使用了浏览器的"),t("code",[e._v("requestIdleCallback")]),e._v("这一 API。")]),e._v(" "),t("blockquote",[t("p",[e._v("window.requestIdleCallback()会在浏览器空闲时期依次调用函数，这就可以让开发者在主事件循环中执行后台或低优先级的任务，而且不会对像动画和用户交互这些延迟触发但关键的事件产生影响。函数一般会按先进先调用的顺序执行，除非函数在浏览器调用它之前就到了它的超时时间。")])]),e._v(" "),t("h3",{attrs:{id:"_1-3-react-fiber"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-react-fiber"}},[e._v("#")]),e._v(" 1.3. React Fiber")]),e._v(" "),t("p",[e._v("React 框架内部的运作可以分为 3 层：")]),e._v(" "),t("ul",[t("li",[e._v("Virtual DOM 层，描述页面长什么样。")]),e._v(" "),t("li",[e._v("Reconciler 层，负责调用组件生命周期方法，进行 Diff 运算等。")]),e._v(" "),t("li",[e._v("Renderer 层，根据不同的平台，渲染出相应的页面，比较常见的是 ReactDOM 和 ReactNative。")])]),e._v(" "),t("p",[e._v("这次改动最大的当属 Reconciler 层了，React 团队也给它起了个新的名字，叫"),t("code",[e._v("Fiber Reconciler")]),e._v("。这就引入另一个关键词：Fiber。\nFiber 其实指的是一种数据结构，它可以用一个纯 JS 对象来表示：")]),e._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("const")]),e._v(" fiber "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    stateNode"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("    "),t("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 节点实例")]),e._v("\n    child"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("        "),t("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 子节点")]),e._v("\n    sibling"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("      "),t("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 兄弟节点")]),e._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("return")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("       "),t("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 父节点")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),t("p",[e._v("为了加以区分，以前的 "),t("code",[e._v("Reconciler")]),e._v(" 被命名为"),t("code",[e._v("Stack Reconciler")]),e._v("。"),t("code",[e._v("Stack Reconciler")]),e._v(" 运作的过程是不能被打断的，必须一条道走到黑。")]),e._v(" "),t("p",[e._v("而 "),t("code",[e._v("Fiber Reconciler")]),e._v(" 每执行一段时间，都会将控制权交回给浏览器，可以分段执行。\n为了达到这种效果，就需要有一个调度器 ("),t("code",[e._v("Scheduler")]),e._v(") 来进行任务分配。任务的优先级有六种：")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("synchronous")]),e._v("，与之前的"),t("code",[e._v("Stack Reconciler")]),e._v("操作一样，同步执行")]),e._v(" "),t("li",[t("code",[e._v("task")]),e._v("，在"),t("code",[e._v("next tick")]),e._v("之前执行")]),e._v(" "),t("li",[t("code",[e._v("animation")]),e._v("，下一帧之前执行")]),e._v(" "),t("li",[t("code",[e._v("high")]),e._v("，在不久的将来立即执行")]),e._v(" "),t("li",[t("code",[e._v("low")]),e._v("，稍微延迟执行也没关系")]),e._v(" "),t("li",[t("code",[e._v("offscreen")]),e._v("，下一次"),t("code",[e._v("render")]),e._v("时或"),t("code",[e._v("scroll")]),e._v("时才执行")])]),e._v(" "),t("p",[e._v("优先级高的任务（如键盘输入）可以打断优先级低的任务（如Diff）的执行，从而更快的生效。\nFiber Reconciler 在执行过程中，会分为 2 个阶段。")]),e._v(" "),t("p",[t("img",{attrs:{src:"/imgs/fiber_reconciliation_process.png",alt:"Fiber Reconciler 过程"}})]),e._v(" "),t("ol",[t("li",[e._v("阶段一，生成 Fiber 树，得出需要更新的节点信息。这一步是一个渐进的过程，可以被打断。")]),e._v(" "),t("li",[e._v("阶段二，将需要更新的节点一次过批量更新，这个过程不能被打断。")])]),e._v(" "),t("p",[e._v("本质上，从"),t("code",[e._v("Stack Reconciler")]),e._v("到"),t("code",[e._v("Fiber Reconciler")]),e._v("，源码层面其实就是干了一件递归改循环的事情")])])}),[],!1,null,null,null);t.default=v.exports}}]);