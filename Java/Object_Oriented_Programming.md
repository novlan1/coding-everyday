### 构造方法

1. 实例在创建时通过`new`操作符会调用其对应的构造方法，构造方法用于初始化实例；
2. 没有定义构造方法时，编译器会自动创建一个默认的无参数构造方法；当有指定的构造方法，无论是有参，无参的构造方法，都不会自动添加无参的构造方法；
3. 构造方法的重载：方法名相同，但参数不同的多个方法，调用是会自动更加不同的参数选择相应的方法；



### 重载

1. 方法重载( Overload )是指在同一个类中，多个方法的方法名相同，但各自的参数不同（个数、顺序或类型），与方法的修饰符或返回值没有关系；
2. 重载方法应该完成类似的功能，参考String的indexOf()；
3. 重载方法返回值类型应该相同。


### 继承

如果父类没有默认的构造方法，子类就必须显式调用super()并给出参数以便让编译器定位到父类的一个合适的构造方法。

这里还顺带引出了另一个问题：即子类不会继承任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。


1. Java只允许单继承，所有类最终的根类是Object；
2. protected允许子类访问父类的字段和方法；
3. 子类的构造方法可以通过super()调用父类的构造方法；
4. 可以安全地向上转型为更抽象的类型；
5. 可以强制向下转型，最好借助instanceof判断；
6. 子类和父类的关系是is，has关系不能用继承。


### 多态

override和Overload不同的是：

- 如果方法签名如果不同，就是Overload，Overload方法是一个新方法；
- 如果方法签名相同，并且返回值也相同，就是Override。

方法签名是什么？
方法的名称和参数类型。


- 子类可以覆写父类的方法（Override），覆写在子类中改变了父类方法的行为；
- Java的方法调用总是作用于运行期对象的实际类型，这种行为称为多态；
- final修饰符有多种作用：
  - final修饰的方法可以阻止被覆写；
  - final修饰的class可以阻止被继承；
  - final修饰的field必须在创建对象时初始化，随后不可修改。



### 接口

interface，就是比抽象类还要抽象的纯抽象接口，因为它连实例字段都不能有（但是可以有静态字段，`public static final`）。因为接口定义的所有方法默认都是public abstract的，所以这两个修饰符不需要写出来（写不写效果都一样）。



### 包

在定义class的时候，我们需要在第一行声明这个class属于哪个包。

```
package ming; // 声明包名ming
```

在Java虚拟机执行的时候，JVM只看完整类名，因此，只要包名不同，类就不同。
包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系。

#### 包作用域

包作用域是指一个类允许访问同一个`package`的没有`public`、`private`修饰的`class`，以及没有`public`、`protected`、`private`修饰的字段和方法。


Java编译器最终编译出的.class文件只使用完整类名，因此，在代码中，当编译器遇到一个class名称时：

- 如果是完整类名，就直接根据完整类名查找这个class；
- 如果是简单类名，按下面的顺序依次查找：
  - 查找当前package是否存在这个class；
  - 查找import的包是否包含这个class；
  - 查找java.lang包是否包含这个class。

因此，编写class的时候，编译器会自动帮我们做两个import动作：

1. 默认自动import当前package的其他class；
2. 默认自动import java.lang.*。



### classpath 和 jar

1. JVM通过环境变量`classpath`决定搜索`class`的路径和顺序；
2. 不推荐设置系统环境变量`classpath`，始终建议通过`-cp`命令传入；
3. jar包相当于目录，可以包含很多`.class`文件，方便下载和使用；
4. `MANIFEST.MF`文件可以提供jar包的信息，如`Main-Class`，这样可以直接运行jar包。

