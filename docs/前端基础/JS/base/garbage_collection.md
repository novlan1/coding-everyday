- [1. 垃圾回收与内存泄露和优化](#1-垃圾回收与内存泄露和优化)
  - [1.1. 常规垃圾回收机制](#11-常规垃圾回收机制)
  - [1.2. 简单介绍一下 V8 引擎的垃圾回收机制](#12-简单介绍一下-v8-引擎的垃圾回收机制)
  - [1.3. 内存泄露和优化](#13-内存泄露和优化)
    - [1.3.1. 什么是内存泄露？](#131-什么是内存泄露)
    - [1.3.2. 常见的内存泄露的场景](#132-常见的内存泄露的场景)
    - [1.3.3. 内存泄露优化](#133-内存泄露优化)

## 1. 垃圾回收与内存泄露和优化
### 1.1. 常规垃圾回收机制


现在各大浏览器通常采用的垃圾回收机制有两种方法：标记清除，引用计数。

1. 标记清除

js中最常用的垃圾回收方式就是标记清除。当变量进入环境时，例如，在一个函数中声明一个变量，就将这个变量标记为"进入环境"，从逻辑上讲，永远不能释放进入环境变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为"离开环境"。

```js
function test(){
    var a = 10;    //被标记"进入环境"
    var b = "hello";    //被标记"进入环境"
}

test();    //执行完毕后之后，a和b又被标记"离开环境"，被回收
```
垃圾回收机制在运行的时候会给存储再内存中的所有变量都加上标记（可以是任何标记方式），然后，它会去掉处在环境中的变量及被环境中的变量引用的变量标记（闭包）。而在此之后剩下的带有标记的变量被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后垃圾回收机制到下一个周期运行时，将释放这些变量的内存，回收它们所占用的空间。



2. 引用计数

语言引擎有一张"引用表"，保存了内存里面所有资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放。

如果一个值不再需要了，引用数却不为0，垃圾回收机制无法释放这块内存，从而导致内存泄漏。
```js
const arr = [1,2,3,4];
console.log("hello world");
```
上面的代码中，数组[1,2,3,4]是一个值，会占用内存。变量arr是仅有的对这个值的引用，因此引用次数为1。尽管后面的代码没有用到arr，它是会持续占用内存。

如果增加一行代码，解除arr对[1,2,3,4]引用，这块内存就可以被垃圾回收机制释放了。
```js
let arr = [1,2,3,4];
console.log("hello world");
arr = null;
```
上面代码中，arr重置为null，就解除了对[1，2，3，4]的引用，引用次数变成了0，内存就可以释放出来了。


### 1.2. 简单介绍一下 V8 引擎的垃圾回收机制

v8 的垃圾回收机制基于**分代回收机制**，这个机制又基于**世代假说**，这个假说有两个特点，一是**新生的对象容易早死**，另一个是**不死的对象会活得更久**。基于这个假说，v8 引擎将内存分为了**新生代和老生代**。

**新创建的对象**或者**只经历过一次的垃圾回收**的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。

新生代被分为 From 和 To 两个空间，To 一般是闲置的。当 **From 空间满了的时候**会执行 Scavenge 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。这个算法分为三步：

（1）首先检查 From 空间的**存活对象**，如果对象存活则判断对象是否满足**晋升**到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 To 空间。

（2）如果对象不存活，则释放对象的空间。

（3）最后将 From 空间和 To 空间角色进行交换。

新生代对象晋升到老生代有两个条件：

（1）第一个是判断**对象否已经经过一次 Scavenge 回收**。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。

（2）第二个是 **To 空间的内存使用占比**是否超过限制。当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 `25%`，则对象直接晋升到老生代中。设置 25% 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。

老生代采用了标记清除法和标记压缩法。标记清除法首先会对**内存中存活的对象进行标记**，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的**内存碎片**，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。

由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了**增量标记**的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。


详细资料可以参考： [v8的垃圾回收机制](https://blog.csdn.net/wu_xianqiang/article/details/90736087) [《JavaScript 中的垃圾回收》](https://zhuanlan.zhihu.com/p/23992332)



### 1.3. 内存泄露和优化

#### 1.3.1. 什么是内存泄露？

存泄露是指程序中已分配的**堆内存**由于某种原因未释放或者无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统奔溃等后果。

#### 1.3.2. 常见的内存泄露的场景

- 缓存
- 作用域未释放（闭包）
- 没有必要的全局变量，如函数 `foo` 内部忘记使用 `var` ，或者使用`this`创建的变量，意外创建了全局变量。
- 无效的 DOM 引用
- 定时器未清除
- 事件监听为空白

#### 1.3.3. 内存泄露优化

- 在业务不需要的用到的内部函数，可以重构到函数外，实现解除闭包。
- 避免创建过多的生命周期较长的对象，或者将对象分解成多个子对象。
- 避免过多使用闭包。
- 注意清除定时器和事件监听器。
- nodejs 中使用 stream 或 buffer 来操作大文件，不会受 nodejs 内存限制。



