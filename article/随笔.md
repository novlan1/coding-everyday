
[toc]

近期做需求中有一些感想，在这里记录下。

## 1. 产品究竟是谁的

人人都是产品经理，并不是一句口号，每个人都是用户，即便你是研发、设计、测试，都有无数的时间，和世界上最优秀的产品打交道。最优秀的产品包括你的电脑、手机，和那些最流行的APP。

所以，如果某个产品经理一言堂，那这个产品大概率不会太成功。除非他真的厉害，并且有数据支撑，比如乔布斯这种。产品不是政治，产品是可以讨论的。

如果一些交互设计难以理解，研发都用着费劲，怎么在普通人中推广呢？

另一个问题，研发需要了解并思考产品的逻辑吗？

答案肯定是需要的，产品是有逻辑的，研发可以根据产品的逻辑，判断、预测未来的变化，抽出稳定性更强的代码。

一个工作3年和工作10年的研发的一个区别就在于，对于产品逻辑的理解，大概工作更久的人更容易预测产品未来的变化，会在代码编写、结构设计时就拆分出不变与变化，从而让代码更易维护。但是，如果每次新来一个需求，都从0开始，从不思考，就另当别论了。


## 2. 定制与通用

通用和定制往往是对立的，一个需求如果是定制的，意味着不够通用。

前一阵做了一个国际化的需求，国际化其实就代表通用，本地化代表定制。

但是如果同一类型定制的多了，就可以变为通用需求。本质上一个`string/number/boolean`类型总是可以扩展成`array`的。

比如H5的自动化测试报告处理，和小程序的处理，是可以通用化的。

这给我们一个启示是，要多沉淀东西，做过的那么多需求，比如表单系统、权限系统，这些工作即使一两年内不会重复，但是时间拉长来，总会在职业生涯的某个阶段重新做一次。

还有，我们加班那么多，是不是产品设计、需求提出、技术实现的时候，通用性考虑的就不足呢，所以今天在A上拧一个螺丝，明天在B上拧一个螺丝。

可怕的是，这两个螺丝都是一样的残次品。

通用性在不同的层次上有不同的表现，比如总监可以考虑业务的通用，产品经理考虑产品的通用，开发则考虑代码和系统层面的。

组件化的基础也是通用性，如果一个组件可以被复用，说明它是通用的。

## 3. 字段名

发现一个现象，大家在字段命名的时候比较洒脱。

- 格式比较多样，比如角色Id：`roleId`、`role_id`、`roleid`，子活动Id：`childid`、`child_id`、`childId`。
- 名称也多样，比如手机号：`phone`、`mobile`，头像：`head`、`header`。

大家好像习惯了这种乱七八糟的命名，倘若统一了，反而觉得难受。

在其他地方没得到的自由，终于在命名时得到了。

这种字段命名问题和上面的通用化有些关系，如果不能统一，谈何通用呢，通用化的基础一定是标准化。

为什么大家会在命名时候，这么随意呢？大概率是因为他根本没考虑过下游开发者的感受，比如前端。

下游开发者做起来是很痛苦的，他知道这个协议会包含子活动Id，但是他必须去协议页面查看，才能知道究竟是哪种命名，是`childid`、还是`childId`、还是`child_id`？并且，他在向他的下游或下级页面、组件传递时，需要考虑对方需要的是什么，必须做一层转换。如果他不知道转换或者不想转换，让下游直接修改字段名，那整个项目就更“精彩”了。

意识也是一种能力。能够预见到一些可能带来的问题，并尽量规避掉，也是一种好习惯。



## 4. 代码是资产还是负债

总看到有人说，代码是负债，个人不敢苟同，倘若代码都是负债，你还在这敲锤子啊，岂不是越欠越多，回家睡大觉不是更好？

大部分人之所以认为代码是负债，是因为维护起来费劲，一看代码就头疼，每次改代码都像是上刀山，这能不是负债吗。

或者改别人写的代码，小心翼翼、胆战心惊、如履薄冰，生怕解决一个问题，带来其他问题。

所以，个人认为，质量高的代码是资产，写的像X一样的是负债。

“大处着眼，小处着手”，架构、系统相关可以视为“大处”，代码规范、代码质量可以视为“小处”。

最近看到公共基础库很多很多的魔法字符串，开发没有意识去抽离，维护这样的代码就比较头疼了。

甚至有人说，“单元测试有什么用？“

## 5. 兜底

有一个需求，A类型的奖品不需要展示，B类型的奖品可以展示，后台让前端“兜底”，过滤下这个类型的奖品。

想到这个只是产品的上层逻辑，是极容易变化的，今天屏蔽A、明天屏蔽B，后天可能又要放开A、B。

兜底应该是对边界的兼容，比如：

- 多重`if else`中最后的`else`
- 对空值给默认值
- 对解析失败的捕获
- 考虑对不同机型、不同环境的兼容性

像这种产品上的逻辑怎么会是兜底呢？这种过滤其实是数据层面的处理，越在上游处理越简单，因为用数据的地方总是无法控制的。

这其实反映出另一个问题，前后台责任不明确，这次你帮我多处理一下，下次我帮你多处理一下。本来后台该做的事，放到前端来做，下一次，本来前端该兼容的，让后台来做。

前端应该始终兼容空值边界，比如`a.b`，当`a`不存在时候的取值异常。组件、页面总是可能复用的，如果下个`prop`或者`cgi`没传，就要付出额外的时间成本处理错误。

此外，处理数据的逻辑应该放在一起，如果这里增加一点字段、那里改变一下结构，又没有类型提示的话，后期维护起来很难受。

## 6. 兼容

上面提到了兼容，其实兼容有两种：

>向前兼容(`forward compatibility`) = 向上兼容(`upward compatibility`)，也就是向未来兼容，即现在设计的软件要考虑未来还能不能用。
向后兼容(`backward compatibility`) = 向下兼容(`downward compatibility`)，也就是向过去兼容，即现在设计的软件要考虑旧版本的数据还能不能用。

一般说的兼容指的是向后兼容。在框架、基础库升级的过程中，如何实现向后兼容、平稳过渡呢？

通常是设置一个过渡版本，比如`v1`版本的旧API，在`v2`版本时候同时提供新老两种写法，并标明旧APi即将废弃，然后在`v3`版本正式废弃掉旧API。

如果不提供过渡版本，一般会导致开发者不敢升级，比如`vue2`和`vue3`就没有做到平滑过度，导致现在很多项目都是`vue2`。

## 7. 变化

代码维护、迭代过程中最重要的事情之一就是控制变化，应该始终将变化的部分做到可控。

其实现代社会就很符合这个规范，电网、能源、航空、铁路等，这些核心产业都被国家握在手里，其他一些小打小闹的产业，比如餐饮、互联网等，随私企去折腾。

对于大型项目，核心模块，比如基础UI组件库、网络框架、核心逻辑，都应该以一种稳定的形式存在，比如npm包、基础库，不能今天改、明天又改。

为什么函数粒度要细呢，也就是常说的一个函数只完成一个功能？其实本质也是控制了变化，如果一个函数同时完成多个功能，那么改动的可能性就更高，就更容易出错。

稳定性是我们一直追求的目标，一般来说，我们更喜欢发挥稳定的球员，而不是“神经刀”。

代码也是一样，控制变化，其实就是保持稳定性。

## 8. 写文章

写文章会耽误工作吗？就个人经验来说，写文章不但不会影响工作，反而会提升效率。

因为写文章一定是因为有自己的思考才写，不论是解决了问题、还是总结了方法，都是有或多或少的思考，大脑一定是活跃的。

没写文章的时候，看似工作时间投入更多，其实脑子已经不转了，没有自己的理解，没有总结思考，工作效率其实非常低。

这就好像，那些成绩好的同学其他方面也有特长，比如体育、文艺，反而是那些成绩差的才干啥啥不行。

为什么会这样呢？因为思考这个东西是相通的，好多东西底层是一样的，会了一样就可以触类旁通、举一反三。

