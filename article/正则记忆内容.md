## 1. 案例


### 1.1. 密码强度校验

>至少有一个大写字母。至少有一个小写字母。至少有一个数字。至少有 8 个字符。

```js
reg = /(?=.*?[0-9])(?=.*?[a-z])(?=.*?[A-Z])^.{8,}$/

reg.test('Password1')
// true

reg.test('Password')
// false

reg.test('password1')
// false

reg.test('123123123')
// false
```

### 1.2. 复杂一点的密码校验

>密码长度6-12位，由数字、小写字符和大写字母组成，但必须至少包括2种字符。

#### 1.2.1. 第1种解法

可以把原题变成下列几种情况之一：

- 同时包含数字和小写字母
- 同时包含数字和大写字母
- 同时包含小写字母和大写字母
- 同时包含数字、小写字母和大写字母

以上的4种情况是或的关系（实际上，可以不用第4条）。


```js
var reg = /((?=.*[0-9])(?=.*[a-z])|(?=.*[0-9])(?=.*[A-Z])|(?=.*[a-z])(?=.*[A-Z]))^[0-9A-Za-z]{6,12}$/;
console.log( reg.test("1234567") ); // false 全是数字
console.log( reg.test("abcdef") ); // false 全是小写字母
console.log( reg.test("ABCDEFGH") ); // false 全是大写字母
console.log( reg.test("ab23C") ); // false 不足6位
console.log( reg.test("ABCDEF234") ); // true 大写字母和数字
console.log( reg.test("abcdEF234") ); // true 三者都有
```


#### 1.2.2. 另外一种解法

“至少包含两种字符”的意思就是说，不能全部都是数字，也不能全部都是小写字母，也不能全部都是大写字母。

那么要求“不能全部都是数字”，怎么做呢？`(?!p)`出马！

对应的正则是：


```js
var reg = /(?!^[0-9]{6,12}$)^[0-9A-Za-z]{6,12}$/;
```


三种“都不能”呢？

最终答案是：


```js
var reg = /(?!^[0-9]{6,12}$)(?!^[a-z]{6,12}$)(?!^[A-Z]{6,12}$)^[0-9A-Za-z]{6,12}$/;
console.log( reg.test("1234567") ); // false 全是数字
console.log( reg.test("abcdef") ); // false 全是小写字母
console.log( reg.test("ABCDEFGH") ); // false 全是大写字母
console.log( reg.test("ab23C") ); // false 不足6位
console.log( reg.test("ABCDEF234") ); // true 大写字母和数字
console.log( reg.test("abcdEF234") ); // true 三者都有
```


### 1.3. 不匹配任何东西的正则

```js
reg = /.^/
```

因为此正则要求只有一个字符，但该字符后面是开头。

### 1.4. 数字的千位分隔符表示法


```js
reg = /(?!^)(?=(\d{3})+$)/g

'123123123'.replace(reg, ',')
// 123,123,123
```

首先整个正则只是匹配了位置，而不是字符，所以replace方法并没有替换任何字符，只是在相应位置插入了分隔符。

`(?!^)`表明这个位置不是开头，也就是避免了`,123,123`情况。

`(?=\d{3}$)`可以匹配最后一个分隔符，加上`+`号可以匹配多个，即`(?=(\d{3})+$)`


如果要支持处理包含空格的数字，比如`123123 123123`，则需要把正则中`^`和`$`替换成`\b`，即字符边界，正则即为`/(?!\b)(?=(\d{3})+)\b/`，也就是`/(\B)(?=(\d{3})+\b)/`


```js
reg = /(\B)(?=(\d{3})+\b)/g

'123123 123123'.replace(reg, ',')
// 123,123 123,123
```

## 2. 断言（环视）

### 2.1. 正向先行断言

正向先行断言：(?=表达式)，指在某个位置往右看，所在的位置右侧必须匹配表达式。




```js

reg = /喜欢(?=你)/

'他很喜欢你'.match(reg)[0]
// 喜欢


'喜欢你'.match(reg)[0]
// 喜欢


'喜欢他'.match(reg)
// null

'喜欢跑步'.match(reg)
// null
```


### 2.2. 反向先行断言

反向先行断言：(?!表达式)，指在某个位置往右看，不能存在表达式中的内容。

```js
reg = /喜欢(?!你)/

'她喜欢你'.match(reg)
// null

'她喜欢你的微笑'.match(reg)
// null

'她喜欢篮球'.match(reg)[0]
// 喜欢

'喜欢做饭'.match(reg)
// 喜欢
```

### 2.3. 正向后行断言

正向后行断言：(?<=表达式)，指在某个位置往左看，存在表达式中的内容。


```js
reg = /(?<=我)喜欢/

'他喜欢你'.match(reg)
// null

'喜欢做饭'.match(reg)
// null

'喜欢你的微笑'.match(reg)
// null

'我喜欢篮球'.match(reg)
// 喜欢
```

### 2.4. 反向后行断言

反向后行断言：(?<!表达式)，指在某个位置往左看，不能存在表达式中的内容。


```js
reg = /(?<!我)喜欢/

'他喜欢你'.match(reg)
// 喜欢

'喜欢做饭'.match(reg)
// 喜欢

'喜欢你的微笑'.match(reg)
// 喜欢

'我喜欢篮球'.match(reg)
// null
```

## 保留两位小数的价格输入框


```ts

// 输入限制
const changePiece = (e) =>{
      e.target.value = e.target.value.replace(/^\D*(\d*(?:\.\d{0,2})?).*$/g, '$1');
  }
  return (
    <div>
       <input type="text" onKeyUp={ (e) => {changePiece(e)}} /> 
    </div>
  );
```