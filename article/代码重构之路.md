[toc]

## 1. 开始

持续记录项目重构过程中的方法、思路和感想。

首先，要有一个意识，不要指望需求一成不变，不要指望项目结构、代码一成不变，程序员20%的时间花在写代码上，80%的时间花在后续维护迭代上。

如何让代码更健壮，更能适应将来的变化呢？个人实践中觉得有用的包括：

理论层面：

- 抽象工具、组件，提高复用性
- 单一职责原则，保持简单，并减少耦合
- 保持单向依赖

实现层面：

- ts语法，编译阶段发现错误
- 函数式调用替换普通写法，减少中间变量
- 项目分层，不同功能模块放在不同的文件夹

抽象能力是一种容易忽略的能力，每次遇到需求，容易无脑拷贝，其实可以看看和以前的组件、逻辑有什么异同，找找规则，封装、抽象出公共的、稳定的部分。

应该将复杂的事情简单做，化繁为简，而不是所谓的简单的事情复杂做。“化繁为简”这个词在招聘要求中看到过一次。

## 2. 关于重构


### 2.1. 目的

为什么进行重构呢？原因各不相同：

- 生产力低下
  - 框架原因，比如`jquery`这种操作`dom`的方式，比不上数据驱动开发效率高
  - 代码自身问题，耦合严重，理解成本高、开发效率低
- 性能差
- 其他

### 2.2. 分级

从技术层面上，重构可以分为：

- 技术栈迁移，比如用`electron`跨平台框架重构多端代码，本质是重写，也可视为广义的重构
- 核心框架迁移，可复用一小部分逻辑，但核心代码仍需重写，比如`jquery`到`vue`、`vue`到`react`
- 核心框架升级，或架构模式变动，比如`vue2`到`vue3`、客户端渲染到`ssr`
- 其他框架迁移
- 代码细节改造

从项目层面上，重构可以分为：

- 项目级别
- 多页面级别
- 单页面级别
- 组件级别

除了项目级别的改动，也就是推倒重来、另起炉灶，其他的重构都建议在原地改。

比如要沉淀组件库，或ui和逻辑的分离，先在原来的地方改好、再迁移效率会更高，因为如果在组件库上改，需要mock很多环境，效率低。

## 3. 原则

### 3.1. 单一职责

好代码一定是符合单一职责原则的，如果一个组件、函数、类不符合这个原则，短期内看似做的很快，长远来看，一定会后续迭代时频繁出bug、难维护，还会让其他开发者无法复用，导致频繁拷贝代码然后修改。

不符合单一职责原则的代码，模块化一定不会太好，可复用性低。

符合单一职责的代码，在需求变更、项目重构时可很容易的复用、迁移、扩展等，哪怕是技术栈的迁移，比如`jquery`到`vue`、`vue`到`react`这种，开发者都能轻易的理清之前的逻辑。


### 3.2. 单向依赖

单一职责可以降低模块内部的复杂度，单向依赖可以降低模块之间的复杂度，增强可维护性。

不要用`someMethod.call(this)`，这种本质上是违反了**单向依赖**，本来是组件依赖工具方法，现在工具方法又依赖了组件内的内容。

也许一开始用到了一两个属性，但随着不断迭代，后面这个`this`会越用越多，后面就积重难返了。所以一开始就不要用 `.call(this)`这种语法。

另外，公共基础库中对业务项目的`config`的依赖，也是违反了单向依赖原则，这种情况其实一个依赖注入就解决了，就是在`startApp`的时候把`config`注入进入即可。很多人理不清这里，其实是没想明白单向依赖。

### 3.3. 组件库


将核心组件、核心逻辑抽离到`press-ui`，好处如下：


- 增强可维护性，提升开发效率
  - 通过整理代码，合并属性，分离业务逻辑等，让组件变纯粹，增强可维护性，进而提升效率
- 减少业务和组件的耦合，降低各自复杂度，并减少bug
- 封装核心逻辑，控制变化
  - 不用担心外部合作人员改乱代码，以及解决冲突时的覆盖问题
- UI问题定位简单
  - 三端代码同时发布，以及多种类型的示例，覆盖面全，容易发现ui问题，以及三端表现不一致问题
- 可提升性能
  - 通过自定义队伍数等变量，定位性能瓶颈，并解决性能问题
- 提高可复用性，可应用到其他项目
- 技术沉淀，技术积累，不断打磨组件细节

并非所有组件、逻辑都可以沉淀到组件库中，有以下准入条件：

- `press-ui`内的组件、逻辑需要有一定的通用性或复杂性，比如`button`、`input`、`area`、`message-detail`等组件通用型强，`schedule-tree`组件复杂度高。
- 对于`press-ui`中沉淀的逻辑也是如此。


`press-ui`的组件、逻辑都应该减少与业务的耦合，基础组件很容易做到，也很容易判断是否耦合，对于业务中沉淀下来的，如何做到呢？

- 不能存在业务状态码，多重判断逻辑应该前置完成
- 关注点分离，关注组件自身，而非业务
- 最少知识原则，只传入必要的参数
  



## 4. 项目


### 4.1. 轮次设置

对于某项目的轮次设置页面，进行分层如下：

<img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/article/2023/6/own_mike_33cb598ce7694ab072.png" width="800">

- `config`主要是常量定义
- `helper`包含一些辅助工具，比如对时间做格式化
- `popup`是一些函数式调用组件
- `page`引用了`component`组件和`popup`
- `logic`包含请求接口逻辑
- `operation`包含对`logic`的封装，比如错误提示、检查已经开赛的比赛个数等


函数式调用可以减少中间变量，比如上面的页面，有很多弹出层，且是嵌套的逻辑。点击A弹出B，点击B弹出C，点击C中的某个选项又要回到B，这其中涉及很多中间状态，需要写很多的`data`、`computed`、`methods`，用函数调用的方式可以大大减少这种中间变量，使逻辑更内聚，不容易出bug。


重构后的效果：

- 页面之前1600行，重构后降到500多行
- 减少了中间变量，逻辑内聚、清晰
- 减少了其他文件对页面`this`的引用，减少耦合

### 4.2. 赛程

赛程树核心组件抽离，并遵循最小知识原则，`roundList`由`scheList`计算生成，不再由外部传入。


其他部分进行中。

