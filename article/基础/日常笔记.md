

## 一、开始

近期整理了一些“收藏”，主要是日常开发中遇到过的问题和小知识点。


## 二、前端

### 1. void运算符

void 运算符 对给定的表达式进行求值，然后返回 undefined。比如：

```js
function test() {
  return void console.log(1)
}

const res = test()
// 1

console.log(res)
// undefined
```



`void 0`返回`undefined`，为什么经常能看到`void 0`，而不是直接用`undefined`呢？因为`undifined`在函数中可以被改写，在全局作用域中不会。


```js
function test() {
  const undefined = 1
  console.log(undefined)
}

test() // 1
```

为什么是`void 0`呢，而不是其他表达式呢，因为`void 0`是表达式中最短的。用`void 0`代替`undefined`能节省字节。

除了表示undefined外，有时还会看到以下用法：


```html
<a href="javascript:void(0);">
  这个链接点击之后不会做任何事情，如果去掉 void()，
  点击之后整个页面会被替换成一个字符 0。
</a>
<p> chrome中即使<a href="javascript:0;">也没变化，firefox中会变成一个字符串0 </p>
<a href="javascript:void(document.body.style.backgroundColor='green');">
  点击这个链接会让页面背景变成绿色。
</a>
```

当用户点击一个以 `javascript:` 开头的URI 时，它会执行URI中的代码，然后用返回的值替换页面内容，除非返回的值是undefined。void运算符可用于返回undefined。

注意，虽然这么做是可行的，但利用 javascript: 伪协议来执行 JavaScript 代码是不推荐的，推荐的做法是为链接元素绑定事件。



相关资料：

1. [void-MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/void)
2. [void 0 与 undefined的区别](https://blog.csdn.net/juzipchy/article/details/86367565)




### 2. CSS 如何排除具有某个class的项


```scss
.text:not(.text-danger){
  display: inline-block;
}
// 增加样式时将class为text的元素并且含有text-danger类的排除掉。
```

相关资料：[前段笔记之——css 排除具有某个class的项](https://blog.csdn.net/weixin_42336774/article/details/87871397)


### 3. 报错`Cannot read property bindings of null`的解决方法


如果该使用`@babel/preset-env`，却使用了`babel-preset-env`就会报这个错误，也就是`@babel/preset-env`的7和6版本不兼容。

```js
// webpack.config.js
{
 test: /\.js$/,
 loader: 'babel-loader',
 exclude: /node_modules/, 
 query: {
   //presets: ["env"]
   presets: ["@babel/preset-env"]
 }
}
```


相关资料：[Cannot read property bindings of null 解决方法](https://blog.csdn.net/qq_41614928/article/details/106839182)

### 4. CSS宽度高度的百分比取值基于谁


width=num% ， height=num% 基于以下几点

1. 若元素不存在定位： 则基于直接父元素的宽高度

2. 若元素存在定位 且 定位为 relative， 则也基于直接父元素的宽高度

3. 若元素存在定位 且 定位为 absolute， 则基于最近的相对定位（relative）的祖先元素的宽高度

4. 若元素存在定位 且 定位为 fixed， 则始终基于body元素的宽高度


注意上面都是**宽高度**！！！

参考：[CSS宽度高度的百分比取值基于谁](https://www.cnblogs.com/nelson-hu/p/9470648.html)


### 5. h5页面禁止双击或者双指放大




第一种方式，可以在meta中指定以下内容，缺点是如果要放开就很难了。


```html
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no">
```

第二种方式是用JS控制：

```js
// 禁止ios10+页面缩放
export const disabledScale = () => {
    var lastTouchEnd = 0;
    document.addEventListener('touchstart', function (event) {
        if (event.touches.length > 1) {
            event.preventDefault();
        }
    });
    document.addEventListener('touchend', function (event) {
        var now = (new Date()).getTime();
        if (now - lastTouchEnd <= 300) {
            event.preventDefault();
        }
        lastTouchEnd = now;
    }, false);

    // 阻止双指放大
    document.addEventListener('gesturestart', function (event) {
        event.preventDefault();
    })
}
```

在业务组件（比如Vue组建）内引入：


```js
import { disabledScale } from "@/tools/disableScale";

mounted() {
  disabledScale();
},
```

参考：[h5页面禁止双击或者双指放大](https://blog.csdn.net/qq_46003166/article/details/106851406)


### 6. 获取Cookie

主要是正则的理解：`(^| )name=(.*?)(;|$)`。

```js
function getC(name) {
  const re =new RegExp('(^| )' +name + '=(.*?)(;|$)')
  const ma = document.cookie.match(re);
  if (ma && ma[2]) {
    return ma[2]
  } 
}
```


### 7. 驼峰和下划线的转换

转驼峰很简单，就是`/_(\w)/`。


转下划线就是匹配 `/([A-Z])/`，然后用`$1`替换匹配到的，即`_$1`。


```js
// 下划线转换驼峰
function toHump(name) {
    return name.replace(/\_(\w)/g, function(all, letter){
        return letter.toUpperCase();
    });
}

// 驼峰转换下划线
function toLine(name) {
  return name.replace(/([A-Z])/g,"_$1").toLowerCase();
}
 
 
// 测试
let a = 'a_b2_345_c2345';
console.log(toHump(a));
 
let b = 'aBdaNf';
console.log(toLine(b));
```

### 8. 正确使用cookie中的domain

domain的含义为域，分为子域和父域，子域可以访问本级域名及父级域名的下的cookie。

假设有两个域名：

```
域名1：a.b.e.f.com.cn  

域名2：c.d.e.f.com.cn   
```

在域名中，所有域名进行分级，也就是说域名1与域名2都是`f.com.cn`的子域名，`f.com.cn`又是`com.cn`的子域名。

在域名1所使用的服务中，可以设置域名

```
a.b.e.f.com.cn

b.e.f.com.cn

e.f.com.cn

f.com.cn
```

于域名1下的`cookie`，域名2可以拿到`e.f.com.cn`，`f.com.cn这`两个`domain`下的`cookie`，单点登录，就是以这个原理实现的。


#### （1）不同`domain`可以存在同名的`cookie`

如果存在相同名的`cookie`不同`domain`呢？不同域名下`的cookie`可以同名，同域名下的`cookie`同名会被替换。

比如`域名1`设置设置`domain`为`e.f.com.cn`的`cookie`，`mykey=myvalue1`。而在`域名2`中设置`domain`为`c.d.e.f.com.cn`的`cookie`，`mykey=myvalue2`。此时在`域名2`服务端能拿到两个`cookie`，并不存在覆盖一说。

注意在域名2中如果设置`domain`为`e.f.com.cn`的`cookie`，`mykey=myvalue3`。此时会覆盖域为`e.f.com.cn`的`mykey`的值，即浏览器中，同一个域，只存在一个名为`mykey`的`cookie`。

#### （2）显式设置domain

如果不显式设置domain，那么浏览器会生成一个只针对当前域名的cookie。

>如果显式声明，不管域中带不带点，到chrome中，都是带点存储的，只有非显式声明域的cookie，浏览器存储才是不带点的。


如果有一个域名就是`e.f.com.cn`，在该域名下设置的cookie如果没有显式domain，在回写浏览器的时候浏览器会特殊处理。如果是火狐，你会发现该cookie的信息，有一个主机项，而域项消失了。在chrome中，虽然有域这个项，但是域的前面少了一个点，也就是子域名拿不到这个cookie。

所以要想子域名拿到这个cookie，需要显式设置domain，比如：

```js
document.cookie=`userName=123;domain=qq.com;`
```


参考：[正确使用cookie中的domain](https://blog.csdn.net/u010856177/article/details/81104714)



### 9. 倒计时

```js
var presentDate = new Date();
var funtureTime = funtureDate.getTime();
var presenTime = presentDate.getTime();
var allTime = funtureTime - presenTime;         

var allSecond = parseInt(allTime / 1000);
var day = size(parseInt(allSecond / 3600 / 24));
var hour = size(parseInt(allSecond / 3600 % 24));
var minute = size(parseInt(allSecond / 60 % 60));
var second = size(parseInt(allSecond % 60));


function size(num) {
  return num < 10 & num >= 0 ? '0' + num : num;
}  
```

参考：[JS实现超级简单的动态倒计时](https://blog.csdn.net/wls666/article/details/89543397)



### 10. vant使用list时，`@load`无法触发


在`list`的父级样式添加 `overflow-y: scroll; height: 100%;`

参考：[vant使用list时，@load 无法触发](https://blog.csdn.net/weixin_44231175/article/details/119653048)


### 11. selenium和puppeteer的区别


- Chronium -> (DevTools Protocol) -> puppeteer
- Chronium -> (DevTools Protocol) -> ChromeDriver -> (WebDriver Protocol) -> WebDriver Client(比如selenium)


参考：[webdriver和puppeteer在实现原理上有什么区别](https://www.zhihu.com/question/278723746)




### 12. `.gitignore`忽略文件夹中除了指定的文件外的其他所有文件

只有2级目录：

```js
//.ignore忽略文件夹中除了指定的文件外的其他所有文件
**/node_modules/*//忽略文件夹node_modules
!**/node_modules/vue-html5-editor/ //不包含vue-html5-editor文件夹
```

存在多级目录时：

```js
//错误写法
**/node_modules/*//忽略文件夹node_modules
!**/node_modules/vue-html5-editor/dist/  //这样写是不生效的

//正确写法
**/node_modules/*
!**/node_modules/vue-html5-editor/
**/node_modules/vue-html5-editor/*
!**/node_modules/vue-html5-editor/dist
```


参考：[.gitignore忽略文件夹中除了指定的文件外的其他所有文件](https://www.jianshu.com/p/82bbcfbb0ec9)

### 13. 正确的清除cookie

清除cookie方式是设置为过期，切记设置domain和path，只有这两个参数跟你要删除的参数完全一样才能把它删除掉。


参考：[Javascript清除cookie的方法](https://www.jiangweishan.com/article/js8usdotjoi8390785023985.html)


### 14. JS设置CSS样式的几种方式



1. 直接设置style的属性，属性名用驼峰写法

比如：

```
element.style.height = '100px';
```


2. setAttribute

```js
element.setAttribute('height', 100);
element.setAttribute('height', '100px');
```

3. setAttribute设置style

```js
element.setAttribute('style', 'height: 100px !important');
```

4. 使用setProperty。如果要设置!important，推荐用这种方法设置第三个参数,属性名不用驼峰写法

```js
element.style.setProperty('height', '300px', 'important');
```

5. 改变class

```js
element.className = 'blue';
element.className += 'blue fb';
```

6. 设置cssText

```js
element.style.cssText = 'height: 100px !important';
element.style.cssText += 'height: 100px !important';
```


7. 创建并引入新的CSS样式文件

```js
function addNewStyle(newStyle) {
  let styleElement = document.getElementById('styles_js');

  if (!styleElement) {
    styleElement = document.createElement('style');
    styleElement.type = 'text/css';
    styleElement.id = 'styles_js';
    document.getElementsByTagName('head')[0].appendChild(styleElement);
  }
  styleElement.appendChild(document.createTextNode(newStyle));
}

addNewStyle('.box {height: 100px !important;}');
```

8. 使用addRule、insertRule

```js
// 在原有样式操作
document.styleSheets[0].addRule('.box', 'height: 100px');
document.styleSheets[0].insertRule('.box {height: 100px}', 0);

// 或者插入新样式时操作
const styleEl = document.createElement('style');
const styleSheet = styleEl.sheet;
styleSheet.addRule('.box', 'height: 100px');
styleSheet.insertRule('.box {height: 100px}', 0);
document.head.appendChild(styleEl);
```


参考：[JS设置CSS样式的几种方式](https://blog.csdn.net/x619y/article/details/80604609)



### 15. CSS3 animation动画中forwards和both的区别


如果动画无延迟，forwards 和 both 表现出来的效果是相同的；在有延迟的时候表现出来的效果才会不同，forwards 和 both 的结束效果相同（停留在最后一个关键帧中定义的状态），**开始时 both 会应用 backwards（第一帧定义的状态） 的效果**。


参考：[一次搞懂 CSS3 animation动画中forwards和both的区别](https://blog.csdn.net/weixin_42989576/article/details/100551602)



### 16. Webpack3和4的区别


1. 增加了一个mode配置，只有两种值`development | production`。
2. 移除了webpack.optimize.CommonsChunkPlugin。可使用optimization.splitChunks进行模块划分（提取公用代码）。
3. 删除原 extract-text-webpack-plugin 配置，增加 mini-css-extract-plugin 配置。
4. 移除UglifyJsPlugin，只需要使用optimization.minimize为true就行，production mode下面自动为true
5. 移除loaders，必须使用rules。


参考：[WEBPACK3和WEBPACK4区别](https://www.cnblogs.com/Super-scarlett/p/11085363.html)



### 17. Nodejs接收图片base64格式保存为文件


base64的形式为`“data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0...”`；

当接收到上边的内容后，需要将`data:image/png;base64`,这段内容过滤掉，过滤成：`“iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0...”`；然后进行保存。

```js
const fs=require('fs');
app.post('/upload', function(req, res){
    //接收前台POST过来的base64
    var imgData = req.body.imgData;
    //过滤data:URL
    var base64Data = imgData.replace(/^data:image\/\w+;base64,/, "");
    // 返回一个被 string 的值初始化的新的 Buffer 实例,原始二进制数据存储在 Buffer 类的实例中，        
    // 一个 Buffer 类似于一个整数数组，但它对应于 V8 堆内存之外的一块原始内存。
    var dataBuffer = Buffer.from(base64Data, 'base64');
    fs.writeFile("image.png", dataBuffer, function(err) {
        if(err){
          res.send(err);
        }else{
          res.send("保存成功！");
        }
    });
});
```

参考：[Nodejs接收图片base64格式保存为文件](https://blog.csdn.net/weixin_42103706/article/details/105903712)




### 18. 字符串中的换行符`\r`、`\n`、`<br>`不生效问题


在css中设置：

```scss
white-space: pre-line; // 合并空白符序列，但是保留换行符 让换行符生效
```


### 19. 进制转换

js中的两个内置方法 toString 和 parseInt。

`toString` 可以把一个数转换为指定进制的数，`parseInt` 是把数按照指定进制解析成十进制的数。

1. 任意进制转换成十进制

```js
console.log(parseInt('11001',2)) // 25
console.log(parseInt('007F',16)) // 127
```

2. 十进制转成任意进制

```js
(25).toString(2) // 11001
```


顺便贴下字符与Unicode（其实是UTF-16代码单元）互相转化：

```js
"a".charCodeAt(0)
// 97

String.fromCharCode(97)
// "a"
```

### 20. 可选链操作符属性为数组

可选链操作符，数组的话，可以 `list?.[1]`。

也可以 `let nestedProp = obj?.['prop' + 'Name'];`


### 21. TS报类型错误

报类型错误，可以直接`(pvpapp as any).invoke`。


### 22. 异步函数调用

异步函数调用的时候不能用`await`，要用`then`，不然某些考试编辑器会超时。


### 23. 查看npm全局包下载路径

```bash
# 查看全局包下载路径
$ npm root -g

# 查看命令下载路径
$ npm bin -g
```

### 24. 插槽

插槽就是在组件引用的内部增加额外的内容，比如一个子组件名字是`Comp`，父组件这样使用：`<Comp>hello</Comp>`，`hello`所处的位置就是`slot`插槽。




### 25. 实现一个任务调度器，将多个任务依次执行，并且上一个任务的结果作为下一个任务的参数

```js
function taskRunner() {
  // TODO
}

function step1(a) {
  return `1-${a}`
}

async function step2(b) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(`2-${b}`)
    }, 2000)
  })
}


const task = taskRunner(step1, step2)

const res = task(0)
```

实现：

```js
function taskRunner() {
  const [...steps] = [...arguments];

  return async function (...args) {
    let tempRes;

    for (let i = 0;i < steps.length;i++) {
      const step = steps[i];
      if (i == 0) {
        tempRes = await Promise.resolve(step(...args));
      } else {
        tempRes = await Promise.resolve(step(tempRes));
      }
    }

    return tempRes;
  };
}

const task = taskRunner(step1, step2)

const res = task(0)

res.then(res => {
  console.log('res', res)
})
// res 2-1-0
```

### 26. 将对象的key由下划线转为驼峰，只转化key

```js
function toHump(str) {
  return str.replace(/\_(\w)/g, (a,b) => {
    return b.toUpperCase()
  })
}

function objToHump(obj, cache = new WeakMap()) {
  if (!(obj instanceof Object)) {
    return obj;
  }

  if (cache.get(obj)) {
    return cache.get(obj);
  }

  const res = {};
  cache.set(obj, res);

  Object.keys(obj).map((key) => {
    const newKey = toHump(key);

    if (obj[key] instanceof Object) {
      if (Array.isArray(obj[key])) {
        res[newKey] = obj[key].map(cObj => objToHump(cObj, cache));
      } else {
        res[newKey] = objToHump(obj[key], cache);
      }
    } else {
      res[newKey] = obj[key];
    }
  });

  return res;
}


const obj = {
  a_apple_p: 'aa',
  a_apple_q: {
    a_k_c: '1',
  },
  a_apple_u: {
    a_apple_h: {
      a_apple_i: '123',
    },
  },
  a_apple_t: [
    {
      a_k_c: '2',
      dd_dd_dd: '3',
    },
    {
      a_k_d: '5',
      dd_dd_de: '6',
    },
  ],
};

obj.t_t_t = obj;

console.log(objToHump(obj));

/**
 * {
      aAppleP: 'aa',
      aAppleQ: { aKC: '1' },
      aAppleU: { aAppleH: { aAppleI: '123' } },
      aAppleT: [ { aKC: '2', ddDdDd: '3' }, { aKD: '5', ddDdDe: '6' } ],
      tTT: [Circular *1]
    }
 */
```


### 27. 理解 TypeScript 中 any 和 unknown


#### （1）Any

any 类型类似于纯 JavaScript 的工作方式。我们有时可能需要描述一个我们根本不知道类型的变量。

```ts
let uncertain: any = 'Hello world'!;
uncertain = 5;
uncertain = { hello: () => 'Hello world!' };
```

在 TypeScript 中，任何东西可以赋值给 any 。它通常被称为 top type 。


>any 和 unknown 的最大区别是, unknown 是 top type (任何类型都是它的 subtype) , 而 any 即是 top type, 又是 bottom type (它是任何类型的 subtype ) , 这导致 any 基本上就是放弃了任何类型检查.

any 破坏了 TypeScript 的类型检查，会引起错误：

```ts
const uncertain: any = 'Hello world!';
uncertain.hello();
```

下面是更接近实际的例子：

```ts
const dog: any = {
 name: 'Fluffy',
 sayHello: () => 'woof woof'
};

dog.hello();
```


#### （2）Unknown

TypeScript 3.0中引入的 unknown 类型也被认为是 top type ，但它更安全。与 any 一样，所有类型都可以分配给unknown。

```ts
let uncertain: unknown = 'Hello'!;
uncertain = 12;
uncertain = { hello: () => 'Hello!' };
```

我们只能将 unknown 类型的变量赋值给 any 和 unknown。

```ts
let uncertain: unknown = 'Hello'!;
let notSure: any = uncertain;
```

它确实在很多方面不同于 any 类型。如果不缩小类型，就无法对 unknown 类型执行任何操作。

```ts
function getDog() {
return '22'
}

const dog: unknown = getDog();
dog.hello(); //Object is of type 'unknown'
```

##### a. 使用类型断言缩小未知范围

上述机制具有很强的预防性，但对我们的限制过于有限。要对未知类型执行某些操作，首先需要使用类型断言来缩小范围。

```ts
const getDogName = () => {
let x: unknown;
return x;
};

const dogName = getDogName();
console.log((dogName as string).toLowerCase());
```

在上面的代码中，我们强制TypeScript编译器相信我们知道自己在做什么。

以上的一个重要缺点是它只是一个假设。它没有运行时效果，也不能防止我们在不小心的情况下造成错误。比如下面的代码, 他实际上是错误的, 但却可以通过 typescript 的检测.

```ts
const number: unknown = 15;
(number as string).toLowerCase();
```

TypeScript编译器接收到我们的数字是一个字符串的假设，因此它并不反对这样处理它。


##### b. 使用类型收缩

一种更类型安全的缩小未知类型的方法是使用 类型收缩 。TypeScript 编译器会分析我们的代码，并找出一个更窄的类型。

```ts
const dogName = getDogName();
if (typeof dogName === 'string') {
  console.log(dogName.toLowerCase());
}
```

在上面的代码中，我们在运行时检查了 dogName 变量的类型。因此，我们可以确保只在 dogName 是变量时调用 toLowerCase函数。

除了使用 typeof，我们还可以使用 instanceof 来缩小变量的类型。

```ts
type getAnimal = () => unknown;

const dog = getAnimal();

if (dog instanceof Dog) {
 console.log(dog.name.toLowerCase());
}
```

在上面的代码中，我们确保只有在变量是某个原型的实例时才调用dog.name.toLowerCase。TypeScript编译器理解这一点，并假设类型。


##### c. 联合类型中的 unknown 类型

在联合类型中，unknown 类型会吸收任何类型。这就意味着如果任一组成类型是 unknown，联合类型也会相当于 unknown：

```ts
type UnionType1 = unknown | null;       // unknown
type UnionType2 = unknown | undefined;  // unknown
type UnionType3 = unknown | string;     // unknown
type UnionType4 = unknown | number[];   // unknown
```

这条规则的一个意外是 any 类型。如果至少一种组成类型是 any，联合类型会相当于 any：

```ts
type UnionType5 = unknown | any;  // any
```

为什么 unknown 可以吸收任何类型（any 类型除外）？让我们来想想 unknown | string 这个例子。这个类型可以表示任何 unkown 类型或者 string 类型的值。就像我们之前了解到的，所有类型的值都可以被定义为 unknown 类型，其中也包括了所有的 string 类型，因此，unknown | string 就是表示和 unknown 类型本身相同的值集。因此，编译器可以将联合类型简化为 unknown 类型。


##### d. 交叉类型中的 unknown 类型

在交叉类型中，任何类型都可以吸收 unknown 类型。这意味着将任何类型与 unknown 相交不会改变结果类型：

```ts
type IntersectionType1 = unknown & null;       // null
type IntersectionType2 = unknown & undefined;  // undefined
type IntersectionType3 = unknown & string;     // string
type IntersectionType4 = unknown & number[];   // number[]
type IntersectionType5 = unknown & any;        // any
```

让我们回顾一下 IntersectionType3：unknown & string 类型表示所有可以被同时赋值给 unknown 和 string 类型的值。由于每种类型都可以赋值给 unknown 类型，所以在交叉类型中包含 unknown 不会改变结果。我们将只剩下 string 类型。


##### e. 示例：从 localStorage 中读取JSON


这是一个使用 unknown 类型的真实例子。

假设我们要编写一个从 localStorage 读取值并将其反序列化为 JSON 的函数。如果该项不存在或者是无效 JSON，则该函数应返回错误结果，否则，它应该反序列化并返回值。

因为我们不知道在反序列化持久化的 JSON 字符串后我们会得到什么类型的值。我们将使用 unknown 作为反序列化值的类型。这意味着我们函数的调用者必须在对返回值执行操作之前进行某种形式的检查（或者使用类型断言）。


实现如下：

```ts
type Result =
  | { success: true, value: unknown }
  | { success: false, error: Error };
 
function tryDeserializeLocalStorageItem(key: string): Result {
  const item = localStorage.getItem(key);
 
  if (item === null) {
    // The item does not exist, thus return an error result
    return {
      success: false,
      error: new Error(`Item with key "${key}" does not exist`)
    };
  }
 
  let value: unknown;
 
  try {
    value = JSON.parse(item);
  } catch (error) {
    // The item is not valid JSON, thus return an error result
    return {
      success: false,
      error
    };
  }
 
  // Everything's fine, thus return a success result
  return {
    success: true,
    value
  };
}
```


tryDeserializeLocalStorageItem 的函数调用者在尝试使用 value 或 error 属性之前必须首先检查 success 属性：

```ts
const result = tryDeserializeLocalStorageItem("dark_mode");
 
if (result.success) {
  // We've narrowed the `success` property to `true`,
  // so we can access the `value` property
  const darkModeEnabled: unknown = result.value;
 
  if (typeof darkModeEnabled === "boolean") {
    // We've narrowed the `unknown` type to `boolean`,
    // so we can safely use `darkModeEnabled` as a boolean
    console.log("Dark mode enabled: " + darkModeEnabled);
  }
} else {
  // We've narrowed the `success` property to `false`,
  // so we can access the `error` property
  console.error(result.error);
}
```

请注意，tryDeserializeLocalStorageItem 函数不能简单地通过返回 null 来表示反序列化失败，原因如下：

1. null 值是一个有效的 JSON 值。因此，我们无法区分是对值 null 进行了反序列化，还是由于缺少参数或语法错误而导致整个操作失败。
2. 如果我们从函数返回 null，我们无法同时返回错误。因此，我们函数的调用者不知道操作失败的原因。


#### （3）小结

unknown 类型要安全得多，因为它迫使我们执行额外的类型检查来对变量执行操作。




参考：
1. [[译] 理解 TypeScript 中 any 和 unknown](https://blog.51cto.com/u_13691366/3266274)
2. [[译] TypeScript 3.0: unknown 类型](https://blog.csdn.net/weixin_33716557/article/details/93177689)



### 28. 填写Promise的返回值类型

介绍完 unknown 类型后，看下下面这个题：


lib.d.ts：

```ts
type SomeProp = unknown;
export declare function getSomeProp(): Promise<SomeProp>;
```

main.ts：

```ts
import { getSomeProp } from './lib';

/**
 * 请实现下面这个类型，使得下面的 `main` 函数能通过 TypeScript 的类型检查。
 * 注意：不能修改 lib.d.ts 文件。
 */
type Result = /* REPLACE */ any;

async function main() {
  const res: Result = await getSomeProp();
}
```

这里我的理解是 unknown 类型的变量只能赋值给 any 或 unknown，那么这里不是 any 也就是 unknown 了。


### 29. Passive Event Listeners

addEventListener()：大家都是认识的，为dom添加触发事件。

在早期addEventListener是这样的：

```js
addEventListener(type, listener, useCapture)
```

useCapture:是否允许事件捕捉，但是很少会传true，然后就变成可选项了：


```js
addEventListener(type, listener[, useCapture ])
```

到现在就变成了这个样子：

```js
addEventListener(type, listener, {
    capture: false, //捕获
    passive: false, 
    once: false    //只触发一次
})
```


如果我们在 touchstart 事件调用 preventDefault 会怎样呢？这时页面会禁止，不会滚动或缩放。那么问题来了：浏览器无法预先知道一个监听器会不会调用 preventDefault()，它需要等监听器执行完后，再去执行默认行为，而监听器执行是要耗时的，这样就会导致页面卡顿。

当你触摸滑动页面时，页面应该跟随手指一起滚动。而此时你绑定了一个 touchstart 事件，你的事件大概执行 200 毫秒。这时浏览器就犯迷糊了：如果你在事件绑定函数中调用了 preventDefault，那么页面就不应该滚动，如果你没有调用 preventDefault，页面就需要滚动。但是你到底调用了还是没有调用，浏览器不知道。只能先执行你的函数，等 200 毫秒后，绑定事件执行完了，浏览器才知道，“哦，原来你没有阻止默认行为，好的，我马上滚”。此时，页面开始滚。


当浏览器等待执行事件的默认行为时，大部分情况是白等了。如果 Web 开发者能够提前告诉浏览器：“我不调用 preventDefault 函数来阻止事件事件行为”，那么浏览器就能快速生成事件，从而提升页面性能。

Chrome官方有个视频测试：https://www.youtube.com/watch?v=NPM6172J22g 


而 passive 就是为此而生的。在 WICG 的 demo 中提到，即使滚动事件里面写一个死循环，浏览器也能够正常处理页面的滑动。

在最新的 DOM 规范中，事件绑定函数的第三个参数变成了对象：

```js
target.addEventListener(type, listener[, options]);
```

我们可以通过传递 passive 为 true 来明确告诉浏览器，事件处理程序不会调用 preventDefault 来阻止默认滑动行为。

在 Chrome 浏览器中，如果发现耗时超过 100 毫秒的非 passive 的监听器，会在 DevTools 里面警告你加上 `{passive: true}`。




参考：

1. [移动Web滚动性能优化: Passive event listeners](https://zhuanlan.zhihu.com/p/24555031)
2. [passive的作用和原理](https://blog.csdn.net/w993263495/article/details/85009761)
3. [让页面滑动流畅得飞起的新特性：Passive Event Listeners](https://blog.csdn.net/dj0379/article/details/52883315)

### 30. Chrome渲染原理

上面的参考文章中，讲到了Chrome的渲染过程中的几个概念：

- 绘制（Paint）：将绘制操作转换成为图像的过程（比如软件模式下经过光栅化生成位图，硬件模式下经过光栅化生成纹理）。在Chrome中，绘制分为两部分实现：绘制操作记录部分（main-thread side）和绘制实现部分（impl-side）。绘制记录部分将绘制操作记录到SKPicture中，绘制实现部分负责将SKPicture进行光栅化转成图像；
- 图层（Paint Layer）：在Chrome中，页面的绘制是分层绘制的，页面内容变化的时候，浏览器仅需要重新绘制内容变化的图层，没有变化的图层不需要重新绘制；
- 合成（Composite）：将绘制好的图层图像混合在一起生成一张最终的图像显示在屏幕上的过程；
- 渲染（Render）：可以简单认为渲染等价于绘制+合成；
- UI线程（UI Thread）：浏览器的主线程，负责接收到系统派发给浏览器窗口的事件、资源下载等；
- 内核线程（Main/Render Thread）：Blink内核及V8引擎运行的线程，如DOM树构建、元素布局、绘制（main-thread side）、JavaScript执行等逻辑在该线程中执行；
- 合成线程（Compositor Thread）：负责图像合成的线程，如绘制（impl-side），合成等逻辑在该线程中执行。

#### （1）单线程渲染框架

内核线程几乎包揽了页面内容渲染的所有工作，如JavaScript执行，元素布局，图层绘制，图层图像合成等，每项工作的执行耗时基本都跟页面内容相关，耗时一般在几十毫秒至几百毫秒不等。

<img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/chrome-single-thread-render.png" width="500">

#### （2）线程化渲染框架

<img src="https://mike-1255355338.cos.ap-guangzhou.myqcloud.com/chrome-multi-thread-render.png" width="500">


在Chrome的线程化渲染框架中，当内核线程完成第1帧（Frame#1）的布局和记录绘制操作，立即通知合成线程对第一帧（Frame#1）进行渲染，然后内核线程就开始准备第2帧（Frame#2）的布局和记录绘制操作。由此可以看出，内核线程在进行第N+1帧的布局和记录绘制操作同时，合成线程也在努力进行第N帧的渲染并交给屏幕展示，这里利用了CPU多核的特性进行并发处理，因此提高了页面的渲染效率。由此也可知，实际上用户看到的页面内容，是上一帧的内容快照，新的一帧还在处理中。


### 31. 配置 Webpack 的 loader


#### （1）配置规则Rule的条件

`Rule.test`

筛选资源，符合条件的资源让这项规则中的loader处理。

除了test，还可以用
- Rule.include（包含）
- Rule.exclude（排除）
- Rule.resource（可以在里面配置test、include、exclude子选项，上面三个其实是它的快捷选项）
- Rule.issuer（匹配的不是资源路径，而是引入资源的文件的路径）
- Rule.resourceQuery（匹配资源引入路径上从问号开始的部分）

来匹配。

这些规则可以同时使用，同时使用时，是“与”的关系。必须同时符合以上所有配置的条件才可以让这项规则中的loader处理。


#### （2）配置规则Rule的loader

- `Rule.use`
- `Rule.loader`

1. `use: ['style-loader']`其实是`use: [ { loader: 'style-loader'} ]`的简写。
2. `loader: 'css-loader'` 是 `use: [ { loader: 'css-loader'} ]`的简写。


参考：[『Webpack系列』—— loader配置详解](https://juejin.cn/post/6847902222873788430)


### 32. progress-bar-webpack-plugin

webpack插件，显示构建过程进度条


### 33. babel-plugin-module-resolver 

模块解析插件


`.babelrc`文件
```js
{
  "plugins": [
    ["module-resolver", {
      "root": ["./"],
      "alias": {
         "P":"./app/p"
      }
    }]
  ]
}
```

因为`.babelrc`文件的路径在项目根, 我们指定配置`module-resolver的root为"./"`，因此我们在使用类似`import X from 'path’`导入模块的使用可以不指定`…/…/`这种相对路径, 默认以项目根为模块的搜索路径。也可以使用别名，而不是在项目中使用相对路径。


下面举个简单的例子：

```js
//import Mp from '../../p/MyPropTypes';
import Mp from 'P/MyPropTypes'

//import MyUtilFn from '../../../../utils/MyUtilFn';
import MyUtilFn from 'utils/MyUtilFn';
```


### 34. json-templater/string 库

可以进行简单的字符串替换


### 35. React Dev Tools 注入全局变量 `__REACT_DEVTOOLS_GLOBAL_HOOK__`


当我们使用React Dev Tools时，Dev Tools会向页面注入全局变量__REACT_DEVTOOLS_GLOBAL_HOOK__。

这个变量是连接React与Dev Tools的桥梁。

### 36. 简写形式：export { default } from './index.vue'

#### （1）转发 default
```js
import comp from './index.vue'
export default comp
```
等于以下形式 ：

```js
export { default } from './index.vue'
```

#### （2）转发全部

```js
import { foo, bar } from 'utils'
export {
  foo,
  bar
};
```

等于以下形式：

```js
export * from 'utils'
```


### 37. ElementUI源码中，是如何拿到所有的自定义icon的？

ElementUI源码中，是如何拿到所有的自定义icon的？

```js
var postcss = require('postcss');

var fontFile = fs.readFileSync(path.resolve(__dirname, 'icon.scss'), 'utf8');
var nodes = postcss.parse(fontFile).nodes;

var classList = [];

nodes.forEach((node) => {
  var selector = node.selector || '';
  var reg = new RegExp(/\.el-icon-([^:]+):before/);
  var arr = selector.match(reg);

  if (arr && arr[1]) {
    classList.push(arr[1]);
  }
});
```

### 38. 前端如何实时监听本地代码文件的修改变动？

可以使用chokidar模块


### 39. JS 中 replace函数

#### （1）replace函数

replace方法的第二个参数是函数的时候，函数的第一个参数是匹配模式的字符串。接下来的参数是与模式中的子表达式匹配的字符串，可以有 0 个或多个这样的参数。

如下面第三个例子中，`camelize('abc-def-xyz')`打印信息为 

```
-d d
-x x
```

#### （2）例子

1. 在本例中，我们将把所有的花引号替换为直引号：


```js
name = '"a", "b"';

name.replace(/"([^"]*)"/g, "'$1'");
```

2. 在本例中，我们将把字符串中所有单词的首字母都转换为大写：

```js
name = 'aaa bbb ccc';

uw=name.replace(/\b\w+\b/g, function(word){
    return word.substring(0,1).toUpperCase() + word.substring(1);}
);
```

3. 中线改驼峰

```js
const camelizeRE = /-(\w)/g;

export function camelize(str: string): string {
  return str.replace(camelizeRE, (_, c) => {
     console.log(_, c)
     c.toUpperCase()
  });
}
```

### 40. NodeJS中如何获取换行符

```js
var endOfLine = require('os').EOL
```


### 41. Vuepress的 displayAllHeaders 及 sidebarDepth 不生效，原因h1标题后必须接h2，不能直接跨到h3


### 42. Vuepress的sidebar配置数组形式时，目录的README.md如何配置？

解决：需要写成'/pmd-tools/'或者'/pmd-tools/index'，写成'/pmd-tools'或者'/pmd-tools/README'无效



### 43. v-imapge-preview插件图片不清晰？

原因：设置的基准width太小了，同一张图片，即使用transform的scale放大，也比直接设置width为原始值模糊。解决：将基准width设置为图片原始宽度



### 44. VScode要使eslint-plugin-vue对vue文件生效，需要写tsconfig.json文件

### 45. Typescript 总结


#### typescript常见报错：Element implicitly has an 'any' type because expression of type 'string | number' can't be used to index type. 

解决：声明接口，然后用类型断言
```ts
interface IConfig {
    [key: string]: any;
}

```

- 第一种方式：`(args as IConfig)[key2]`

- 第二种方式：`<IConfig>args[key2]`

上面其实是类型断言，类型断言有两种形式：
- <类型>值
- 值 as 类型

####  函数返回never类型，表示总是会抛出异常或根本就不会有返回值

例如：

```ts
function errorEmitter(): never {
  while(true) {}
}
```

```ts
// 返回never的函数必须存在无法达到的终点
function error(message: string): never {
    throw new Error(message);
}
```


#### 定义数组的两种方式

```ts
let arr: number[] = [1,2,3];
let arr: Array<number> = [1,2,3];
```


#### 元组的约束比数组强，数量和每一项的类型都确定了

元组在读CSV文件的时候会用到

```ts
const info: [string, string, number] = ['yang', 'male', 18]
```



#### 对象数组

```ts
// type alias 类型别名
type User = { name: string; age: number };

class Teacher {
  name: string;
  age: number;
}

const objectArr: Teacher[] = [
  new Teacher(),
  {
    name: 'dell',
    age: 28
  }
];
```


#### 函数参数为变量名称时不报错，直接写对象参数报错 

```ts
inserface Person{
 name: string
}

function getName(person: Person):void {
  console.log(person.name)  
}

const person = {
  name: 'yang',
  age: 18
}

getName(person) // 参数为变量名称时不报错
getName({
  name: 'yang',
  age: 18
}). // 直接写对象参数，报错
```

解决：
Person接口增加`[prop: string]: any`


#### interface定义函数

```ts
interface SayHi {
  (word: string): string;
}

const say: SayHi = (word: string) => {
  return word;
};
```

#### 类中super的使用场景

子类覆盖掉父类方法后，想调用父类的方法，可以用`super.getName()`


#### 初始化赋值简写

```ts
class Person{
  constructor(public name: string){}

  // 等价于下面
  // public name: string;
  // constructor(name: string) {
  //   this.name = name;
  // }
}
```



#### 子类声明构造器的时候，要手动调用父类的构造器，也就是super()，即使父类没有构造器

比如：

```ts
class Person{
  constructor(public name: string){}
}

class Teacher extends Person{
  constuctor(public age: number) {
    super('yang') // 不可少  
  }
}
const teacher = new Teacher(20)
```


####  getter和setter 保护私有变量

```ts
class Person{
  constructor(private _name: string){}
  get name() {
    return this._name+' good'
  }
  set name(name: string) {
    const realName = name.split(' ')[0];
    this._name = realName
  }
}

const person = new Person('yang')
console.log(person.name)

person.name='ygw good'
console.log(person.name)
```

#### 如果把constructor设置为private属性，那就不能在类外通过new的方式调用，但可以在类内调用。借此可以实现单例模式。


#### 抽象类只能被继承，不能直接new实现

#### void类型

声明一个void类型的变量没有什么大用，因为你只能为它赋予`undefined`和`null`：

```ts
let unusable: void = undefined;
```

#### null和undefined类型 

默认情况下null和undefined是所有类型的子类型。 就是说你可以把 null和undefined赋值给number类型的变量。

```ts
let test:string = null;
```
然而，当你指定了`--strictNullChecks`标记，**null和undefined只能赋值给void和它们各自**。

#### TypeScript能够根据返回语句自动推断出返回值类型，因此我们通常省略它，但是箭头函数`=>`后的返回值类型不可省略

```ts
let myAdd: (x: number, y: number) => number =
    function(x: number, y: number): number { return x + y; };
```

#### 与普通可选参数不同的是，带默认值的参数不需要放在必须参数的后面。 如果带默认值的参数出现在必须参数前面，用户必须明确的传入 undefined值来获得默认值


#### 枚举的使用：通过枚举的属性来访问枚举成员，和枚举的名字来访问枚举类型
```ts
enum Response {
    No = 0,
    Yes = 1,
}

function respond(recipient: string, message: Response): void {
    // ...
}

respond("Princess Caroline", Response.Yes)
```


#### 类型保护-去除null或undefined

如果编译器不能够去除 null或 undefined，你可以使用类型断言手动去除。 语法是添加 !后缀： identifier!从 identifier的类型里去除了 null和 undefined：
```ts
function fixed(name: string | null): string {
  function postfix(epithet: string) {
    return name!.charAt(0) + '.  the ' + epithet; // ok
  }
  name = name || "Bob";
  return postfix("great");
}
```

#### 映射类型，从旧类型中创建新类型

```ts
type Readonly<T> = {
    readonly [P in keyof T]: T[P];
}

type Partial<T> = {
    [P in keyof T]?: T[P];
}

// 通过从T中选择属性K的集合来构造类型
type Pick<T, K extends keyof T> = {
    [P in K]: T[P];
}

// K 中所有属性值转化为 T 类型
type Record<K extends string, T> = {
    [P in K]: T;
}
```

使用：
```ts
type PersonPartial = Partial<Person>;
type ReadonlyPerson = Readonly<Person>;
```

```ts
interface Animal {
  canFly: boolean
  canSwim: boolean
}

let person: Pick<Animal, 'canSwim'> = {
  canSwim: true,
}
```

```ts
interface DatabaseInfo {
  id: string
}

type DataSource = 'user' | 'detail' | 'list'

const x: Record<DataSource, DatabaseInfo> = {
  user: { id: '1' },
  detail: { id: '2' },
  list: { id: '3' },
}
```

#### extends关键字，主要作用是添加泛型约束

```ts
interface WithLength {
  length: number
}
// extends 来继承
function logger<T extends WithLength>(val: T) {
  console.log(val.length)
}

logger('hello')
logger([1, 2, 3])
// logger(true) // error 没有length属性
```

#### keyof关键字，用于获取某种类型的所有键，其返回类型是联合类型
```ts
interface Person {
  name: string
  age: number
}

type PersonKey = keyof Person // "name" | "age"
```


keyof 的使用场景：

```ts
interface Person{
  name: string,
  age: number,
}
```

定义了一个对象`info: Person`，然后一个方法`getInfo(key)`会报类型错误，因为key有可能是`name/age`之外的任意属性。可以这样:

```ts
getInfo<T extends keyof Person>(key: T): Person[T]{
  return this.info[key]
}
```


#### typeof关键字，获取一个对象/实例的类型

```ts
interface Person {
  name: string
  age: number
}
const person1: Person = { name: 'monkey', age: 18 }
const person2: typeof person1 = { name: 'jacky', age: 24 } // 通过编译
```

#### 联合类型，表示其类型为多个类型中的任意一个

```ts
export type ButtonSize = 'lg' | 'md' | 'sm'
```

#### 交叉类型，将多个类型合并成一个类型

```ts
type Props = TypographyProps & ColorProps & SpaceProps
```

#### Symbol

Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。
比如，如果你调用Symbol.for("cat")30 次，每次都会返回同一个 Symbol 值，但是调用Symbol("cat")30 次，会返回 30 个不同的 Symbol 值。

Symbol.for()的这个全局登记特性，可以用在不同的 iframe 或 service worker 中取到同一个值。

```js
let a = Symbol.for('abc');
let b = Symbol.for('abc');
a === b; // true

let c = Symbol('abc');
let d = Symbol('abc');
c === d; // false
```

#### superagent可以用来爬虫，抓取页面
cheerio进行数据提取

#### tsconfig.json配置

- tsconfig.json文件中`outDir: './build'`，可以更改编译后的文件地址，如果不指定，直接运行tsc则会在js同文件夹下生成对应的ts文件
- tsconfig.json中的`include、exclude、files`表示tsc编译的范围
- `noImplicitAny: true`，表示必须显式的指明any类型，不能隐式的指明
- `strictNullChecks: true`，表示null不能赋值给string/number等
- `incremental: true`, 表示开启增量编译
- `rootDir: './src'`，表示编译入口
- `allowJS: true`, 表示也会编译JS文件，比如将JS文件中的ES6语法编译成ES5
- `checkJS: true`, 表示对JS语法进行检测


- `noUnusedLocals: true`，表示文件中如果有未使用的代码会报错
- `noUnusedParameter: true`, 表示函数有未使用的参数会报错

- `outFile:'./build/index.js'`，会把所有文件打包到一个文件中，但是这时`module`不可以是`commonjs`，可以是`amd`和`system`


#### tsc命令

- tsc -w命令可以监听文件变化，实时进行编译

- nodemon可以监听文件变化，不断执行某种操作，比如：nodemon node ./build/main.js

- concurrently可以同时执行多种命令，比如：concurrently npm run dev & npm run start


tsc后面接文件名时，tsconfig.json不生效

直接执行tsc时，tsconfig.json才生效


#### ts-loader 9 doesn't support webpack 4，降级到8


#### 类型融合，比如使用第三方库的时候扩展类型



#### jquery的声明文件
```ts
declare module 'jquery' {
  function $(): void;
  // ...
  export = $;
}
```

#### refrence

```ts
///<refrence path='./components' />
```
说明本文件依赖components中的变量


#### 泛型应用的简单举例

比如，add函数要求后一个参数必须和前一个参数相同，`function add(x: string | number, y: string | number)`达不到这样的效果，可以`function add<T>(x: T, y: T){}`。


泛型还可以继承自`stirng | number`，比如`add<T extends string | number>()`



#### 枚举类型

```ts
enum Status={
  offline,
  online=4,
  deleted,
}
```
结果分别是0 4 5

正着查：

```ts
console.log(Status.offline) // 0
```

反着查：

```ts
console.log(Status[0]) // offline
```

#### 类型保护

只有联合类型中，才会出现需要类型保护的情况

类型保护的方式有：
1. 类型断言
2. in语法
3. typeof
4. instanceof


#### 装饰器

装饰器从上到下、从左到右收集，执行的时候从下到上、从右到左执行

```ts
function f() {
    console.log("f(): evaluated");
    return function (target, propertyKey: string, descriptor: PropertyDescriptor) {
        console.log("f(): called");
    }
}

function g() {
    console.log("g(): evaluated");
    return function (target, propertyKey: string, descriptor: PropertyDescriptor) {
        console.log("g(): called");
    }
}

class C {
    @f()
    @g()
    method() {}
}
```

打印顺序为 ：

```
f(): evaluated
g(): evaluated
g(): called
f(): called
```

##### 1. 类的装饰器
唯一的参数是类的构造函数

##### 2.  方法装饰器
有三个参数：
1. 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。
2. 成员的名字。
3. 成员的属性描述符。

##### 3. 访问器装饰器
有三个参数：
1. 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。
2. 成员的名字。
3. 成员的属性描述符。

##### 4. 属性装饰器
有两个参数：
1.  对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。
2. 成员的名字。

属性装饰器没有办法直接修改此属性，因为装饰器第一个参数是类的原型，`Class.prototype.name = 'yang'`，而属性是`test.name`，可以通过`test.__proto__.name`拿到装饰器里赋予的值

##### 5. 参数装饰器
有三个参数：
1. 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。
2. 成员的名字。
3. 参数在函数参数列表中的索引。


##### 6. 执行时机
类的装饰器执行时机是在类定义的时候，不是实例化的时候。
方法的装饰器也是一样，是类定义的时候，就会执行。

##### 返回descriptor

在装饰器中创建新的descriptor，并将它返回的时候，新的descriptor会替换被装饰得对象，比如禁止修改类的属性

#### 构造函数的表示方法

```ts
new (...args: any[])=>any 
```


### 46. vue-test-utils的setData不会改变引用地址？

如果组件内两个变量已经指向了同一地址，setData的方式无法让其不相等，可以用`wrapper.vm.tempSelectRole = {}`改变值

### 47. vue.mixin不生效，找不到getLocation，删除子模块的node_modules就可以了


推测是如果安装了子模块的 node_modules，vue 就会从子模块里取得，而 main.js 的 vue.mixin 会优先找当前目录下的node_modules 的 vue，所以两个 vue 引用位置不同，导致不生效。



### 48. 如何不改变代码，而模拟游戏内环境？

方法：修改User agent，chrome开发者工具 => 右上角... => More tools => Network Conditions => ingame...



### 49. touchmove事件一旦滚动，无法中途停止，即在内部调用event.preventDefault时，会报错。

解决：想模拟中断滚动，可以让元素的scrollTop始终为一定值。


### 50. vue 的script使用typescript时，报JSON解析错误。解决：通过排查发现是tsconfig.json中 lib 没有引入 scripthost 导致。


### 51. `vue-lazyload`重复请求图片？

原因：页面主动设置了`disable-cache`。解决方法：允许使用缓存。


### 52. React源码中用二进制表示mode

```js
var a = 0b000
var b = 0b001
var c = 0b010
var d = 0b100

var mode = a 

// 判断是否包含模式b
mode & b // 0

// 添加模式b
mode |= b  // 1 (0b001)

// 添加模式c
mode |= c // 3 (0b011)
```
二进制或运算符`(|)`：如果两个符号位都为0，则结果为0，否则为1






### 53. js获取上一个兄弟元素

需要用到的两个属性：previousSbiling和previousElementSibling

1. previousSibling：获取元素的上一个兄弟节点；（既包含元素节点、文本节点、注释节点）

2. previousElementSibling：获取上一个兄弟元素节点；（只包含元素节点）；

区别如下图：

![https://github.com/novlan1/technical-blog/blob/main/imgs/previousSibling.jpg](https://github.com/novlan1/technical-blog/blob/main/imgs/previousSibling.jpg?raw=true)

所以一般我们会用previousElementSibling

参考：[js获取上一个兄弟元素](https://www.cnblogs.com/Mrrabbit/p/8591558.html)


### 54. npm查看包的版本信息



#### 远程包
##### 1. 查看npm服务器上所有的jquery版本信息

```
npm view jquery versions
```

##### 2. 查看jquery的最新版本是哪个

```bash
npm view jquery version
```

##### 3. 和第一种方式类似，也能查看jquery所有版本，但能查出更多关于jquery的信息

```bash
npm info jquery
```

#### 本地包
##### 1. 查看本地下载的jquery版本信息

```
npm ls jquery
```
##### 2. 查看全局安装的jquery

```
npm ls jquery -g
```


### 55. npm为什么要设置代理,设置镜像源不就行了吗,两者有什么区别?



代理的话，是设置代理服务器，代理服务器帮你转发下载请求；

镜像源的话，是镜像站点已经提前镜像(下载)了所有的npm包，你是直接从它的服务器上获取到的包。

参考： [npm 代理](https://segmentfault.com/q/1010000017507867)


### 56. 报错信息：Error 'tunneling socket' while executing npm install 

解决：取消代理设置

```bash
npm config set proxy null
npm config set https-proxy null
```

参考：[error-tunneling-socket-while-executing-npm-install](https://stackoverflow.com/questions/33162560/error-tunneling-socket-while-executing-npm-install)

### 57. shims-vue.d.ts 解析


**shims-vue.d.ts**文件

```js
declare module '*.vue' {
  import Vue from 'vue';  // 引用了type和value (value是Vue构造器 type是Vue interface)
  export default Vue;
}
```

在TypeScript编译器解析 `import ‘aaa’ from xxx.vue` 的时候

拿到 `node_modules/vue/` 目录下 `index.d.ts` 中`export default`出来的`type`和`value`， type是Vue接口，value是 const Vue，这个常量的类型是VueConstructor

![demo page](https://github.com/novlan1/technical-blog/blob/main/imgs/shims-vue.d.ts.png?raw=true)
(图中是从'vue'中import中得到的type和 value) 

一个import 能同时import到两个东西，import了一种type 还import了一个value，参考[这里](https://www.typescriptlang.org/docs/handbook/declaration-files/deep-dive.html)

 我们来看vue.d.ts:

![vue.d.ts.png](https://github.com/novlan1/technical-blog/blob/main/imgs/vue.d.ts.png?raw=true)

23行导出了type Vue， 129行导出了 value Vue 这两个东西都被export default出来了 当你import的时候 就拿到了这两个东西，并且改成了你import的名字。


参考：[shims-vue.d.ts 解析](https://www.cnblogs.com/eret9616/p/11308470.html)



### 58. Promise 版本的 JSONP



```js
const jsonp = function (url, data) {
  return new Promise((resolve, reject) => {

    // 初始化url
    const dataString = url.indexOf('?') === -1 ? '?' : '&';
    const callbackName = `jsonpCB_${Date.now()}`;
    url += `${dataString}callback=${callbackName}`;

    if (data) {
      // 有请求参数，依次添加到url
      for (const k in data) {
        url += `&${k}=${data[k]}`;
      }
    }

    const jsNode = document.createElement('script');
    jsNode.src = url;

    // 触发callback，触发后删除js标签和绑定在window上的callback
    window[callbackName] = (result) => {
      delete window[callbackName];
      document.body.removeChild(jsNode);

      if (result) {
        resolve(result);
      } else {
        reject('没有返回数据');
      }
    };

    // js加载异常的情况
    jsNode.addEventListener('error', () => {
      delete window[callbackName];
      document.body.removeChild(jsNode);
      reject('JavaScript资源加载失败');
    }, false);

    // 添加js节点到document上时，开始请求
    document.body.appendChild(jsNode);
  });
};

jsonp('http://192.168.0.103:8081/jsonp', { a: 1, b: 'heiheihei' })
  .then((result) => {
    console.log(result);
  })
  .catch((err) => {
    console.error(err);
  }); 
```


参考：[手写一个JSONP(promise封装)](https://www.jianshu.com/p/43b48648c730?utm_source=oschina-app)


### 59. switch 中一旦 case 匹配，就会一次执行后面的代码，直到遇到 break


#### 1、switch 中一旦 case 匹配，就会一次执行后面的代码，直到遇到 break

```js
for (let i = 0;i < 3;i++) {
  switch (i) {
    case 0: {
      console.log(i);
    }
    case 2: {
      console.log(i);
    }
    default: {
      console.log(i);
    }
  }
}
```
上题的打印顺序是：000122

#### 2、无论default位置在前还是在后，都是先判断各个case, 最后才进default

```js
switch (0) {
  default:
    text = '期待周末！';
    break;
  case 6:
    text = '今天是周六';
    break;
  case 0:
    text = '今天是周日';
}
```
上题中：text 为 '今天是周日'



### 60. JS实现滚动区域触底事件


```js
export default {
  data(){
    return {
      isReachBottom: false,
      reachBottomDistance: 100
      scrollHeight: 0,
      offsetHeight: 0,
    }
  },
  mounted(){
    // 页面加载完成后  将高度存储起来
    let dom = document.querySelector('.comment-area .comment-list')
    this.scrollHeight = dom.scrollHeight
    this.offsetHeight = Math.ceil(dom.getBoundingClientRect().height)
  },
  methods: {
    onScroll(e) {
        let scrollTop = e.target.scrollTop
        let currentHeight = scrollTop + this.offsetHeight + this.reachBottomDistance

        if(currentHeight < this.scrollHeight && this.isReachBottom){
          this.isReachBottom = false
        }
        if(this.isReachBottom){
          return
        }
        if (currentHeight >= this.scrollHeight) {
          this.isReachBottom = true
          console.log('触底')
        }
    }
  }
}
```
监听滚动事件，从 event 上取得 scrollTop 信息，而不是全局的 page

参考：[JS实现滚动区域触底事件](https://www.cnblogs.com/chanwahfung/p/12540114.html)


### 61. touchmove 实时获取当前元素 



```js
// 根据坐标直接返回元素 document.elementFromPoint()

const ele = document.elementFromPoint(touch.pageX, touch.pageY);   
```

eg:

```js
$('ul li').on('touchmove touchstart', (e) => {
  event.preventDefault();
  e = e || window.event;
  const touch = e.originalEvent.targetTouches[0];
  const ele = document.elementFromPoint(touch.pageX, touch.pageY);
});
```

参考：
1. [touchmove 实时获取当前元素](https://www.cnblogs.com/mrt-yyy/p/5946258.html)
2. [Document.elementFromPoint()-MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/elementFromPoint)


### 62. JS 产生正态分布随机数


有一个称为 [Box-Muller (1958)](https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform) 转换的算法能够将两个在区间（0,1] 的均匀分布转化为标准正态分布，其公式为：

y1 = sqrt( - 2 ln(u) ) cos( 2 pi v )

y2 = sqrt( - 2 ln(u) ) sin( 2 pi v )

因为三角函数计算较慢，我们可以通过上述公式的一个 polar form（极坐标形式）能够简化计算，

代码如下：
```js
function getNumberInNormalDistribution(mean,std_dev){
    return mean+(randomNormalDistribution()*std_dev);
}

function randomNormalDistribution(){
    var u=0.0, v=0.0, w=0.0, c=0.0;
    do{
        //获得两个（-1,1）的独立随机变量
        u=Math.random()*2-1.0;
        v=Math.random()*2-1.0;
        w=u*u+v*v;
    }while(w==0.0||w>=1.0)
    //这里就是 Box-Muller转换
    c=Math.sqrt((-2*Math.log(w))/w);
    //返回2个标准正态分布的随机数，封装进一个数组返回
    //当然，因为这个函数运行较快，也可以扔掉一个
    //return [u*c,v*c];
    return u*c;
}
```



参考：[Javascript 随机数函数 学习之二：产生服从正态分布随机数](https://www.cnblogs.com/zztt/p/4025207.html)


### 63. .npmrc文件，npm 配置文件


项目根目录下的.npmrc文件：

```
registry=http://registry.npmjs.org/
```

可以实现，仅仅对于这个项目，换npm的源了

### 64. NodeJS 可以直接读取 .json 文件


示例如下：

```js
const config = require('./config.json')
console.log("name",config.name)
console.log("age",config.age)
```


参考：[nodejs中 require 方法的加载规则](https://blog.csdn.net/duansamve/article/details/89787480)


### 65. ADB命令


ADB，全称为Android Debug Bridge，它是 Android 开发/测试人员不可替代的强大工具。

- 查看ADB版本：adb version
- 查看手机设备：adb devices
- 查看设备型号：adb shell getprop ro.product.model
- 查看电池信息：adb shell dumpsys battery
- 查看设备ID：adb shell settings get secure android_id
- 查看设备IMEI：adb shell dumpsys iphonesubinfo
- 查看Android版本：adb shell getprop ro.build.version.release
- 查看手机网络信息：adb shell ifconfig
- 查看设备日志：adb logcat
- 重启手机设备：adb reboot
- 安装一个apk：adb install /path/demo.apk
- 卸载一个apk：adb uninstall <package>
- 查看系统运行进程：adb shell ps
- 查看系统磁盘情况：adb shell ls /path/
- 手机设备截屏：adb shell screencap -p /sdcard/aa.png
- 手机文件下载到电脑：adb pull /sdcard/aa.png ./
- 电脑文件上传到手机：adb push aa.png /data/local/
- 手机设备录像：adb shell screenrecord /sdcard/ab.mp4
- 手机屏幕分辨率：adb shell wm size
- 手机屏幕密度：adb shell wm density
- 手机屏幕点击：adb shell input tap xvalue yvalue
- 手机屏幕滑动：adb shell input swipe 1000 1500 200 200
- 手机屏幕带时间滑动：adb shell input swipe 1000 1500 0 0 1000
- 手机文本输入：adb shell input text xxxxx
- 手机键盘事件：adb shell input keyevent xx
- 连接多个手机设备时，指定手机设备：adb -s serialNumber <command>


参考：[MAC系统下ADB入门与简单使用](https://zhuanlan.zhihu.com/p/41381658)


### 66. Chrome 跨域的方式


#### Windows 电脑 Chrome 跨域的方式

在chrome的快捷方式上右键，在属性后面加上：
```js
--disable-web-security --user-data-dir=C:\MyChromeDevUserData
```

#### Mac 电脑 Chrome 跨域的方式

最后文件夹为自己主目录，一进来的目录，切换zsh，用pwd可以查看

```
open -n /Applications/Google\ Chrome.app/ --args --disable-web-security  --user-data-dir=/Users/liyuquan/Documents/MyChromeDevUserData
```


参考：[Windows10 Google浏览器的跨域设置——包括版本49前后两种设置
](https://blog.csdn.net/qq_19734597/article/details/104062061)


### 67. JS字符串和 DOM 互相转化 

JS字符串转DOM：
```js
function parseDom(arg) {
    const objE = document.createElement('div');
    objE.innerHTML = arg;
    return objE.childNodes;
};
```

DOM转字符串：
- 直接调用`dom.innerHTML()`

参考：[js 字符串转dom 和dom 转字符串](https://www.cnblogs.com/lxg0/p/5976909.html)



### 68. 用HTTP的方式链接远程仓库，有时会经常要求输入密码，用SSH则不用

参考：[git使用指令git push origin master报错remote: Invalid username or password. fatal: Authentication failed for](https://www.cnblogs.com/xiaohaodeboke/p/12617776.html)



### 69. tagName和nodeName的区别


首先介绍DOM里常见的三种节点类型（总共有12种，如docment）：**元素节点，属性节点以及文本节点**，例如`<h2 class="title">head</h2>`，其中h2是元素节点，class是属性节点，head是文本节点，在这里你可以说h2这个元素节点包含一个属性节点和一个文本节点。其实几乎所有HTML的标签都是元素节点，而id, title, class等则是属性节点，而元素所包含的文本内容则是文本节点。

tagName和nodeName的语义是一样的，都是返回所包含标签的名称，例如上面的h2标签，都是返回h2，但是tagName只能在元素标签上使用，而nodeName则可以在所有的节点上使用。

总结：tagName只能用在元素节点上，而nodeName可以用在任何节点上，可以说nodeName涵盖了tagName，并且具有更多的功能，因此建议总是使用nodeName。

参考：[tagName和nodeName的区别](https://blog.csdn.net/borishuai/article/details/5719227)



### 70. npm link的使用 



1. 假如开发的包的名称是`module-a`，进入`module-a`主目录，执行`npm link`。
2. 进入项目目录，执行`npm link module-a`


参考：[npm link的使用](https://www.jianshu.com/p/aaa7db89a5b2)


### 71. node获取当前路径的三种方法


- __dirname
- process.cwd()
- path.resolve(./)


区别如下：

- __dirname：返回运行文件所在的目录
- path.resolve('./')：当前命令所在的目录
- process.cwd()：当前命令所在的目录

参考：[node获取当前路径的三种方法](https://www.cnblogs.com/founderswitch/p/10310203.html)


### 72. Chrome DevTools — Network - Timing：查看请求在各个阶段对应的时间 


- Queueing：浏览器会在以下情况对请求进行排队：
  - 有更高优先级的请求
  - 在这个域下，已经有6个TCP连接了，达到Chrome最大限制数量。此条规则仅适用在HTTP/1.0和HTTP/1.1
- Stalled：Queueing中的任何一个因素发生都会导致该请求被拖延

- Proxy negotiation：浏览器与代理服务器协商消耗的时间

- DNS Lookup：浏览器对请求的IP地址进行DNS查找所消耗的时间

- Initial conncection：发起连接所消耗的时间

- Request sent：请求发送消耗的时间

- Waiting (TTFB)：浏览器等待响应的时间，TTFB表示 Time To First Byte

- Content Download：资源下载所消耗的时间

![network-timing](https://github.com/novlan1/technical-blog/blob/main/imgs/chrome-network-timing.jpeg?raw=true)

参考：
- [Chrome 官网](https://developers.google.com/web/tools/chrome-devtools/network/reference#timing)
- [Chrome DevTools — Network](https://segmentfault.com/a/1190000008407729)


### 73. JS exec()方法：执行正则表达式匹配



在非全局模式下，exec() 方法返回的数组与 String.match() 方法返回的数组是相同的。

在全局模式下，exec() 方法与 String.match() 方法返回的结果不同。当调用 exec() 方法时，会为正则表达式对象定义 lastIndex 属性，执行执行下一次匹配的起始位置，同时返回匹配数组，与非全局模式下的数组结构相同；而 String.match() 仅返回匹配文本组成的数组，没有附加信息。

因此，在全局模式下获取完整的匹配信息只能使用 exec() 方法。

```js
var s = "JavaScript";  //测试使用的字符串直接量
var r = /\w/g;  //匹配模式
while ((a = r.exec(s))) {  //循环执行匹配操作
    console.log("匹配文本 = " + a[0] + "    a.index = " + a.index + "    r.lastIndex = " + r.lastIndex);  //显示每次匹配后返回的数组信息
}
// 匹配文本 = J    a.index = 0    r.lastIndex = 1
// ...
```


参考：[JS exec()方法：执行正则表达式匹配](http://c.biancheng.net/view/5616.html)


### 74. 【webpack】中library的作用 

webpack默认打包之后的代码形式是这样的（假设我导出 module.exports = 'hello world' ）
```js
(function () {
  return 'hello world'
})()
```

注意：代码是一个自执行函数，外界想获取函数里面的返回值怎么办（也就是模块的导出结果 hello world ），那么就需要配置一个 library 

```js
const path = require('path')

module.exports = {
  entry: './src/utils.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'bundle.js',
    library: 'result'
  }
}
```
 

然后打包之后是这样的形式
```js
var result = (function () {
  return 'hello world'
})()
```

通过把导出的结果赋值给 result 变量，配置了 library: 'result' 

 

将打包之后的文件引入到HTML文件中，可以直接使用哦！（假设打包的文件名是bundle.js）

```html
<body>
  <script src="./dist/bundle.js"></script>
  <script>
    console.log(result)
  </script>
</body>
```
 

如果你不想在HTML中使用，想在一个JS文件里面通过 require 导入来使用，需要这么配置

```js
const path = require('path')

module.exports = {
  entry: './src/utils.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'bundle.js',
    libraryTarget: 'commonjs2'
  }
}
```
 

打包之后代码是这样的
```js
module.exports = (function () {
  return 'hello world'
})()
```

可以在JS文件中导入来使用
```js
import result from './bundle'

console.log(result)
```
同时支持import和require语法引入

 

两个配置同时使用，生效的是第二种模式

参考：[【webpack】中library的作用](https://www.cnblogs.com/wuxianqiang/p/11324078.html)


### 75. vue获取当前页面路由



当前页面
完整url可以用 window.location.href
路由路径可以用 this.$route.path
路由路径参数 this.$route.params

参考：[vue获取当前页面路由](https://blog.csdn.net/weixin_43292447/article/details/89242307)



### 76. NPM 废弃/删除包 

#### 废弃
```
npm deprecate yuyy-test-pkg@1.1.0 'test deprecate'
```

废弃的包除了安装时会有警示，并不影响使用。

#### 删除
```
npm unpublish @yuyy/babel --force
```

参考：[npm发布包教程（五）：废弃/删除](https://segmentfault.com/a/1190000017479985)




### 77. scss中循环的使用


1、`@each in` 循环

使用一个变量： #{$变量名}
```scss
$colors: (
    p1: rgb(255, 113, 61),
    p2: lightblue,
    p3: lightseagreen
);
@each $key, $color in $colors {
    &.#{$key} {
         background-color: $color;
    }
}
```
2、`@for… from… to` 循环

```scss
@for $i from 1 to 4 {
    .paper:nth-child(#{$i}) {
        /**
        有顺序之分
        transform: translate() rotate() !== transform: rotate() translate()
        */
         transform: translate(-50%, -40%) rotate(#{$i}5deg);
     }
}
分别旋转15 25 35 45度
```

参考：[scss中循环的妙用](https://blog.csdn.net/swallowblank/article/details/108468926)


### 78. nodejs判断文件、文件夹是否存在


判断的方法

```js
fs.exists(path, callback)
```

- path：判断的文件夹、文件的路径
- callback：回调函数

```js
fs.exists("dirName", function(exists) {
  console.log(exists ? "创建成功" : "创建失败");
});
```





参考：[nodejs判断文件、文件夹是否存在及删除的方法](https://www.jb51.net/article/127906.htm)



### 79. JavaScript的new Function()方法


new Function的基本用法：

```js

// 最后一个参数是函数的 body(函数体),类型为 string;  
// 前面的参数都是 索要构造的函数的参数(名字)  
var myFunction = new Function('users', 'salary', 'return users * salary');  
```

参考：[你可能不知道的JavaScript的new Function()方法](https://www.jb51.net/article/49103.htm)


### 80. 几个正则


#### Javascript正则里面\s\S和.的区别

- \s 匹配空白字符；
- \S 匹配非空白字符；
- +? 匹配 1 次或多次。

- [\s\S]+? 就是匹配任意字符1次或多次。

- . 匹配换行符以外的字符。

- [.]+? 就是匹配换行符以外的字符1次或多次。

区别就在于：
```js
/.+?/.test('\n')  // false
/[\s\S]+?/.test('\n')  // true

/.+?/.test('\r') // false
/[\s\S]+?/.test('\r')  // true
```


参考：[Javascript正则里面\s\S和.的区别](https://www.imooc.com/wenda/detail/421482)



#### 中文正则

```js
/[\u4e00-\u9fa5]|[^\x00-\xff]/;
```


中文字符算2个，英文字符算1个，求字符总数
```js
export const getFixedNameLen = (teamName) => {
  const chiReg = /[\u4e00-\u9fa5]|[^\x00-\xff]/g;
  const pureName = teamName.replace(chiReg, () => 'xx');
  const len = pureName.length;

  return len;
};
```


#### Vue中限制input最大输入长度

```js
watch: {
   teamName(val = '') {
     const fixedLen = getFixedNameLen(val);
     if (fixedLen > DEFAULT_MAX_LEN) {
        this.teamName = this.teamName.substr(0, val.length - 1);
        this.$forceUpdate();
      }
   },
},
```



### 81. Git 中 cannot lock ref问题的解决


1、打开git-bash, 输入 git branch -a 后发现远程有两个相同名字的分支。

2、删除掉远程重复名字的分支，在删除远程代码之前做好本地代码备份

```
git branch -r -d origin/branch-name  
git push origin :branch-name 
```

参考：[cannot lock ref问题的解决](https://blog.csdn.net/qq_29781403/article/details/78454913)


### 82. 重要的需要优先加载的图片最好采用img，不重要的图片最好采用background

参考：[前端优化-Img与background](https://www.cnblogs.com/hunchun/p/3794182.html)

### 83. Node.js：Expected linebreaks to be 'CRLF' but found 'LF'. 

(linebreak-style)换行符报错换行符报错因为在执行上操作系统不一样的缘故！


参考：[Node.js：Expected linebreaks to be 'CRLF' but found 'LF'. (linebreak-style)换行符报错](https://blog.csdn.net/weixin_37937428/article/details/83063577)



### 84. window.parent 与 Window.top 


#### window.parent

返回当前窗口的父窗口对象.

如果一个窗口没有父窗口,则它的 parent 属性为自身的引用.

如果当前窗口是一个 `<iframe>`, `<object>`, 或者 `<frame>`,则它的父窗口是嵌入它的那个窗口


#### Window.top

返回窗口体系中的最顶层窗口的引用。

#### 区别

window.parent 返回当前窗口的父对象，而 window.top 返回最顶层的窗口对象。

当你在处理父窗口的子框架（subframe），而你想获取顶层框架时，这个属性相当有用。

参考：[window.parent 与 Window.top](https://www.cnblogs.com/ys-wuhan/p/6600885.html)

### 85. Object.seal() 和 Object.freeze()方法


- 相同点：删除属性和添加属性都不生效
- 不同点：Object.seal()方法可以修改属性，Object.freeze()方法不可以修改属性。


### 86. 代理与反向代理



#### 代理，隐藏了真实的客户端。

比如我们想直接上`www.google.com`是上不去的，如果在境外搭一个代理服务器，我们向它发送请求，它再向`www.google.com`发送就可以了。

又比如小明想向马云借钱，但是没有渠道，就可以通过中间好友小芳，让她去借，也隐藏了真实的“客户端“。

#### 反向代理，隐藏了真实的服务端。

比如我们打10086，会有不同的人接电话，10086总机就相当于反向代理服务器。

又如，我们访问淘宝，有很多的服务器，我们不必知道具体是哪一台，`taobao.com`背后就是反向代理服务器。Nginx是有名的反向代理服务器。

参考：[反向代理为何叫反向代理？](https://www.zhihu.com/question/24723688)


### 87. vue同一页面，只是参数不同，如果使用this.$router.push，不会触发mounted钩子

vue同一页面，只是参数不同，如果使用`this.$router.push`，不会触发`mounted`钩子。

可以利用`beforeRouteUpdate`钩子函数，进行参数判断(to.params.mid和from.params.mid)，重新请求数据。


### 88. rgb(0 0 0 / 50%)，就是不透明度50%，等于rgba(0,0,0,0.5)



### 89. beforeDestory前，必须clearInterval，否则多个子组件会相互影响


### 90. vue传递props时，期待boolean类型，若传递undefined，会使用默认类型default。defaut是true则为true，default为false则为false 


### 91. mac - vscode保存文件时，提示权限不足

解决: `sudo chmod -R 用户名 ./`

### 92. JS中map和forEach函数，break和continue报错，return不生效

例子：
```js
function test() {
    const a = [1,2,3,4,5,6]
    a.map(item => { // forEach
        console.log(item)
        if (item == 3){
            continue; // break
            return item
        }
    })
   console.log('end')
}

b = test()
```



### 93. windows切换盘符

直接输入`d:`就可以，或者输入`cd /d`, `d:`


### 94. 通过命令行将iOS的APP安装到模拟器中

```
xcrun simctl install booted Calculator.app 
```


### 95. npm设置registry地址

```
npm config set registry https://mirrors.tencent.com/npm/

npm config set registry https://registry.npm.taobao.org 

npm config set registry http://registry.npmjs.org
```



### 96. 代码规范

1. if-else嵌套不能超过4层
拒绝面条代码，减少代码中各种结构的嵌套，例如 if-else、try-catch、循环等。从指标上说，这是为了降低圈复杂度。从实际读代码的体验上来看，两层刚好，三层偏多，四层爆炸。
2. 方法超过80行
方法尽量精简在80行以内，并且以小function进行组织，方便维护、复用。
3. 项目中存在大量注释掉的无用代码
注释掉的代码应该通过git仓库本身的版本管理来进行回溯，而不是通过注释来注释掉。
4. 遗留大量多余的console.log调试日志
5. 缺少注释
6. 存在很多eslint-disable注释
在代码中存在多个tslint-disable、eslint-disable的注释，而且这些注释本身可被修复。





### 97. localStorage存储数字的时候，取出来的时候是字符串，要parseInt一下


### 98. vue-router中，beforeEach中的location.replace不生效，还是存在历史记录，算是vue-router的bug

### 99. ESLint采用逐级向上查找的方式查找`.eslintrc.*`文件，当找到带有 "root": true 配置项的`.eslintrc.*`文件时，将会停止向上查找。



### 100. antd或者element的页码实现原理


antd或者element的页码实现原理：
1. 总数小于等于8时，显示全部
2. 当前小于等于4时，显示`[前6个, ..., total]`
3. 当前大于等于`total-3`时，显示`[1, ..., 后6个]`
4. 显示`[1, ..., cur-2, cur-1, cur, cur+1, cur+2, ..., total]`

示例代码如下：
```js
function onChangePageList() {
  const { curPage, totalPage } = this;
  const pageList = [];

  // 总数小于等于8
  if (totalPage <= 8) {
    for (let i = 1;i < totalPage + 1 ; i++) {
      pageList.push(i);
    }
    this.showPageList = pageList;
    return;
  }

  // 当前小于等于4
  if (curPage <= 4) {
    for (let i = 1;i <= 6; i++) {
      pageList.push(i);
    }
    pageList.push('...');
    pageList.push(totalPage);
    this.showPageList = pageList;
    return;
  }

  // 当前大于等于totalPage-3
  if (curPage >= totalPage - 3) {
    pageList.push(1);
    pageList.push('...');
    for (let i = totalPage - 5;i <= totalPage; i++) {
      pageList.push(i);
    }
    this.showPageList = pageList;
    return;
  }

  // 大于5，小于total-3, total至少为11，因为total为10的情况上面已经全部覆盖了
  pageList.push(1);
  pageList.push('...');

  for (let i = curPage - 2;i <= curPage + 2; i++) {
    pageList.push(i);
  }

  pageList.push('...');
  pageList.push(totalPage);
  this.showPageList = pageList;
}
```




### 101. Vue3新特性 

#### ref、reactive

ref和reactive都可以给数据添加响应性，ref一般用于给js基本数据类型添加响应性（当然也支持非基本类型的object），reactive只能用于代理非基本数据类型。null是基本数据类型，只能使用ref，那既然如此，为什么不在所有情况都使用ref呢？


```js
const num = ref(0);
num.value = 1;

const obj = { a: 1 };
const refObj = ref(obj);
const reactiveObj = reactive(obj);

refObj.value.a = 2;
reactiveObj.a = 3;
console.log(num, refObj, reactiveObj);
```

使用ref api时，数据变成了对象，值就是value属性的值，如果数据本身就是对象，依然会多一层value结构，而reactive没有这些副作用。

#### toRefs

因为响应式对象，经过解构出来的属性不再具有响应性，toRefs就是为了快速获得响应性的属性，因此这段代码`const { init } = toRefs(props);`，就是为了获得响应式属性init，想要保留props参数的响应性，建议这么做。



#### watch、watchEffect
```js
const num = ref(0);
const state = reactive({
  num: 0,
});
const obj = { num: 0 };

watch(num, (newVal, oldVal) => {
  console.log("num", newVal, oldVal);
});
watch(() => state.num, (newVal, oldVal) => {
  console.log("num", newVal, oldVal);
});
watch(() => obj.num, () => {
  console.log("这里不会执行");
});

num++;
state.num++;
obj.num++;
```
watch api，它需要接受一个具有返回值的getter函数或者ref（如() => state.num，ref）。

如果需要监听多个值，如下所示：
```js
const num1 = ref(0);
const num2 = ref(0);

watch([num1, num2], ([newNum1, newNum2], [prevNum1, prevNum2]) => {
  console.log([newNum1, newNum2], [prevNum1, prevNum2]);
});

num1.value = 1; // [1, 0], [0, 0]
num2.value = 2; // [1, 2], [1, 0]
```

可见多个数据的每次更新都会触发watch。想要监听一个嵌套的对象，跟Vue2一样，依旧需要使用deep选项，如下所示：

```js
const state = reactive({
  attr: {
    id: 1,
  },
});

watch(() => state, (currState, prevState) => {
  console.log(currState.attr.id, prevState.attr.id, currState === prevState, currState === state); // 2, 2, true, true
}, { deep: true });

watch(() => state.attr.id, (currId, prevId) => {
  console.log(currId, prevId); // 2, 1
});
state.attr.id = 2;
```


看到差别了吗？监听响应式对象时，返回的是对象的引用，因此currState，prevState指向是同一个最新的state，如果需要获取变化前的值，建议返回监听的属性，如watch(() => state.attr.id)，刚好state.attr.id是一个基本类型的值，那么deep也不需要。

watchEffect是Vue3新增的api，watchEffect会自动运行一次，用于自动收集依赖，但不支持获取变化前的值，除此之外，与watch用法一致。那么watchEffect适用什么场景呢？这也是我刚上手Vue3的困惑之一。我们来看一段代码：

```
const rights = {
  admin: ["read", "write"],
  user: ["read"],
};
const state = reactive({
  rights: "",
})

const userInfo = reactive({ role: "user" });
userInfo.name = "Tom";
userInfo.role = "admin";

watch(() => userInfo.role, (newVal, oldVal) => {
  state.rights = rights[newVal];
});

watchEffect(() => {
  state.rights = rights[userInfo.role];
});
```
以上代码中，watch中的逻辑只能在userInfo变化后执行，因此state.rights不会提供初始值，相反，watchEffect中state.rights由于自动依赖收集，获得了一次赋值的机会。

这样做的好处是什么呢？在实际项目中，userInfo.role可能是一个全局store中的数据，用户登录进来后，就会通过接口获取初始值，我们并不能确认，用户进到其中一个页面时，userInfo.role的值是否已经被接口更新，且userInfo变化前的值我们也不关心，watchEffect就非常适合这种场景，它会自动进行一次初始化，并且在变化后，及时更新值。

watch和watchEffect的监听会在组件销毁时自动取消，除此之外，可以通过它们返回的函数手动取消监听，如下所示：
```js
const stopWatch = watch(selectRef, (newVal, oldVal){});
const stopWatchEffect = watchEffect(selectRef, (newVal, oldVal){});

setTimeout(stopWatch, 1000);
setTimeout(stopWatchEffect, 1000);
```

#### 生命周期函数的执行顺序

```
setup -> beforeCreate -> created -> setup.onBeforeMount -> beforeMount -> setup.onMounted...
```

#### vue3中的setup方法可以接收两个参数props和context


1. props就是传过来的props，props不能进行ES6的解构，因为这会消除响应式。
2. context上有emit方法，因为setup没有this了(原因是setup执行时，组件实例没有创建)，所以可以用context.emit进行事件的传递




#### Vite和Webpack的区别


                                                                  

1. webpack的模式是先进行打包再启动开发服务。
2. Vite是启动服务请求哪个模块再对该模块进行编译。

很明显 Vite充分利用浏览器支持ES Module的特性，浏览器会自动像依赖的Module发出请求，将开发环境下的模块文件，就作为浏览器要执行的文件，而不是像webpack那样进行打包合并。

Vite在启动的时候不需要进行打包，就意味着不需要分析模块的依赖以及编译，因此启动速度非常快。

当浏览器请求某个模块时按需进行编译。

这种按需动态编译的方式，极大的缩减了启动时间，项目越复杂、模块越多，vite的优势越明显。



### 102. PNG图片压缩原理


#### 什么是PNG

PNG的全称叫便携式网络图型（Portable Network Graphics）是目前最流行的网络传输和展示的图片格式，原因有如下几点：

- 无损压缩：PNG图片采取了基于LZ77派生算法对文件进行压缩，使得它压缩比率更高，生成的文件体积更小，并且不损失数据。

- 体积小：它利用特殊的编码方法标记重复出现的数据，使得同样格式的图片，PNG图片文件的体积更小。网络通讯中因受带宽制约，在保证图片清晰、逼真的前提下，优先选择PNG格式的图片。

- 支持透明效果：PNG支持对原图像定义256个透明层次，使得图像的边缘能与任何背景平滑融合，这种功能是GIF和JPEG没有的。


#### PNG类型

PNG图片主要有三个类型，分别为 `PNG 8/ PNG 24 / PNG 32`。


- PNG 8：PNG 8中的8，其实指的是8bits，相当于用`2^8`（2的8次方）大小来存储一张图片的颜色种类，`2^8`等于256，也就是说PNG 8能存储256种颜色，一张图片如果颜色种类很少，将它设置成PNG 8得图片类型是非常适合的。


- PNG 24：PNG 24中的24，相当于3乘以8 等于 24，就是用三个8bits分别去表示 R（红）、G（绿）、B（蓝）。`R(0~255),G(0~255),B(0~255)`，可以表达256乘以256乘以256=16777216种颜色的图片，这样PNG 24就能比PNG 8表示色彩更丰富的图片。但是所占用的空间相对就更大了。


- PNG 32：PNG 32中的32，相当于PNG 24 加上 8bits的透明颜色通道，就相当于R（红）、G（绿）、B（蓝）、A（透明）。`R(0~255),G(0~255),B(0~255),A(0~255)`。比PNG 24多了一个A（透明），也就是说PNG 32能表示跟PNG 24一样多的色彩，并且还支持256种透明的颜色，能表示更加丰富的图片颜色类型。


#### PNG图片数据结构

PNG图片的数据结构其实跟http请求的结构很像，都是一个数据头，后面跟着很多的数据块。

#### 什么样的PNG图片更适合压缩

常规的png图片，颜色越单一，颜色值越少，压缩率就越大。



#### PNG的压缩

PNG图片的压缩，分两个阶段：

- 预解析（Prediction）：这个阶段就是对png图片进行一个预处理，处理后让它更方便后续的压缩。
- 压缩（Compression）：执行Deflate压缩，该算法结合了 LZ77 算法和 Huffman 算法对图片进行编码。



参考：[PNG图片压缩原理解析](https://juejin.cn/post/6844903798658318343)



### 103. lighthouse 性能检测工具


####  First Contentful Paint (FCP)
第一次内容丰富的绘画(FCP)指标衡量了从页面开始加载到页面内容的任何部分呈现在屏幕上的时间。对于该指标，"内容 "指的是文本、图像（包括背景图像）、元素或非白色元素。

虽然部分内容已经呈现，但并非所有内容都已呈现。这是First Contentful Paint (FCP)和Largest Contentful Paint (LCP)之间的一个重要区别--LCP的目的是衡量页面的主要内容何时完成加载。

####   Largest Contentful Paint (LCP)
最大内容画（LCP）指标报告了在视口中可见的最大图像或文本块的渲染时间，相对于页面首次开始加载的时间。

为了提供良好的用户体验，网站应该努力使最大内容画幅达到2.5秒或更少。

####  Cumulative Layout Shift (CLS)
官方对它的解释:

>Cumulative Layout Shift (CLS)是一种视觉稳定性的测量方法，它量化了页面内容在视觉上的移动程度。它量化了一个页面的内容在视觉上移动的程度。


### 104. performance.now()和Date.now()的区别是什么


- performance.now()是相对于页面加载和数量级更精确，单位是毫秒。具有小数点，从`page load`的时候从零开始计数。约等于 `Date.now()-performance.timing.navigationStart`
- Date.now()是相对于Unix时代(`1970-01-01T00：00：00Z`)并且依赖于系统时钟。


### 105. 负载均衡常用算法

1、轮询
   遍历服务器节点列表，并按节点次序每轮选择一台服务器处理请求。当所有节点均被调用过一次后，该算法将从第一个节点开始重新一轮遍历。
  特点：适用于服务器性能相近的集群情况，其中每个服务器承载相同的负载。对于服务器性能不同的集群而言，该算法容易引发资源分配不合理等问题。

2、加权轮询
  每个服务器会有各自的 weight。一般情况下，weight 的值越大意味着该服务器的性能越好，可以承载更多的请求。该算法中，客户端的请求按权值比例分配，当一个请求到达时，优先为其分配权值最大的服务器。
   特点：加权轮询可以应用于服务器性能不等的集群中，使资源分配更加合理化。

3、IP hash
  ip_hash 依据发出请求的客户端 IP 的 hash 值来分配服务器，该算法可以保证同 IP 发出的请求映射到同一服务器，或者具有相同 hash 值的不同 IP 映射到同一服务器。
  特点：该算法在一定程度上解决了集群部署环境下 Session 不共享的问题。

4、URL hash
  url_hash 是根据请求的 URL 的 hash 值来分配服务器。该算法的特点是，相同 URL 的请求会分配给固定的服务器，当存在缓存的时候，效率一般较高。然而 Nginx 默认不支持这种负载均衡算法，需要依赖第三方库。

5、最小连接数
  当有新的请求出现时，遍历服务器节点列表并选取其中连接数最小的一台服务器来响应当前请求。连接数可以理解为当前处理的请求数。



#### Node服务器代码

```js
const express = require('express');
const app = express();

// 定义要监听的端口号
const listenedPort = '8087';

app.get('/', (req, res) => res.send(`Hello World! I am port ${listenedPort}～`));

// 监听端口
app.listen(listenedPort, () => console.log(`success: ${listenedPort}`));
```

#### Ngnix配置



- 轮询的服务器，写在 http 中的 upstream 对象里：
```
upstream testServer {
  server localhost:8087 weight=10;
  server localhost:8088 weight=2;
  server localhost:8089;
}
```

- 代理地址，写在 http 中的 server 对象里：

```
location / {
  root   html;
  index  index.html index.htm;
  proxy_pass http://testServer; // testServer 为自己定义的服务器集群
}	
```

参考：[五分钟看懂 Nginx 负载均衡](https://juejin.cn/post/6844904106541203464)


### 106. requestAnimationFrame


与 setTimeout 相比，rAF 最大的优势是**由系统来决定回调函数的执行时机**。具体一点讲就是，系统每次绘制之前会主动调用 rAF 中的回调函数，如果系统绘制率是 60Hz，那么回调函数就每16.7ms 被执行一次，如果绘制频率是75Hz，那么这个间隔时间就变成了 1000/75=13.3ms。换句话说就是，rAF 的执行步伐跟着系统的绘制频率走。它能保证回调函数在屏幕每一次的绘制间隔中只被执行一次，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。

requestAnimationFrame采用系统时间间隔，保持最佳绘制效率，**不会因为间隔时间过短，造成过度执行，增加开销；也不会因为间隔时间太长，使用动画卡顿不流畅**，让各种网页动画效果能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果。

另外一个特点是，**在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流**，这当然就意味着更少的的cpu，gpu和内存使用量。


使用方法：

```js
varprogress = 0;
//回调函数
function render() {
    progress += 1;//修改图像的位置
 
    if(progress < 100) {
           //在动画没有结束前，递归渲染
           window.requestAnimationFrame(render);
    }
}
 
//第一帧渲染
window.requestAnimationFrame(render);
```

参考：[requestAnimationFrame 知多少？](https://www.cnblogs.com/onepixel/p/7078617.html)


### 107. window.location.href="javascript:void(0)"不会跳转


### 108. Vue的分页组件


```vue
<!-- eslint-disable max-len -->
<template>
  <div class="page">
    <a
      :class="curPage == 1 ? 'disable': ''"
      @click="onGetPrePage"
    >上一页</a>

    <span
      v-for="(item, index) of showPageList"
      :key="index"
      :class="{on: item == curPage, 'more-page': item === '...' && index!=1, 'back-more-page': item === '...' && index == 1}"
      @click="onChangePage(item, index)"
    >{{ item }}</span>
    <a
      :class="totalPage != 1 && curPage == totalPage ? 'disable': ''"
      @click="onGetNextPage"
    >下一页</a>
  </div>
</template>
<script>
export default {
  props: {
    curPage: {
      type: Number,
      default: 1,
    },
    totalPage: {
      type: Number,
      default: 1,
    },
  },
  data() {
    return {
      showPageList: [],
    };
  },
  watch: {
    totalPage() {
      this.onChangePageList();
    },
    curPage() {
      this.onChangePageList();
    },
  },
  methods: {
    // 改变页码
    onChangePage(page, index) {
      if (page == this.curPage) {
        return;
      }
      if (page === '...') {
        if (index === 1) {
          // 点击前一个...
          const page = this.curPage - 5 < 1 ? 1 : this.curPage - 5;
          this.$emit('changePage', page);
        } else {
          // 点击后一个...
          const page = this.curPage + 5  > this.totalPage ? this.totalPage : this.curPage + 5;
          this.$emit('changePage', page);
        }
      } else {
        this.$emit('changePage', page);
      }
    },
    // 点击上一页
    onGetPrePage() {
      if (this.curPage <= 1) {
        return;
      }
      this.$emit('changePage', this.curPage - 1);
    },
    // 点击下一页
    onGetNextPage() {
      if (this.curPage >= this.totalPage) {
        return;
      }
      this.$emit('changePage', this.curPage + 1);
    },
    // 根据curPage和totalPage改变展示的pageList
    onChangePageList() {
      const { curPage, totalPage } = this;
      const pageList = [];
      // 总数小于等于8
      if (totalPage <= 8) {
        for (let i = 1;i < totalPage + 1 ; i++) {
          pageList.push(i);
        }
        this.showPageList = pageList;
        return;
      }
      // 当前小于等于4
      if (curPage <= 4) {
        for (let i = 1;i <= 6; i++) {
          pageList.push(i);
        }
        pageList.push('...');
        pageList.push(totalPage);
        this.showPageList = pageList;
        return;
      }
      // 当前大于等于totalPage-3
      if (curPage >= totalPage - 3) {
        pageList.push(1);
        pageList.push('...');
        for (let i = totalPage - 5;i <= totalPage; i++) {
          pageList.push(i);
        }
        this.showPageList = pageList;
        return;
      }
      // 大于5，小于total-3, total至少为11，因为total为10的情况上面已经全部覆盖了
      pageList.push(1);
      pageList.push('...');

      for (let i = curPage - 2;i <= curPage + 2; i++) {
        pageList.push(i);
      }

      pageList.push('...');
      pageList.push(totalPage);
      this.showPageList = pageList;
    },
  },
};
</script>
```

分页组件的几种边界：
1. totalPage <= 8时，展示全部
  
  <img src="https://user-images.githubusercontent.com/41728540/117237040-9f6ee000-ae5c-11eb-8022-c2bc4d4139c7.png" width="420" />

2. curPage <= 4时，展示前6个、...、最后一个

  <img src="https://user-images.githubusercontent.com/41728540/117236303-04293b00-ae5b-11eb-986c-3c58dbd415d3.png" width="420" />

3. curPage >= totalPage - 3 ，展示第一个、...、最后6个

<img src="https://user-images.githubusercontent.com/41728540/117236361-1c995580-ae5b-11eb-9b1c-cba3ca92a2ba.png" width="420" />

4. 其他情况，展示第一个、...、curPage-2、curPage-1、curPage、curPage+1、curPage+2、...、最后一个

<img src="https://user-images.githubusercontent.com/41728540/117236352-1905ce80-ae5b-11eb-9f1e-a2d0ebeae424.png" width="420" />


### 109. 自动化测试


#### browser.pages()

puppeteer中，`browser.pages()`获取到的`page`在不激活的情况下，无法执行`tap`、`click`等事件，需要新建个tab

#### 自动化测试可以分为两类：接口自动化、UI自动化

#### UI 测试（UI Test）和端到端测试（E2E Test）是稍有区别的

1. UI 测试（UI Test）只是对于前端的测试，是脱离真实后端环境的，仅仅只是将前端放在真实环境中运行，而后端和数据都应该使用 Mock 的。
2. 端到端测试（E2E Test）则是将整个应用放到真实的环境中运行，包括数据在内也是需要使用真实的。

#### 前端测试主要分为 3 种：单元测试（Unit Test）、集成测试（Integration Test）、UI 测试（UI Test）

集成测试通常被应用在：耦合度较高的函数/组件、经过二次封装的函数/组件、多个函数/组件组合而成的函数/组件等。

集成测试的目的在于，测试经过单元测试后的各个模块组合在一起是否能正常工作。会对组合之后的代码整体暴露在外接口进行测试，查看组合后的代码工作是否符合预期



#### 端到端测试

端到端测试，除了软件系统，它还验证来自其他上游/下游系统的批处理/数据处理。因此，被称为 "端到端"。

#### eptest相关

1. 必须加describe才能正确解析用例
2. 失败用例前要加注解，注明用例管理者，并且不能是debug模式，才会收到失败通知


### 110. Vuex和Redux


#### Vuex 处理异步操作
vuex中，mutation是同步的，用commit提交；action是异步的，用dispatch派发

- 同步操作：commit mutation -> 修改state
- 异步操作：`dispatch action` -> `commit mutation` -> 修改state


#### Vuex 和 Redux 核心概念对比

| Redux 的核心概念                                                                                   | Vuex 的核心概念                                                    |
| -------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------ |
| action （同步action ，或借助 中间件 实现异步操作，action 不会改变 store，只是描述了怎么改变store） | mutation（用于同步操作） 、action（可用于异步操作，提交 mutation） |
| reducer（纯函数，根据 action 和旧的 store 计算出新的 store                                         | mutation里面直接修改 state                                         |
| store（单一数据源）                                                                                | state（单一数据源）                                                |



#### Redux处理异步操作

Redux 得益于 中间件机制，利用 redux-thunk ，可以将异步逻辑放在  action creator 里面，通过 action creator 做一个控制反转， 给 action creator 传入 dispatch 作为参数，于是就可以 dispatch  action。

>redux-thunk 可以 dispatch 函数，这个函数用于生成 action，所以在这个函数里面我们可以进行异步操作，等异步的结果出来后再放在 action 里面将这个 action 用 dispatch 分发出去, 而这个函数被叫做 “action creator” 。

>原本是通过 dispatch 来分发 action ,现在是异步 action 即 action creator 掌握了控制权调用 dispatch，所以叫控制反转。

- 同步action: dispatch action -> reducer -> 新state
- 异步action：dispatch -> action creator -> dispatch action -> reducer -> 新state





#### 参考
1. [Redux 和 Vuex 的对比](https://juejin.cn/post/6844903929063424013)
2. [一篇文章总结redux、react-redux、redux-saga](https://juejin.cn/post/6844903846666321934)


### 111. first-child、first-of-type，last-child、last-of-type，nth-child(n)、nth-of-type(n)的区别


使用p:first-child生效要满足两个条件：

1. `p`被同一个父元素包裹
2. 该父元素的第一个元素就是`p`元素

同理，使用p:last-child生效要满足两个条件：

1. `p`被同一个父元素包裹 
2. 该父元素的最后一个元素就是`p`元素

```html
<div id="wrap">
<a></a>
<p></p>
</div>
```
```css
#wrap p:first-child{}
```
是取不到上面的p元素的
可以用

```css
#wrap p:first-of-type{}
```

结论：

1. :first-child 匹配的是某父元素的第一个子元素，可以说是结构上的第一个子元素。
2. :first-of-type 匹配的是某父元素下相同类型子元素中的第一个，比如 p:first-of-type，就是指所有类型为p的子元素中的第一个。这里不再限制是第一个子元素了，只要是该类型元素的第一个就行了。

同样类型的选择器 :last-child  和 :last-of-type、:nth-child(n)  和  :nth-of-type(n) 也可以这样去理解。


### 112. 在console面板上打印vue实例

一种方法是**将vue实例挂在window对象下**，比如`window.app=new Vue()`，然后可以在console中打印`window.app`。

还有一种是，Vue 组件挂载成功后会在根节点 DOM 实例上挂一个 `__vue__` 对象，所以有时候并不一定为了好调试而非要把 new Vue() 的实例赋给 window.app 什么的。**直接在 console 上用 $0 表示当前高亮的节点，然后通过 `__vue__` 就能找到组件实例了**



### 113. bash打包上传，远程监控文件变化并部署




 远程监控

#### mon.deploy.sh文件

```bash
#!/bin/sh
# monitor and deploy bash file

set -eux

src=/root/ft_local/chat-robot.tar.gz

/usr/bin/inotifywait -rmq --timefmt '%Y-%m-%d %H:%M:%S' --format '%T %w%f %e' \
 -e "create,delete,close_write,attrib,moved_to" $src |  while read  event
do
echo $event;
bash ./deploy.sh
done
```

#### deploy.sh文件

```bash
#!/bin/sh

set -eux

dirName=chat-robot
zipFileName=${dirName}.tar.gz


ls ./ft_local -l
tar -zxf ./ft_local/$zipFileName -C $dirName

cd $dirName
ls -lh

npm install
# npm run dev
pm2 restart $dirName
```


### 114. nginx 配置反向代理 `proxy_pass http:/127.0.0.1:3066/` 最后一定要加斜杠


### 115. 关闭浏览器或者关闭网页窗口的时候，需要移除token，但是destroyed与beforeDestroy钩子不生效


关闭浏览器或者关闭网页窗口的时候，需要移除token
在 App.vue挂载的时候，加上这个方法，浏览器关闭动作的事件

```js
mounted () {
  window.addEventListener('beforeunload', () => {
  localStorage.removeItem('token')
  localStorage.removeItem('user')
  });
},
```
vue的生命钩子函数destroyed与beforeDestroy只能在页面切换的时候才能检测到,关闭浏览器的时候，拿不到摧毁组件的事件，所以无效


### 116. 如何根据进入链接不同，始终显示不同的列表？



sessionstorage一刷新，参数就丢了，如果不舍弃，那如果又从其他链接进入又会有问题。所以， 唯一刷新还保留数据的还是url参数，所有始终将用户点击时的参数保留。在`router.afterEach`中，增加：
```js
if (to.query.qq === undefined) {
      app.$router.replace({
        query: {
          ...to.query,
          qq: parseInt(from.query.qq || 0, 10) ? 1 : 0,
        },
      });
    }
```


### 117. koa框架


router里面的`await next()`，前面有了`ctx.body=''`，后面再写`ctx.body='about'`会覆盖前面的`ctx.body`；
而`return`语句后面的`ctx.body`不会覆盖之前的返回；
如果既没有`await next()`，也没有`return`，则后一个`ctx.body`会覆盖前面的。

结论：只有`return`，才会截断。


### 118. CSS相关


#### filter的hue-rotate


```css
hue-rotate(90deg)   /* 90度旋转 */
hue-rotate(.5turn)       /* 180度旋转 */
hue-rotate(3.142rad)     /* 3.142弧度旋转，近似一圈，也就是360度 */
```

#### CSS之linear-gradient

##### 1. 语法

```css
background-image: linear-gradient(direction, color-stop1, color-stop2, ...);
```



##### 2. 例子-渐变文本
![shine-words](https://user-images.githubusercontent.com/41728540/111406737-c6871c00-870d-11eb-95ef-04e872e538b8.gif)

渐变文本关键：
```css
-webkit-background-clip: text
background-image: linear-gradient(...);
```

##### 3. 例子-波浪线

<img width="154" alt="wave-word" src="https://user-images.githubusercontent.com/41728540/111407349-a60b9180-870e-11eb-98df-86413376d8fe.png">

波浪线的核心代码：

```css
 background:
        linear-gradient(135deg, transparent, transparent 45%, #008000, transparent 55%, transparent 100%),
        linear-gradient(45deg, transparent, transparent 45%, #008000, transparent 55%, transparent 100%);
background-size: 1em 1em;
background-repeat: repeat-x, repeat-x;
height: 0.5rem;
```

原理是，一个135度的线和一个45度的线交叉，同时`background-size`的宽和高都是`height`的2倍

`linear-gradient`中度数的意思，0度指向上，45度指向右，不填的话，默认其实是180度，指向下。




#### CSS之蛇形边框

蛇形边框运用了clip属性，clip属性只能用在`position: absolute`或者`position: fixed`元素上。

clip常见用法：`clip: rect (top, right, bottom, left)`;

蛇形边框的本质是，在矩形周围，用一圈圈的线围绕，然后给它们`animation`。




参考：[CSS Clip属性](https://www.cnblogs.com/tianma3798/p/5862126.html)


#### CSS之box-shadow详解

box-shadow有5个属性值offset-x、offset-y、blur-radius、spread-radius、color

- blur-radius：模糊距离，值越大，就越模糊。blur半径值大于0时会扩展阴影尺寸
- spread-radius：阴影大小


参考：
- [三维视角解析box-shadow](https://blog.csdn.net/qq_40574071/article/details/94326686)
- [详解box-shadow](https://zhuanlan.zhihu.com/p/96747540)


#### div中img有间隙的解决方法：line-height: 0

##### 方案

方案1，给img 设置为display：block

```css
img{
  display:block
}
```

第二种办法就是给外层的div添加line-height 设置为0 （none）也一样

```css
div{
  line-height:0;
}
```

##### 为什么line-height设置为0就可以消除img下面多余的空白呢？

猜测是默认的 line-height 撑开了div的高度。

类似的应用场景还有 [父元素line-height设为0后，inline-block的空元素终于安分了](https://segmentfault.com/a/1190000007661072)


####  line-height的理解

行高是指文本行基线间的垂直距离。 基线（base line）并不是汉字文字的下端沿，而是英文字母“x”的下端沿。下图中两条红线之间的距离就是行高，上行的底线和下一行顶线之间的距离就是行距，而同一行顶线和底线之间的距离是font-size的大小，行距的一半是半行距。

![line-height.png](https://github.com/novlan1/technical-blog/blob/main/imgs/line-height.png?raw=true)

##### font-size和line-height的关系
![line-height.png](https://github.com/novlan1/technical-blog/blob/main/imgs/line-height2.png?raw=true)

- 当font-size等于line-height时，行距 = line-height - font-size = 0；
- 而当font-size大于line-height时，则会出现行距为负值，则两行重叠，如下图

![line-height.png](https://github.com/novlan1/technical-blog/blob/main/imgs/line-height3.png?raw=true)
 

设置div的高度时，是div的font-size决定了div的高度还是line-weight的值。
- 试验发现是，line-height。

div的height与line-height的大小关系不同时，会有什么显示结果呢？
- height=line-height时，垂直居中
- height > line-height时，文字靠上
- height < line-height时，文字靠下



参考：
1. [css行高line-height的一些深入理解及应用](https://www.zhangxinxu.com/wordpress/2009/11/css%E8%A1%8C%E9%AB%98line-height%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8F%8A%E5%BA%94%E7%94%A8/)
2. [真正理解CSS中的font-size，height与line-height](https://blog.csdn.net/a2013126370/article/details/82786681)


#### css中，:after中`content: "...\a..\a." `的`\a`可以起到换行的作用

css中 `:after`中 `content: "...\a..\a." `的`\a`可以起到换行的作用

实现加载中`...`效果的一个方法是：

```css
animation: loading 3s infinite step-start both;

@keyframes loading {
 33% {
  transform: translate3d(0, -2em, 0);
 }
 66% {
  transform: translate3d(0, -1em, 0);
 }
}
```

#### CSS white-space 属性

white-space 属性设置如何处理元素内的空白。

| normal   | 默认。空白会被浏览器忽略。                                       |
| -------- | ---------------------------------------------------------------- |
| pre      | 空白会被浏览器保留。其行为方式类似 HTML 中的 \<pre\> 标签。      |
| nowrap   | 文本不会换行，文本会在在同一行上继续，直到遇到 \<br\> 标签为止。 |
| pre-wrap | 保留空白符序列，但是正常地进行换行。                             |
| pre-line | 合并空白符序列，但是保留换行符。                                 |
| inherit  | 规定应该从父元素继承 white-space 属性的值。                      |


white-space中 pre pre-line pre-wrap的区别？

pre-line与pre-wrap都会自动换行，但pre-line会把多个空格合并成一个，而pre-wrap会保留空格。



#### VSCode中Live Sass Compiler和Live Server两个插件


Live Sass Compiler用于实时编译sass/scss文件为css文件。

Live Server用于启动具有实时刷新功能的本地开发服务器，以处理静态页面和动态页面。


#### CSS3 [attribute*=value] 选择器

实例：

设置 class 属性值包含 "test" 的所有 div 元素的背景色：

```css
div[class*="test"] {
  background:#ffff00;
}
```

参考： [CSS3 [attribute*=value] 选择器](https://www.w3school.com.cn/cssref/selector_attr_contain.asp)



### 119. IoC 


#### 什么是IoC

IoC 的全称叫做 `Inversion of Control`，可翻译为为「控制反转」或「依赖倒置」，它主要包含了三个准则：

- 高层次的模块不应该依赖于低层次的模块，它们都应该依赖于抽象
- 抽象不应该依赖于具体实现，具体实现应该依赖于抽象
- 面向接口编程 而不要面向实现编程



```js
class App {
    constructor(options) {
        this.options = options;
        this.router = new Router();
        this.track = new Track();

        this.init();
    }

    init() {
        window.addEventListener('DOMContentLoaded', () => {
            this.router.to('home');
            this.track.tracking();
            this.options.onReady();
        });
    }
}

// index.js
import App from 'path/to/App';
new App({
    onReady() {
        // do something here...
    },
});
```
如果需要给路由新增功能（比如实现 `history` 模式）或者更新配置（启用 `history, new Router({ mode: 'history' })`）。这就不得不在 App 内部去修改这两个模块

这不是一个好的应用结构，高层次的模块 App 依赖了两个低层次的模块 Router 和 Track，对低层次模块的修改都会影响高层次的模块 App。

#### 依赖注入
依赖注入，就是**把高层模块所依赖的模块通过传参的方式把依赖「注入」到模块内部**。

```js
// app.js
class App {
    constructor(options) {
        this.options = options;
        this.router = options.router;
        this.track = options.track;

        this.init();
    }

    init() {
        // ...
    }
}

// index.js
import App from 'path/to/App';
import Router from './modules/Router';
import Track from './modules/Track';

new App({
    router: new Router(),
    track: new Track(),
    onReady() {
        // do something here...
    },
});
```

虽然 App 通过依赖注入的方式在一定程度上解耦了与其他几个模块的依赖关系，但是还不够彻底，其中的 `this.router` 和 `this.track` 等属性其实都还是对「具体实现」的依赖，明显违背了 IoC 思想的准则，那如何进一步抽象 App 模块呢。

```js
class App {
    static modules = []
    constructor(options) {
        this.options = options;
        this.init();
    }
    init() {
        window.addEventListener('DOMContentLoaded', () => {
            this.initModules();
            this.options.onReady(this);
        });
    }
    static use(module) {
        Array.isArray(module) ? module.map(item => App.use(item)) : App.modules.push(module);
    }
    initModules() {
        App.modules.map(module => module.init && typeof module.init == 'function' && module.init(this));
    }
}
```
App.use 做了一件非常简单的事情，就是把依赖保存在了 App.modules 属性中，等待后续初始化模块的时候被调用。

`this.initModules()`方法同样做了一件非常简单的事情，就是遍历 App.modules 中所有的模块，判断模块是否包含 init 属性且该属性必须是一个函数，如果判断通过的话，该方法就会去执行模块的 init 方法并把 App 的实例 this 传入其中，以便在模块中引用它。

从这个方法中可以看出，要实现一个可以被 `App.use()` 的模块，就必须满足两个「约定」：

1. 模块必须包含 init 属性
2. init 必须是一个函数

这其实就是 IoC 思想中对「面向接口编程 而不要面向实现编程」这一准则的很好的体现。App 不关心模块具体实现了什么，只要满足对 接口 init 的「约定」就可以了。

经过改造后 App 内已经没有「具体实现」了，看不到任何业务代码了，那么如何使用 App 来管理我们的依赖呢：

```js
// modules/Router.js
import Router from 'path/to/Router';
export default {
    init(app) {
        app.router = new Router(app.options.router);
        app.router.to('home');
    }
};
// modules/Track.js
import Track from 'path/to/Track';
export default {
    init(app) {
        app.track = new Track(app.options.track);
        app.track.tracking();
    }
};

// index.js
import App from 'path/to/App';
import Router from './modules/Router';
import Track from './modules/Track';

App.use([Router, Track]);

new App({
    router: {
        mode: 'history',
    },
    track: {
        // ...
    },
    onReady(app) {
        // app.options ...
    },
});
```

可以发现 App 模块在使用上也非常的方便，通过 `App.use()` 方法来「注入」依赖，在 `./modules/some-module.js` 中按照一定的「约定」去初始化相关配置，比如此时需要新增一个 Share 模块的话，无需到 App 内部去修改内容：

#### 总结

App 模块此时应该称之为「容器」比较合适了，跟业务已经没有任何关系了，它仅仅只是提供了一些方法来辅助管理注入的依赖和控制模块如何执行。
控制反转（`Inversion of Control`）是一种「思想」，依赖注入（`Dependency Injection`）则是这一思想的一种具体「实现方式」，而这里的 App 则是辅助依赖管理的一个「容器」。


### 120. AMD、UMD、CJS、ESM的区别


#### 不同打包模式的区别
##### 1. CJS

`CJS` 是 `CommonJS` 的缩写。经常我们这么使用：

```js
// importing 
const doSomething = require('./doSomething.js'); 

// exporting
module.exports = function doSomething(n) {
  // do something
}
```

- 很多人可以从 Node 中立刻认出 `CJS` 的语法。这是因为 `Node` 就是使用 `CJS` 模块的
- `CJS` 是同步导入模块
- 你可以从 `node_modules` 中引入一个库或者从本地目录引入一个文件 。如 `const myLocalModule = require('./some/local/file.js')` 或者 `var React = require('react');` ，都可以起作用
- 当 `CJS` 导入时，它会给你一个导入对象的副本
- `CJS` 不能在浏览器中工作。它必须经过转换和打包


##### 2. AMD

AMD 代表异步模块定义。下面是一个示例代码

```js
define(['dep1', 'dep2'], function (dep1, dep2) {
    //Define the module value by returning a value.
    return function () {};
});
```
或者

```js
// "simplified CommonJS wrapping" https://requirejs.org/docs/whyamd.html
define(function (require) {
    var dep1 = require('dep1'),
        dep2 = require('dep2');
    return function () {};
});
```

- `AMD` 是异步(`asynchronously`)导入模块的(因此得名)
- 一开始被提议的时候，`AMD` 是为前端而做的(而 `CJS` 是后端)
- `AMD` 的语法不如 `CJS` 直观。我认为 `AMD` 和 `CJS` 完全相反


##### 3. UMD

`UMD` 代表通用模块定义（`Universal Module Definition`）。下面是它可能的样子

```js
(function (root, factory) {
    if (typeof define === "function" && define.amd) {
        define(["jquery", "underscore"], factory);
    } else if (typeof exports === "object") {
        module.exports = factory(require("jquery"), require("underscore"));
    } else {
        root.Requester = factory(root.$, root._);
    }
}(this, function ($, _) {
    // this is where I defined my module implementation

    var Requester = { // ... };

    return Requester;
}));
```

- 在前端和后端都适用（“通用”因此得名）
- 与 `CJS` 或 `AMD` 不同，`UMD` 更像是一种配置多个模块系统的模式。这里可以找到更多的模式
- 当使用 `Rollup/Webpack` 之类的打包器时，`UMD` 通常用作备用模块

##### 4. ESM

`ESM` 代表 `ES` 模块。这是 `Javascript` 提出的实现一个标准模块系统的方案。我相信你们很多人都看到过这个:

```js
import React from 'react';
// 或者
import {foo, bar} from './myLib';

export default function() {
  // your Function
};
export const function1() {...};
export const function2() {...};
```

- 在很多现代浏览器可以使用
- 它兼具两方面的优点：具有 `CJS` 的简单语法和 `AMD` 的异步
- 得益于 `ES6` 的静态模块结构，可以进行  `Tree Shaking`
- `ESM` 允许像 `Rollup` 这样的打包器，删除不必要的代码，减少代码包可以获得更快的加载
- 可以在 `HTML` 中调用，只要如下

```html
<script type="module">
  import {func1} from 'my-lib';

  func1();
</script>
```

但是不是所有的浏览器都支持


#### 总结

- 由于 `ESM` 具有简单的语法，异步特性和`tree-shaking`特性，因此它是最好的模块化方案
- `UMD` 随处可见，通常在 ESM 不起作用的情况下用作备用
- `CJS` 是同步的，适合后端
- `AMD` 是异步的，适合前端


#### 相关资料

- [What are CJS, AMD, UMD, and ESM in Javascript?](https://dev.to/iggredible/what-the-heck-are-cjs-amd-umd-and-esm-ikm)
- [【面试说】Javascript 中的 CJS, AMD, UMD 和 ESM是什么？](https://juejin.cn/post/6935973925004247077)
- [聊聊 package.json 文件中的 module 字段](https://juejin.cn/post/6844903569150197774)


### 121. eslint规则

- “off” 或 0 - 关闭规则
- “warn” 或 1 - 开启规则，使用警告级别的错误：warn (不会导致程序退出)
- “error” 或 2 - 开启规则，使用错误级别的错误：error (当被触发的时候，程序会退出)


### 122. IoC

IoC 的全称叫做 Inversion of Control，可翻译为为「控制反转」或「依赖倒置」，它主要包含了三个准则：

1. 高层次的模块不应该依赖于低层次的模块，它们都应该依赖于抽象
2. 抽象不应该依赖于具体实现，具体实现应该依赖于抽象
3. 面向接口编程 而不要面向实现编程

依赖注入，就是把高层模块所依赖的模块通过传参的方式把依赖「注入」到模块内部。

```js
class App {
    static modules = []
    constructor(options) {
        this.options = options;
        this.init();
    }
    init() {
        window.addEventListener('DOMContentLoaded', () => {
            this.initModules();
            this.options.onReady(this);
        });
    }
    static use(module) {
        Array.isArray(module) ? module.map(item => App.use(item)) : App.modules.push(module);
    }
    initModules() {
        App.modules.map(module => module.init && typeof module.init == 'function' && module.init(this));
    }
}
```


```js
import Track from 'path/to/Track';
export default {
    init(app) {
        app.track = new Track(app.options.track);
        app.track.tracking();
    }
};
```

```js
// index.js
import App from 'path/to/App';
import Router from './modules/Router';
import Track from './modules/Track';

App.use([Router, Track]);

new App({
    router: {
        mode: 'history',
    },
    track: {
        // ...
    },
    onReady(app) {
        // app.options ...
    },
});
```


### 123. TypeError: this.getOptions is not a function




It seems like sass-loader@11.0.0 doesn't work with vue@2.6.12.

I installed sass-loader@10.1.1 and it worked like a charm again.


### 124. npm link


执行npm link命令后，npm-link-module会根据package.json上的配置，被链接到全局，路径是`{prefix}/lib/node_modules/<package>`，这是官方文档上的描述，我们可以使用`npm config get prefix`命令获取到`prefix`的值(不过我这里使用的是windows，实际被链接到的路径是`{prefix}/node_modules/<package>`，不知道是不是npm升级的原因)，如果是win系统的话，实际观察，会发现在`{prefix}/lib/node_modules/<package>`路径下的`node-link-module`是一个快捷方式


### 125. vm._vnode 

vm._vnode 和 `vm.$vnode` 的关系就是一种父子关系，用代码表达就是 `vm._vnode.parent === vm.$vnode`



### 126. 解决封装van-list时v-model=“loaing”时报错“改变props”


比如自定义组件为match-list，引用的时候用`<match-list  v-model="loading" />`，match-list组件内部加上一个model和computed，使用的时候用vantLoading：

```js
model: {
    prop: 'loading',
    event: 'changeLoading',
  },
computed: {
    vantLoading: {
      get() {
        return this.loading;
      },
      set(val) {
        this.$emit('changeLoading', val);
      },
    },
  },
```

### 127. effect函数：副作用函数实际就是响应式数据在发生变更的时候，要执行的函数

### 128. node版本小于7的时候，不能识别async


### 129. Vuex

vuex中，mutation是同步的，用commit提交；action是异步的，用dispatch派发
- 异步操作：dispatch action -> commit mutation -> 修改state
- 同步操作：commit mutation -> 修改state

### 130. Codecc的Hack方法


1. 过滤掉反引号，可以解决sql的安全问题

2. codecc代码安全检测不识别includes，只能识别indexof，即不能识别es7的语法


### 131. git stash

常用git stash命令：

（1）`git stash save "save message"`  : 执行存储时，添加备注，方便查找，只有`git stash` 也要可以的，但查找时不方便识别。

（2）`git stash list`  ：查看stash了哪些存储

（3）`git stash show` ：显示做了哪些改动，默认show第一个存储,如果要显示其他存贮，后面加`stash@{$num}`，比如第二个 `git stash show stash@{1}`

（4）`git stash show -p` : 显示第一个存储的改动，如果想显示其他存存储，命令：`git stash show  stash@{$num}  -p `，比如第二个：`git stash show  stash@{1} -p`

（5）`git stash apply` :应用某个存储,但不会把存储从存储列表中删除，默认使用第一个存储,即`stash@{0}`，如果要使用其他个，`git stash apply stash@{$num}`， 比如第二个：`git stash apply stash@{1} `

（6）`git stash pop` ：命令恢复之前缓存的工作目录，将缓存堆栈中的对应stash删除，并将对应修改应用到当前的工作目录下,默认为第一个stash,即`stash@{0}`，如果要应用并删除其他stash，命令：`git stash pop stash@{$num}` ，比如应用并删除第二个：`git stash pop stash@{1}`

（7）`git stash drop stash@{$num}` ：丢弃stash@{$num}存储，从列表中删除这个存储

（8）`git stash clear` ：删除所有缓存的stash



### 132. cookie写入浏览器


```js
const DOMAIN = 'igame.qq.com';

function setCookie(name, value, Hours = 1) {
  const date = new Date(); // 获取当前时间
  const expiresDays = Hours;  // 将date设置为n天以后的时间
  date.setTime(date.getTime() + expiresDays * 24 * 3600 * 1000); // 格式化为cookie识别的时间
  document.cookie = `${name}=${value};expires=${date.toGMTString()};path=/;domain=${DOMAIN}`;  // 设置cookie
}

function writeToCookie(cookie) {
  const a = cookie.split('; ');
  const d = a.reduce((c, item) => {
    const temp = item.split('=');
    c[temp[0]] = temp[1];
    return c;
  }, {});
  Object.keys(d).map((item) => {
    setCookie(item, d[item]);
  });
}
```


## 三、基础

### 1. HTTP2.0

二进制分帧层，是HTTP 2.0性能增强的核心。 HTTP 1.x在应用层以**纯文本**的形式进行通信，而HTTP 2.0将所有的传输信息分割为更小的消息和帧，并对它们采用二进制格式编码。这样，客户端和服务端都需要引入新的二进制编码和解码的机制。 如下图所示，HTTP 2.0并没有改变HTTP 1.x的语义，只是在应用层使用二进制分帧方式传输。

二进制分帧层保留了HTTP的语义不受影响，包括首部、方法等，在应用层来看，和HTTP 1.x没有差别。同时，所有同主机的通信能够在**一个TCP连接**上完成。



参考：
1. [HTTP 2.0 原理详细分析](https://blog.csdn.net/zhuyiquan/article/details/69257126)
2. [HTTP2.0性能增强的核心：二进制分帧](https://blog.csdn.net/u011904605/article/details/53012844)


### 2. Base64原理

#### （1）原理

- 第一步，将待转换的字符串每三个字节分为一组，每个字节占8bit，那么共有24个二进制位。
- 第二步，将上面的24个二进制位每6个一组，共分为4组。
- 第三步，在每组前面添加两个0，每组由6个变为8个二进制位，总共32个二进制位，即四个字节。
- 第四步，根据Base64编码对照表（见下图）获得对应的值。


```
0　A　　17　R　　　34　i　　　51　z

1　B　　18　S　　　35　j　　　52　0

2　C　　19　T　　　36　k　　　53　1

3　D　　20　U　　　37　l　　　54　2

4　E　　21　V　　　38　m　　　55　3

5　F　　22　W　　　39　n　　　56　4

6　G　　23　X　　　40　o　　　57　5

7　H　　24　Y　　　41　p　　　58　6

8　I　　25　Z　　　42　q　　　59　7

9　J　　26　a　　　43　r　　　60　8

10　K　　27　b　　　44　s　　　61　9

11　L　　28　c　　　45　t　　　62　+

12　M　　29　d　　　46　u　　　63　/

13　N　　30　e　　　47　v

14　O　　31　f　　　48　w　　　

15　P　　32　g　　　49　x

16　Q　　33　h　　　50　y
```


举例：

| 文本      | M        | a        | n        |
| --------- | -------- | -------- | -------- |
| ASCII编码 | 77       | 97       | 110      |
| 二进制位  | 01001101 | 01100001 | 01101110 |


对二进制位重新分组


| 二进制位   | 010011 | 010110 | 000101 | 101110 |  |
| ---------- | ------ | ------ | ------ | ------ |
| 索引       | 19     | 22     | 5      | 46     |
| Base64编码 | T      | w      | F      | u      |



因此“Man”Base64编码之后就变为：TWFu。




#### （2）位数不足情况


- 两个字节：两个字节共16个二进制位，依旧按照规则进行分组。此时总共16个二进制位，每6个一组，则第三组缺少2位，用0补齐，得到三个Base64编码，第四组完全没有数据则用“=”补上。因此，“BC”转换之后为“QkM=”；



| 文本      | B        | C        |
| --------- | -------- | -------- |
| ASCII编码 | 66       | 67       |
| 二进制位  | 01000010 | 01000011 |


对二进制位重新分组：

| 二进制位   | 010000 | 100100 | 001100 |     |
| ---------- | ------ | ------ | ------ | --- |
| 索引       | 16     | 36     | 12     |     |
| Base64编码 | Q      | k      | M      | =   |




- 一个字节：一个字节共8个二进制位，依旧按照规则进行分组。此时共8个二进制位，每6个一组，则第二组缺少4位，用0补齐，得到两个Base64编码，而后面两组没有对应数据，都用“=”补上。因此，“A”转换之后为“QQ==”；


| 文本      | B        |
| --------- | -------- |
| ASCII编码 | 65       |
| 二进制位  | 01000001 |


对二进制位重新分组：

| 二进制位   | 010000 | 010000 |     |     |
| ---------- | ------ | ------ | --- | --- |
| 索引       | 16     | 16     |     |     |
| Base64编码 | Q      | Q      | =   | =   |


#### （3）作用

Base64都是可打印字符，可解决乱码问题。


#### （4）特点

1. Base64字符表中的字符原本用6个bit就可以表示，现在前面添加2个0，变为8个bit，会造成一定的浪费。因此，Base64编码之后的文本，要比原文大约三分之一。
2. 为什么使用3个字节一组呢？因为6和8的最小公倍数为24，三个字节正好24个二进制位，每6个bit位一组，恰好能够分为4组。
3. 大多数编码都是由字符串转化成二进制的过程，而Base64的编码则是从二进制转换为字符串。与常规恰恰相反，
4. Base64编码主要用在传输、存储、表示二进制领域，不能算得上加密，只是无法直接看到明文。也可以通过打乱Base64编码来进行加密。
5. 中文有多种编码（比如：utf-8、gb2312、gbk等），不同编码对应Base64编码结果都不一样。



参考：[一篇文章彻底弄懂Base64编码原理](https://blog.csdn.net/wo541075754/article/details/81734770)


### 3. Open Graph Protocol

og标签是一种新的http头部标记，即Open Graph Protocol（开放内容协议）。在页面添加这种协议可以让网页成为一个“富媒体对象”，表示同意网页内容可以被其他社会化网站引用等。

目前Facebook、人人等SNS网站都支持该协议。任何网页只要遵守该协议，SNS网站就能从页面上提取最有效的信息并呈现给用户；也能让SNS网站按照页面上og标签规定的内容呈现给用户。


比如：

```html
<meta property="og:title" content="The Rock" />
<meta property="og:type" content="video.movie" />
<meta property="og:url" content="https://www.imdb.com/title/tt0117500/" />
<meta property="og:image" content="https://ia.media-imdb.com/images/rock.jpg" />
```

参考：
1. [ogp.me/](https://ogp.me/)
2. [什么是og标签？什么是OG协议？](https://www.jianshu.com/p/dedd9a9aff4e)


### 4. git取消文件跟踪

如果要取消追踪dir：

```bash
$ git rm -r --cached dir # 不删除本地文件

$ git rm -r --f dir   # 删除本地文件
```


参考：[git取消文件跟踪](https://www.cnblogs.com/zhuchenglin/p/7128383.html)

### 5. 几个正则

- `'^$'`头尾相连，表示空行
- `\w`匹配字类字符，包括下划线，等于 `[0-9a-zA-Z_]`
- `\b`匹配单词的分隔，`grep ''\bx\b' passwd`


### 6. 基础图的区别


| 图表   | 维度       | 注意点                     |
| ------ | ---------- | -------------------------- |
| 柱状图 | 二维       | 只需比较其中一维           |
| 折线图 | 二维       | 适用于较大的数据集         |
| 饼图   | 二维       | 只适用反映部分与整体的关系 |
| 散点图 | 二维或三维 | 有两个维度需要比较         |
| 气泡图 | 三维或四维 | 其中只有两维能精确辨识     |
| 雷达图 | 四维以上   | 数据点不超过6个            |


### 7. mongodb远程连接命令

```
mongo mongodb://mongouser:username@x.x.x.x:xxxxx/dbname
```


### 8. semver

`semver`，语义化版本 `semantic version`。

版本号格式：主版本号，次版本号，修订号。


定义依赖版本号时：

- `^`，次版本号以及修订号为最新，主版本号不变。这种说法不完备。`^` 只会执行不更改最左边非零数字的更新，如果写入的是 ^0.13.0，可以更新到 0.13.1、0.13.2 等，但不能更新到 0.14.0 或更高版本。 如果写入的是 ^1.13.0，则当运行 npm update 时，可以更新到 1.13.1、1.14.0 等，但不能更新到 2.0.0 或更高版本。
- `~`，修订号为最新，次版本号及主版本号不变。如果写入的是 〜0.13.0，则当运行 npm update 时，会更新到补丁版本：即 0.13.1 可以，但 0.14.0 不可以。



参考：[semver 语义化版本规范](https://www.jianshu.com/p/a7490344044f)



### 9. MVC


#### （1）MVC

MVC模式其实就是单向通信：

1. 用户通过View传送指令到Controller
2. Controller完成业务逻辑，促使Model改变状态
3. Model 将新的数据发送到View，用户得到反馈


View => Controller => Model => View ...

```
           View

         /      \

 Controller  -->   Model
```

#### （2）MVP

MVP 模式将 Controller 改名为 Presenter，同时改变了通信方向。
1. 各部分之间的通信，都是双向的。
2. View 与 Model 不发生联系，都通过 Presenter 传递。
3. View 非常薄，不部署任何业务逻辑，称为"被动视图"（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。


View <=> Presenter <=> Model

```
         View 
    
      //

 Presenter   <-->    Model
```

#### （3）MVVM

MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。
唯一的区别是，**它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然**。

```
       View
 
     //

ViewModel  <-->  Model   
```

也就是说，MVVM 模式中 View 层也非常薄，没有任何业务逻辑，ViewModel 非常厚，含有很多逻辑。


参考：[MVC，MVP 和 MVVM 的图示](http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html)




### 10. XOR 运算

#### （1）XOR 运算有以下的运算定律

1. 一个值与自身的运算，总是为 false。

```
x ^ x = 0
```

2. 一个值与 0 的运算，总是等于其本身。

```
x ^ 0 = x
```

3. 可交换性

```
x ^ y = y ^ x
```

4. 结合性

```
x ^ (y ^ z) = (x ^ y) ^ z
```

#### （2）一道面试题

一个数组包含 n-1 个成员，这些成员是 1 到 n 之间的整数，且没有重复，请找出缺少的那个数字。

最快的解答方法，就是把所有数组成员（A[0] 一直到 A[n-2]）与 1 到 n 的整数全部放在一起，进行异或运算。

```
A[0] ^ A[1] ^ ... ^ A[n-2] ^ 1 ^ 2 ^ ... ^ n
```

上面这个式子中，每个数组成员都会出现两次，相同的值进行异或运算就会得到 0。只有缺少的那个数字出现一次，所以最后得到的就是这个值。

加法也可以解这道题。

```
1 + 2 +  ... + n - A[0] - A[1] - ... - A[n-2]
```

但是，加法的速度没有异或运算快，而且需要额外的空间。如果数字比较大，还有溢出的可能。


## 四、Linux

### 1. SSH配置config快速登录服务器


#### （1）本地操作

```bash
# 快速生成密钥
$ ssh-keygen -t rsa

# 进入ssh配置目录
$ cd ~/.ssh 

# 没有config文件的话需自己创建一个
$ ls 
```

在config文件中新增如下内容：

```bash
Host my
  HostName x.x.x.x
  Port 36000
  User root
  IdentityFile ~/.ssh/id_rsa # 这句可以省略
```


- Host后面是别名，u92的话就可以通过“ssh u92” 进行登录
- HostName为IP
- Port为端口
- User为用户名
- IdentityFile为自己ID私钥

#### （2）服务器操作

将自己的公钥写入`authorized_keys`中。


```bash
$ cd ~/.ssh 
$ cat authorized_keys
```





参考：[ssh配置config快速登录服务器](https://blog.csdn.net/ky1in93/article/details/83093981)





### 2. 管道命令和xargs的区别

`linux`命令可以从两个地方读取要处理的内容，一个是通过命令行参数，一个是标准输入。

1. 管道是实现“将前面的标准输出作为后面的标准输入” 
2. `xargs`是实现“将标准输入作为命令的参数” 

尝试运行以下代码，看下结果的不同。 

```bash
$ echo "--help"|cat 

$ echo "--help"|xargs cat 
```

如果你直接在命令行输入`cat`后回车，而不输入命令参数，这时`cat`会等待标准输入，你通过键盘输入内容并按回车，`cat`进程会读取输入并原样返回。所以如果此时你输入`–help`，那么cat程序会在标准输出上输出`–help`，这就是使用管道符时的情况。

然而使用`| xargs`时，就相当于直接将 `--help` 作为了 `cat` 命令的参数，执行了`cat --help`命令。

参考：[linux xargs与管道的区别](https://blog.csdn.net/whatday/article/details/105290814)





### 3. Linux环境变量文件

登录 Session 是用户登录系统以后，系统为用户开启的原始 Session，通常需要用户输入用户名和密码进行登录。

登录 Session 一般进行整个系统环境的初始化，启动的初始化脚本依次如下。

- `/etc/profile`：所有用户的全局配置脚本。
- `/etc/profile.d`目录里面所有.sh文件
- `~/.bash_profile`：用户的个人配置脚本。如果该脚本存在，则执行完就不再往下执行。
- `~/.bash_login`：如果`~/.bash_profile`没找到，则尝试执行这个脚本（C shell 的初始化脚本）。如果该脚本存在，则执行完就不再往下执行。
- `~/.profile`：如果`~/.bash_profile`和`~/.bash_login`都没找到，则尝试读取这个脚本（Bourne shell 和 Korn shell 的初始化脚本）。

Linux 发行版更新的时候，会更新/etc里面的文件，比如`/etc/profile`，因此不要直接修改这个文件。如果想修改所有用户的登陆环境，就在`/etc/profile.d`目录里面新建.sh脚本。

如果想修改你个人的登录环境，一般是写在`~/.bash_profile`里面。这个脚本定义了一些最基本的环境变量，然后执行了`~/.bashrc`。

参考：[Linux环境变量文件介绍](https://blog.csdn.net/pengjunlee/article/details/81585726)


### 4. kill与kill -9的区别

`kill - 9` 表示强制杀死该进程

参考：[kill与kill -9的区别](https://blog.csdn.net/yushouxiang2014/article/details/82876405)



### 5. 反斜杠

- 在Windows系统中，正斜杠 `/` 表示除法，用来进行整除运算；反斜杠 `\` 用来表示目录。
- 在Unix系统中，`/`表示目录；`\`表示跳脱字符将特殊字符变成一般字符（如`enter`,`$`,空格等）。



### 6. find命令

`find` 先接 `path`，然后是选项参数(`-()`)，然后是表达式`expression`。

- `find -name '*.c'` —— 查找符合某 shell 式样式的文件名的文件。用 `iname` 开启大小写不敏感搜索。

- `find -path 'test'` —— 查找符合某 shell 式样式的路径的文件。用 `ipath` 开启大小写不敏感搜索。

- `find -mtime -5` —— 查找近五天内编辑过的文件。你也可以用 `+5` 来查找五天之前编辑过的文件。

- `find -newer server.c` —— 查找比 `server.c` 更新的文件。

- `find -type d` —— 查找所有文件夹。如果想找出所有文件，那就用 `-type f`；找符号连接就用 `-type l`。

### 7. set命令

- `set -u` 等于 `set -o nounset`，遇到不存在的变量就会报错，比如直接 `echo $a`。有时需要暂时 `set +u`，暂时取消这个规则。
- `set -x` 等于 `set -o xtrace`，在运行结果之前，先输出执行的那一行命令
- `set -e` 等于 `set -o errexit`，只要脚本发生错误(返回值为非0代表失败)，就终止执行

- `set -o pipefail`，只要一个子命令失败，整个管道命令就失败，脚本就会终止执行。之前是`set -e`对管道命令不生效，其中一个子命令失败，整个管道命令依然成功。比如`foo | echo a`

- `set -E`，一旦设置了`set -e`，函数内部的错误不会被`trap`命令捕获，`-E`参数可以纠正这个行为。

连在一起使用

```bash
# 写法一
set -euxo pipefail

# 写法二
set -eux
set -o pipefail
```

另一种办法是在执行 Bash 脚本的时候，从命令行传入这些参数。

```bash
$ bash -euxo pipefail script.sh
```



### 8. cp命令

拷贝目录必须带-r

```bash
$ cp -r dir1 dir2
```

拷贝多个文件

```bash
$ cp source1 source2 source3 dest
```

删除文件/目录时显示详情 -v

```bash
$ rm -rfv test/
```


### 9. tree命令

`tree` 命令比 `ll` 命令更详细。

### 10. Nginx 配置反向代理

Nginx 配置反向代理 `proxy_pass http:/127.0.0.1:3066/` 最后一定要加斜杠！！！


### 11. 创建一个文件，写入三行数据


```bash
$ echo -e '123123\n123123\n123' > 123.txt
```


### 12. Bash检查目录是否存在

在Linux下，检查一个目录是否存在，不存在则创建的方法如下，通过shell文件

```bash
if [ ! -d dirname]; then
  mkdir dirname
fi
```

这里判断名称 dirname 的目录是否存在，如果不存在则通过 mkdir 创建 dirname 目录，如果是多层的目录，则可以用`mkdir -p`递归创建多层的目录。

### 13. crontab日志存放位置

默认情况下,crontab中执行的日志写在`/var/log`下,如:

```bash
$ ls /var/log/cron*
/var/log/cron /var/log/cron.1 /var/log/cron.2 /var/log/cron.3 /var/log/cron.4
```

### 14. echo输出的内容赋值给变量

```bash
$ data='123'
$ value=$( echo $data )
$ echo $value
123
```

上面的`$()`可以用`\`\``代替。

参考：[echo输出的内容赋值给变量](https://www.jianshu.com/p/129011d4bc43)



### 15.pm2查看日志命令

- 快速查看日志：`pm2 logs appname|id`
- 查看某一个项目的详情：`pm2 show appname|id`


### 16. Bash中eval的用法



```bash
$ eval command-line
```


其中`command－line`是在终端上键入的一条普通命令行。然而当在它前面放上`eval`时，其结果是Shell在执行命令行之前扫描它两次。如：

```bash
$ pipe="|"
$ eval ls $pipe wc -l
```


shell第1次扫描命令行时，它替换出`pipe`的值`｜`，接着`eval`使它再次扫描命令行，这时shell把`｜`作为管道符号了。

如果变量中包含任何需要shell直接在命令行中看到的字符（不是替换的结果），就可以使用`eval`。命令行结束符（`;｜&`），I／O重定向符（`< >`）和引号就属于对shell具有特殊意义的符号，必须直接出现在命令行中。


### 17. 读取文件中的服务器密码


比如有一个文件，存放服务器的域名和密码：

```
hostName=x.x.x.x
hostPwd=***
```

有一个脚本用来打包并上传文件，它会读取服务器地址和密码，并把文件上传到该服务器上。

```bash
#!/bin/sh
set -eux

function getHostInfo() {
  # 先获取域名或密码，然后赋值给参数，也就是hostName或者hostPwd
  eval $1=$(awk -F '=' '$1 == "'$1'"  {print $NF}' server.pwd)
}

fileName=work-weixin-robot
tarFileName=${fileName}.tar.gz

getHostInfo hostName
getHostInfo hostPwd


rm -rf ./$tarFileName
tar --exclude=node_modules/ --exclude=test/ --exclude=output/ --exclude=build.sh -zcvf $tarFileName ./*


expect -c "
        set timeout 1200;
        spawn scp -P 36000 -r $tarFileName root@$hostName:/root/ft_local
        expect {
                \"*yes/no*\" {send \"yes\r\"; exp_continue}
                \"*password*\" {send \"$hostPwd\r\";}
               }
expect eof;"
```


### 18. linux下tar命令解压到指定的目录 

```bash
tar zxvf /bbs.tar.zip -C /zzz/bbs    
```

把根目录下的bbs.tar.zip解压到/zzz/bbs下，前提要保证存在/zzz/bbs这个目录 

这个和cp命令有点不同，cp命令如果不存在这个目录就会自动创建这个目录！

附：用tar命令打包

例：将当前目录下的zzz文件打包到根目录下并命名为zzz.tar.gz

```bash
tar zcvf /zzz.tar.gz ./zzz
```
参考：[linux下tar命令解压到指定的目录](http://blog.sina.com.cn/s/blog_62449fcf0100nfar.html)


### 19. Linux下的date命令

date 可以用来显示或设定系统的日期与时间。
```js
-d<字符串>：显示字符串所指的日期与时间。字符串前后必须加上双引号； 
-s<字符串>：根据字符串来设置日期与时间。字符串前后必须加上双引号； 
-u：显示GMT； 
--help：在线帮助； 
--version：显示版本信息。
```

如果需要以指定的格式显示日期，可以使用“+”开头的字符串指定其格式

```bash
date "+现在时间是：%Y-%m-%d %H:%M:%S"
# 现在时间是：2021-05-07 09:37:01
```

如果要显示的时间不是当前时间，而是经过运算的时间，则可以用-d选项。例如显示三年前的时间：
```bash
date +"%Y-%m-%d %H:%M:%S" -d "-3 year"
# 2018-05-07 09:39:46
```

有时候需要获取当前时间距离1970年0时0分0秒所经历的秒数，保存在变量中：
```bash
time=`date "+%s"
echo $time
# 1620351114
```




参考：[Linux date命令的用法](https://www.cnblogs.com/asxe/p/9317811.html)


### 20.  top命令按内存和cpu排序


- 按内存排序：大写M
- 按CPU排序：大写P

TOP完整命令：

```
c： 显示完整的命令
d： 更改刷新频率
f： 增加或减少要显示的列(选中的会变成大写并加*号)
F： 选择排序的列
h： 显示帮助画面
H： 显示线程
i： 忽略闲置和僵死进程
k： 通过给予一个PID和一个signal来终止一个进程。（默认signal为15。在安全模式中此命令被屏蔽）
l:  显示平均负载以及启动时间（即显示影藏第一行）
m： 显示内存信息
M： 根据内存资源使用大小进行排序
N： 按PID由高到低排列
o： 改变列显示的顺序
O： 选择排序的列，与F完全相同
P： 根据CPU资源使用大小进行排序
q： 退出top命令
r： 修改进程的nice值(优先级)。优先级默认为10，正值使优先级降低，反之则提高的优先级
s： 设置刷新频率（默认单位为秒，如有小数则换算成ms）。默认值是5s，输入0值则系统将不断刷新
S： 累计模式（把已完成或退出的子进程占用的CPU时间累计到父进程的MITE+ ）
T： 根据进程使用CPU的累积时间排序
t： 显示进程和CPU状态信息（即显示影藏CPU行）
u： 指定用户进程
W： 将当前设置写入~/.toprc文件，下次启动自动调用toprc文件的设置
<： 向前翻页
>： 向后翻页
?： 显示帮助画面
1(数字1)： 显示每个CPU的详细情况
```


### 21. 软连接：ln -s 源文件 目标文件。


如：
```
ln -s /usr/local/mysql/bin/mysql /usr/bin
```




## 五、业务


### 1. 前端鉴权

权限页面，用`computed`属性表示是否有权限，可以在`computed`中进行跳转，只是要用个标志位，否则会陷入死循环。

```js
computed: {
  // 是否显示资质审核tab
  hasCertAuditTab() {
    const { certRole } = this.$store.state.authority || {} ;
    const result = !!certRole && !this.isPvp && !this.isGPVersion;
    if (result && !jumped) {
      jumped = true;
      this.onChangeTab('cert');
    }
    return result;
  },
}
```

### 2. 不要用二维数组

二维数组可以拆分成`[ { title: xx, children: [] } ]`，更容易维护！！！


### 3. 表单要做到数据驱动，否则后期难以维护


### 4. 页面多个tab的话，许多数据都需要设置成对象的形式


页面多个tab的话，dataList、loadings、endFlags、pageIdxes都需要设置成对象的形式，然后根据curTab取当前值。

这样的好处是简单，维护方便，不用写myDataList、allDataList，这种多标记，很难维护。


### 5. vue如果模块引入路径错误，也有可能报错：TypeError: Object(...) is not a function 

报这种错误信息的另一个场景是，把写在methods的方法写在了data中

### 6. 实名认证输入框的时候，会有横竖屏提示，所以有输入框的时候可以用样式去掉提示。



### 7. 要获取游戏圈链接，分享给好友，快速点击右上角，有复制链接按钮


### 8. 发布

- feature->develop -> 发布测试 
- hotfix-release  -> 发布测试 -> 审核 -> 发布正式
- relase -> develop
- develop -> release -> 发布测试 -> 审核 -> 发布正式


### 9. VSCode中对一行的css进行换行

```
\s\{([\s\S]+)

 {\n  $1
```



### 六、Android

(1) Android 四大组件

1. Activity: 负责用户界面的展示和用户交互,学习Activity就要学习Fragment，虽然它不是四大组件之一，但是它在我们的开发工作中也是频频被使用到，且必须和Activity一块使用，常用于分模块开发，比如慕课首页的几个tab,每个tab都是对应着一个Fragment.

2. Service服务：不需要和用户交互，负责后台任务，比如播放音乐，socket长连接

3. BroadcastReceiver广播接收者: 负责页面间通信，系统和APP通信，APP和APP通信，比如监听网络连接状态变化，就是通过BroadcastReceiver广播接收者来实现的

4. ContentProvider内容提供者: 负责数据存取，常用于APP进数据共享，跨进程数据存取等....比如读取相册，读取联系人，都是ContentProvider来实现的






(2) noActionBar没有状态栏

RecyclerView控件的名称：androidx.recyclerview.widget.RecyclerView




(3) 设置textView的跑马灯效果，需要设置下面两个属性

- android:ellipsize="marquee"
- android:marqueeRepeatLimit="marquee_forever"

textView默认不可点击，加上clickable="true"，就可以点击




(4) 对textview设置layout_width为match-parent，即和linearout宽度进行匹配






(5) 按住option+enter可以快速实现方法



(6) mainActivity.kt中的setContentView(R.layout.activity_main)决定使用哪个布局文件









(7) MaterialButtonToggleGroup继承关系，可以看出viewGroup继承自View，MaterialButtonToggleGroup继承自LinearLayout

java.lang.Object
   ↳android.view.View
        ↳android.view.ViewGroup
             ↳android.widget.LinearLayout
                  ↳com.google.android.material.button.MaterialButtonToggleGroup








(8) materialButton继承自button，button继承自textview，所以有android:text、android:textSize等属性 

materialButton在xml中名称是com.google.android.material.button.MaterialButton

materialButton属性没有提示的话，把    xmlns:app="http://schemas.android.com/apk/res-auto" 写在布局容器中，然后就可以使用app这个命名空间了。

在text属性中写&会报错，&符号不支持在xml文件中使用

给materialButton添加icon示例：   app:icon="@android:drawable/star_on"

默认iconGravity是start，也就是button的最前面出现，还可以是textStart、textEnd，在文本的前面和后面。

消除阴影，可以设置style：        style="@style/Widget.MaterialComponents.Button.UnelevatedButton"





(9) 添加依赖在app/build.gradle下面添加，比如添加'com.google.android.material:material:1.3.0'。
在dependencies中增加     implementation 'com.google.android.material:material:1.3.0' 。然后点击sync now，会把依赖下载到本地。



(10) 修改主题，先去app/src/main/AndroidManifest.xml中，找到主题，然后command+鼠标左键，进入，修改parent属性，改成想要的









(11) FrameLayout属性：

组件的默认位置都是左上角，组件之间可以重叠。像千层饼一样，一层压着一层 可以设置上下左右的对齐、水平垂直居中、设置方式与线性布局相似

常用属性
属性 可选值 说明
layout_gravity center/center_vertical/center_horizontal 组件相对父容器的位置
layout_marginLeft 具体的数值100dp 左侧外间距
layout_marginTop 具体的数值100dp 上侧外间距
layout_marginRight 具体的数值100dp 右侧外间距
layout_marginBottom 具体的数值100dp 下侧外间距






(12) button的insetTop和insetBottom默认大于0dp，背景色都不会填充。这两个属性IDE不会智能提示，只能自己敲，android:insetTop="0dp"。

设置id，android:id="@+id/btn1"







(13) RelativeLayout元素属性

相对于父元素 7个常用属性
属性 可选值 说明
layout_alignParentTop true/false 是否让控件相对于父容器顶部对齐
layout_alignParentBottom true/false 是否让控件相对于父容器底部对齐
layout_alignParentLeft true/false 是否让控件相对于父容器左边对齐
layout_alignParentRight true/false 是否让控件相对于父容器右边对齐
layout_centerHorizontal true/false 相对父容器水平居中显示
layout_centerVertical true/false 相对父容器垂直居中显示
centerInParent true/false 相对父容器居中显示

相对于兄弟元素 4个常用属性
属性 可选值 说明
layout_above @+id/ 指定在那个控件的上侧
layout_below @+id/ 指定在那个控件的上侧
android:layout_toLeftOf @+id/ 指定在那个控件的左侧
android:layout_toRightOf @+id/ 指定在那个控件的右侧

相对于兄弟元素的对齐方式
属性 可选值 说明
layout_alignLeft @+id/ 该控件的左边沿与指定控件的左边对齐
layout_aliginRight @+id/ 该控件的右边沿与指定控件的右边对齐
layout_alignTop @+id/ 该控件的上边沿与指定控件的上边沿对齐
layout_alignBottom @+id/ 该控件的下边沿与指定控件的下边沿对齐








(14) 只有LinearLayout的子元素可以使用layout_weight，相对布局等其他布局不可以





(15) linearLayout如果设置了orientation是vertical，那么如果对子元素button再设置layout_gravity为center_vertical会无效，因为父元素要保证它们从上到下按序排列。
也就是说子元素设置的layout_gravity(center_vertical)如果和父元素的orientation(vertical)方向一致的话，就会失效。

linearLayout的orientation如果是horizontal时，对一个控件设置了layout_weight后，layout_width就会失效，所以将layout_width设置为0dp。如果Linearlayout的orientation是vertical，layout_height会失效。








(16) 高版本中，button设置背景色不能用background，需要用backgroundTint





(17) 写布局文件，在src/main/res/layout中，new Layout Resource File。先把root element设置为LinearLayout




(18) layout_gravity：决定该容器相对它的父容器的位置

1.center：该容器相对于它的父容器居中显示
2.horizontal_center:该容器横向方向上相对它的父容器居中显示
3.vertical_center:该容器纵向方向上相对它的父容器居中显示






(19) gravity：决定子控件相对该父容器的位置 

1.center：所有子视图相对于父容器居中显示
2.horizontal_center:所有子容器的横向方向上相对父容器居中显示
3.vertical_center:所有子视图的纵向方向上相对父容器居中显示





(20) layout_width
layout_height 

1.match_parent:填充父容器的剩余空间
2.wrap_content:根据子视图宽高自适应自己的宽高
3.自定义大小50dp





