关于滚动条，有几个公式要先了解下：

```
scale 
= scrollBarThumb.clientHeight / scrollBar.clientHeight 
= page.clientHeight / page.scrollHeight  
= page.scrollTop / (scrollBar.clientHeight - scrollBarThumb.clientHeight)
```

翻译下就是：


```
缩放比例 
= 滑块高度 / 滚动条高度 
= 页面可视区高度 / 页面总高度 
= 页面可视区顶部距离 / 滑块顶部距离
```


比如：
- 比例是5
- 滑块高度是1，滚动条高度是6
- 页面可视区高度为5， 页面总高度为30
- 页面可视区顶部距离为25，滑块顶部距离为5

```
5 / 1 = 30 / 6 = (30 - 5) / (6-  1)
```

下面是基本的结构，一个scrollBar包住scrollBarThumb：

```html
<div
  v-show="scrollBarNum>2 && (showThis || isHoldDown)"
  ref="scrollBar"
  class="tip-match-scrollbar"
  :class="{'tip-match-scrollbar--active': isHoldDown}"
  :style="{height: `${scrollBarTotalHeight}px`}"
  @click.stop="onClickScrollBar"
>
  <div
    ref="scrollBarThumb"
    class="tip-match-scrollbar-thumb"
    :style="{transform:`translate3d(0,${scrollTranslateY}px,0)`, height: `${scrollBarHeight}px`}"
    @touchmove="onTouchMoveScrollBar"
    @touchstart="onTouchStartScrollBar"
    @touchend="onTouchEndScrollBar"
  >
    <div class="tip-match-team-member-tip">
      {{ +currentPageNum }}/{{ Math.ceil(scrollBarNum) - 1 }}页
    </div>
  </div>
</div>
```

scrollBarThumb拖动时的几个事件：

```js
let startY = 0;
let disY = 0;
let showThisTimer = null;
let holdDownTimer = null;

onTouchStartScrollBar(e) {
  clearTimeout(holdDownTimer);
  
  holdDownTimer = setTimeout(() => {
    this.isHoldDown = true;
  }, 200);

  startY = e.touches[0].clientY;
  disY = startY - this.scrollTranslateY;
},
onTouchMoveScrollBar(e) {
  if (!this.isHoldDown) return;
  e.preventDefault();

  this.showThis = true;
  clearTimeout(showThisTimer);
  showThisTimer = setTimeout(() => {
    this.showThis = false;
  }, 2000);

  const endY = e.touches[0].clientY;
  const { scrollBar, scrollBarThumb } = this.$refs;
  const { pageScrollRef } = this;

  let T = endY - disY;
  const maxTop = scrollBar.clientHeight - scrollBarThumb.clientHeight;

  if (T < 0) {
    T = 0;
  } else if (T > maxTop) {
    T = maxTop;
  }
  this.scrollTranslateY = T;
  this.$forceUpdate();

  // 页面主体滚动
  const scale = pageScrollRef.scrollHeight / scrollBar.scrollHeight;
  let scrollTop = T * scale;
  if (T === maxTop) {
    scrollTop = pageScrollRef.scrollHeight - pageScrollRef.clientHeight;
  }
  pageScrollRef.scrollTo(pageScrollRef.scrollLeft, scrollTop);

  this.currentPageNum = scrollTop === 0 ? 1 : Math.ceil(scrollTop / pageScrollRef.clientHeight) ;
},
onTouchEndScrollBar() {
  clearTimeout(holdDownTimer);
  this.isHoldDown = false;
},
```

点击scrollBar的某一处时的事件：

```js
onClickScrollBar(e) {
  const { offsetY } = e;
  const { scrollBarThumb, scrollBar } = this.$refs;
  const { pageScrollRef } = this;
  
  let T = offsetY - disY;
  const maxTop = scrollBar.clientHeight - scrollBarThumb.clientHeight;
  if (T < 0) {
    T = 0;
  } else if (T > maxTop) {
    T = maxTop;
  }

  this.scrollTranslateY = T;

  if (pageScrollRef) {
    pageScrollRef.scrollTo(
      pageScrollRef.scrollLeft,
      (offsetY / scrollBarThumb.clientHeight) * pageScrollRef.clientHeight
    );
  }
},
```

此外还有一个监听页面主体滚动的方法：

```js
onScrollMain(e) {
  if (this.isHoldDown) return;
  const { scrollTop, clientHeight } = e.target;
  const { pageScrollRef, scrollBarTotalHeight } = this;

  this.showThis = true;
  clearTimeout(showThisTimer);
  showThisTimer = setTimeout(() => {
    this.showThis = false;
  }, 2000);

  const scale = pageScrollRef.scrollHeight / scrollBarTotalHeight;
  this.currentPageNum = scrollTop === 0 ? 0 : Math.floor(scrollTop / clientHeight) ;
  this.scrollTranslateY = scrollTop / scale;
}
```